<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python之Pandas库躺坑记</title>
      <link href="posts/617073a5/"/>
      <url>posts/617073a5/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​        最近在开发一个线上用例管理平台，需要使用 <code>Python语言</code> 对 <code>Excel文件</code> 进行一系列的操作，网上大致搜索了下常用的库，最后决定使用 <code>Pandas</code> 库（原因就不具体阐述了）。在使用的过程中，大部分的需求都能满足，但是还是有部分需求通过不断躺坑最终解决了。</p><p>Pandas 库常用的方法就不一一阐述了，可以参考如下链接。</p><ul><li><p><a href="http://www.fixbbs.com/p/0844377.html">Python Pandas读取修改excel操作攻略</a> </p></li><li><p><a href="https://blog.csdn.net/zhangchuang601/article/details/79583551">Pandas DataFrame数据的增、删、改、查</a></p></li></ul><p>在此将整个过程中遇到的一些特定的问题进行记录┑(￣。。￣)┍ ┑(￣。。￣)┍ 。</p><a id="more"></a><h3 id="特殊问题"><a href="#特殊问题" class="headerlink" title="特殊问题"></a>特殊问题</h3><h4 id="问题1-部分Excel文件单元格进行了合并或者单元格内容为空"><a href="#问题1-部分Excel文件单元格进行了合并或者单元格内容为空" class="headerlink" title="问题1. 部分Excel文件单元格进行了合并或者单元格内容为空"></a>问题1. 部分Excel文件单元格进行了合并或者单元格内容为空</h4><p>需要对合并了的单元格或者单元格内容为空的进行内容，通过Debug发现此时值为 <code>Nan</code>。</p><p><strong>解决办法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将单元格的值赋值给data</span></span><br><span class="line">data = df.iloc[iRow, iCol]</span><br><span class="line"><span class="comment"># 通过如下方法判断 data 是否为 Nan， 是则返回 True。</span></span><br><span class="line"><span class="built_in">isinstance</span>(data, <span class="built_in">float</span>) <span class="keyword">and</span> math.isnan(df.iloc[iRow, iCol])</span><br></pre></td></tr></table></figure><h4 id="问题2-使用Panads的to-excel方法会覆盖其他所有的sheet"><a href="#问题2-使用Panads的to-excel方法会覆盖其他所有的sheet" class="headerlink" title="问题2. 使用Panads的to_excel方法会覆盖其他所有的sheet"></a>问题2. 使用Panads的to_excel方法会覆盖其他所有的sheet</h4><p>具体问题：在使用pandas的 <code>df.to_excel(file_path)</code> 想要对一个有多张sheet的workbook操作时一定会尴尬的发现：永远只存在最后一次写进去的表，其他的sheet表都被清空了，并且最后一次写进去的表的样式也未保存。</p><p><strong>解决办法：</strong> <a href="https://zhuanlan.zhihu.com/p/85918022">参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># file_abs_path excel文件的绝对路径</span></span><br><span class="line">excel_sheet_handle = pd.read_excel(file_abs_path, sheet_name=<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="comment"># ... 中间对 sheet1 进行一系列值的改动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过下方的代码将其他 sheet 的内容与最新的 sheet1 表进行合并。</span></span><br><span class="line">book = openpyxl.load_workbook(file_abs_path)</span><br><span class="line">writer = pd.ExcelWriter(file_abs_path, engine=<span class="string">&#x27;openpyxl&#x27;</span>)</span><br><span class="line">writer.book = book</span><br><span class="line"></span><br><span class="line">writer.sheets = <span class="built_in">dict</span>((ws.title, ws) <span class="keyword">for</span> ws <span class="keyword">in</span> book.worksheets)</span><br><span class="line"><span class="comment"># index 为序号, header 为原来的表头</span></span><br><span class="line">excel_sheet_handle.to_excel(writer, sheet_name=<span class="string">&quot;sheet1&quot;</span>, index=<span class="literal">False</span>, header=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>通过如上的办法就可以将所有表都保存下来，并且保存了原有的样式， sheet1表的内容也修改正确。</p><h4 id="问题3-使用了问题2的办法后，使用Panads-drop-方法在最后出现重复行。"><a href="#问题3-使用了问题2的办法后，使用Panads-drop-方法在最后出现重复行。" class="headerlink" title="问题3. 使用了问题2的办法后，使用Panads.drop()方法在最后出现重复行。"></a>问题3. 使用了问题2的办法后，使用Panads.drop()方法在最后出现重复行。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file_abs_path excel文件的绝对路径</span></span><br><span class="line">excel_sheet_handle = pd.read_excel(file_abs_path, sheet_name=<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="comment"># 将文件的第2、3行删除掉</span></span><br><span class="line">excel_sheet_handle.drop([<span class="number">1</span>, <span class="number">2</span>], inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>具体问题现象</strong>如下：存在文件A，里面的sheet1表中有4行数据（如下），通过上述代码的drop删除后， 再调用问题2中的办法进行保存，发现sheet1表中仍然有4行， 内容为原来的第1、4、3、4 行内容，实际预期应该只是第1、4行的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># excel_sheet_handle.drop([1, 2], inplace=True)</span></span><br><span class="line"><span class="comment"># 原数据</span></span><br><span class="line">   A   B   C   D</span><br><span class="line">0  0   1   2   3</span><br><span class="line">1  4   5   6   7</span><br><span class="line">2  8   9  10  11</span><br><span class="line">3  3   2   6   7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预期应该为：</span></span><br><span class="line">   A   B   C   D</span><br><span class="line">0  0   1   2   3</span><br><span class="line">3  3   2   6   7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际结果为：</span></span><br><span class="line">   A   B   C   D</span><br><span class="line">0  0   1   2   3</span><br><span class="line">3  3   2   6   7</span><br><span class="line">2  8   9  10  11</span><br><span class="line">3  3   2   6   7</span><br></pre></td></tr></table></figure><p><strong>具体原因：</strong> 由于问题2中进行了原来的sheet内容读取，所以在writer中也记录了原来的 sheet1 的内容，导致 writer 在写入的时候又重新将原来的第3、4行与实际的 第1、4行进行了合并。</p><p><strong>最终解决办法</strong>（根据上述的实例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">max_row = <span class="number">4</span></span><br><span class="line"><span class="comment"># 共删除了2、3两行，所以删除的行数为2</span></span><br><span class="line">delete_row_count = <span class="number">2</span></span><br><span class="line">change_sheet = writer.sheets[<span class="string">&quot;sheet1&quot;</span>]</span><br><span class="line"><span class="comment"># 删除原来重复合并的第 3、4行。</span></span><br><span class="line">change_sheet.delete_rows(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">writer.save()</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        只有真的多面对几次现实中的需求，才能真的掌握一个库的使用。。。否则仅仅是最基础的 <code>Demo</code> 演练。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandas </tag>
            
            <tag> Python </tag>
            
            <tag> excel文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构化思维</title>
      <link href="posts/ec1ab3bc/"/>
      <url>posts/ec1ab3bc/</url>
      
        <content type="html"><![CDATA[<h3 id="结构化思维"><a href="#结构化思维" class="headerlink" title="结构化思维"></a>结构化思维</h3><p>​    什么是结构化思维呢？在本书第一章 第三节简单介绍了结构化思维， 书上所举的鲁班的例子，但个人感觉上鲁班的思维与结构化思维也不太相似，因此对于结构化思维更加迷惑。。。（可能比较愚钝╮(╯Д╰)╭ 😭）</p><p>​    我在这里个人重新理解下：<font color=red><strong>结构化思维 =&gt; 结构化的做事方式</strong></font>，具体见如下两个实例。</p><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>​    通过网上查找的一些资料，如下两个实例体现出了结构化思维：</p><h4 id="场景一：记忆词组"><a href="#场景一：记忆词组" class="headerlink" title="场景一：记忆词组"></a>场景一：记忆词组</h4><p>有下图的一串词组让你来记忆，</p><img src="https://i.loli.net/2021/03/03/FH2QGJbpRXNKcmx.png" alt="结构化思维-1.png" style="zoom: 33%;" /><p><strong>方式一：</strong></p><p><strong>上来就马上开始从前到后的记忆，那么这个记忆的效果可能不太理想，要是数量越多，那效果一般越差</strong>。（<em>此处排除过目不忘的大佬。。。</em>）这种做事方式一般比较低效。<font color=red>就如像我一样刚入职场时┑(￣。。￣)┍ ，在领导布置任务后一般都不思考就马上一股脑动手了，很可能最后结果就是效率低下并且结果与领导希望得到的结果背道而驰。</font></p><img src="https://i.loli.net/2021/03/03/rBAd5syXfHE3zWM.png" alt="结构化思维-2.png" style="zoom:40%;" /><p><strong>方式二：</strong></p><p>一般经过学校或者工作的锻炼，部分人就会掌握一些比较巧妙的做事方式，比如：在看到上面词组后，大家会先将所有词组进行一个分类归纳，然后再来记忆，虽然从数量上反而还新增了3个节点（蔬菜、水果、动物），但实际在记忆的效率上肯定比方式一要高效。</p><h4 id="场景二：新人入职任务"><a href="#场景二：新人入职任务" class="headerlink" title="场景二：新人入职任务"></a>场景二：新人入职任务</h4><p>很多人应该都经历过新人入职培训，培训上面可能会布置一些新人入职第一天的任务，那你还记得培训上有哪些任务吗？比如讲师就将如下图的内容展示给你们，你们估计也就是填鸭式将一天课程从头到尾听一遍，事情过了就完了。</p><img src="https://i.loli.net/2021/03/03/1Bd9gmSQIwzUhLb.png" alt="结构化思维-4.png" style="zoom:33%;" /><p>上图就是普通的做事方式，从头到尾来一遍。</p><p>这个时候依然参考结构化思维，更好的办法是先让大家了解这些任务之间的关系，然后再从更小的一个维度去让大家了解具体任务是什么，如下图：</p><img src="https://i.loli.net/2021/03/03/voQyqiHkV8aB4s6.png" alt="结构化思维-3.png" style="zoom:33%;" /><p>通过上述结构化后的任务，更加容易理解需要做的任务以及之间的关联性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    通过上述的两个实例后，我大概对结构化思维有了如下的一些见解：</p><p>​    ⚠️ 个人理解：每个实例中的后者就是<strong>结构化</strong>的做事方式，前者则为普通的思维（做事）方式，当然除了结构化的做事方式我理解还有更多其他成熟的做事方式，每种方式可能解决的场景又不太一样。</p><p>结构化思维可以解决如下类型的问题：</p><ul><li>遇到大问题脑子一团乱，不知如何下手；</li><li>说了一堆话，别人却表示听不懂；</li><li>想写文章，却毫无思路，无从下笔。</li></ul><p>结构化的做事方式具体步骤如下：</p><ol><li>先所有的信息/任务收集在一起；</li><li><strong>将所有信息/任务在已知的认知中，进行一个加工、归纳分组，形成多个更小的有条理和逻辑的分组，每个分组与上下之间都是有紧密联系的；</strong></li><li>如果下层分组过大，则可以将下层分组再次重复步骤2分成更小的分组。（<strong>存在一些极端场景：那就是所有的信息/任务没有任何关联</strong>）；</li><li>处理/记忆 每个分组。</li></ol><p>所以，结构化思维的核心就是： “<strong>拆分任务为多个有逻辑联系的小任务</strong>“。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思维的影响</title>
      <link href="posts/1f0a8761/"/>
      <url>posts/1f0a8761/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    很多时候，<strong>你可能不知道思维对你的生活到底造成了多大的影响</strong>。（就如同以前的我。。。此处可将<font color=red><strong>思维替换为看法</strong></font>）刚好最近看了一部电影一一<strong>华仔的《拆弹专家2》</strong>，里面很明显的展示出了不同的思维对主角（刘德华）带来了多大的影响。</p><p>​    <font color=gray>备注：可能很多地方也推荐《金字塔原理》，但我个人觉得如果是入门可以先看《结构化思维》，里面有更多的实例，让人理解起来更加浅显易懂。</font></p><a id="more"></a><h3 id="思维的意义"><a href="#思维的意义" class="headerlink" title="思维的意义"></a>思维的意义</h3><p>​    <font color=blue><strong>思维的意义，它是我们解读事实的起点，是产生行为的源头，是决定结果的根本。</strong></font></p><p>​    本书中刚开始就用了很多比较形象的案例阐述了思维在这些案例中的影响（意义），我个人理解思维在情绪上大致可以总结为：<code>积极的思维</code> 和 <code>消极的思维</code> 两种（有兴趣可以自行查阅书中的案例）。</p><p>​    <font color=blue>在不同的思维下，对于做事情的态度和行为也会天差地别。</font></p><p><strong>从以下几个大部分人可能都经历过的实际场景来看</strong>（平时工作中的年终考核或者季度考核）<font color=gray><em>我不以偏概全，但如果把我自己代入到这个场景后我可能会有如下看法。</em></font></p><ul><li><p><strong>你得知你自己的绩效较差或者你觉得自己能拿A，但是实际只给了你B。</strong></p><p>以前的我第一看法可能就是：<strong>搞什么鬼？， 这领导是给我穿小鞋吧，然后开始对于后面的工作有所松懈，更极端点就是离职</strong>。</p></li><li><p><strong>在上面的场景下，你得知自己只得到了B，小明得到了A（并且你觉的小明不如自己）。</strong></p><p>以前的我第一看法可能是：<strong>他做的和我一样呀，感觉都还不如我做的好，不会是靠拍马屁上去的吧？</strong></p></li></ul><p>先不管上面的猜测或者臆断的看法是否是正确的，但是可以发现产生我上述的看法的根本原因之一就是一一<code>消极思维</code>。以至于对后面的工作也可能越做越差，那后续的绩效也可想而知。</p><p>⚠️ 注意：<strong>道理可能大家都懂，但是真的碰到后不按照道理说的来做那还不如不懂这个道理！！！</strong></p><p>看了这章节后，我明白了思维的重要性，现在的我至少在再次面对上面的场景时候，我能从更深层次去思考问题，关于上述的实例场景，具体可以分为如下几个步骤：</p><ol><li><strong>先保持冷静以及抛开所有上述自己开始的猜想或者臆断</strong>（如果有这些主观因素影响的话，后面的步骤可能效果不佳）；</li><li><strong>仔细思考下这一年或者这一个季度自己做的东西是否真的如自己想象中那么好？</strong><ul><li>如果是自己真的做的不好，那么后面<strong>需要进行反省以及制定对应的改进计划</strong>，并且将自己的改进计划与领导进行核对确认，避免大方向错误。（这牵涉到<strong>向上管理</strong>，有兴趣的可以搜索这方面书籍）；</li><li>如果真的是自己做的好，那么总结出自己做的好的内容，与领导进行核对，确认是否两端有误会，<strong>而不是直接放手不干</strong>。</li></ul></li><li><strong>仔细思考下小明是不是真的不如自己？</strong><ul><li>如果小明真的是不如自己，那么总结出自己做的比小明好的地方，与领导进行核对，确认是否两端有误会，<strong>而不是背地里猜忌</strong>。</li><li>如果小明真的做的比自己好，那么就需要<strong>提取出小明的优势，然后制定自己的改进计划，并且将自己的改进计划与领导进行核对确认，避免误解了小明做的好的地方。</strong></li></ul></li></ol><p><font color=gray><em>但如果上述步骤做了后，发现确实不是自己的问题的时候，如何抉择很重要，但绝不能因为这件事而影响以后的工作或者生活。</em></font></p><h3 id="本节总结"><a href="#本节总结" class="headerlink" title="本节总结"></a>本节总结</h3><p>​    最后还是再强调一句：<code>如果过往事实不能改变，我们就只能改变思维，改变面对事实的态度和行为，让未来过得更好，避免发生悲剧。改变思维才是改变一切的源头。</code></p><p>​    发生任何事情， <code>积极思维</code> 一般都比 <code>消极思维</code> 要好，当然有时候一些悲伤的事情，适当的 <code>消极思维</code> 也是可以的，但一定要注意及时调整自己的思维，否则浪费的就是自己的时间。（可能大家有更好的见解💡，欢迎一起讨论实践）。 </p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周报的意义</title>
      <link href="posts/6241996/"/>
      <url>posts/6241996/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在从刚开始工作至工作5年后，都对周报的作用没有太大的了解，并且<strong>觉得是一件浪费时间又不讨好的事情</strong>。至今我才恍然大悟，庆幸为时不晚。</p><p>​    写周报，在公司里每周都会发生，大部分情况下，周围的人都对周报没有表现出太大的兴趣，有人则对它异常反感，甚至称它是<strong>“职场鸡肋”</strong>；还有人有这样的疑问：<strong>每周雷同的“僵尸”周报浪费时间和精力，真的有存在的必要吗？</strong>而且，我们辛辛苦苦写的周报老板到底看了没有？</p><p>或多或少，大家应该都可能有过如下类似的想法：</p><blockquote><p>  【小明】忙了一周了但是周报上不知道该写啥？老板看没看呢？</p><p>  【小明】我做了什么领导不知道吗?记录一周的工作内容有什么价值？随便写写算了~</p><p>  【小明】每周忙的都是一样的，这个能写出个什么花来？</p></blockquote><a id="more"></a><h3 id="周报是否-“鸡肋”？"><a href="#周报是否-“鸡肋”？" class="headerlink" title="周报是否 “鸡肋”？"></a>周报是否 “鸡肋”？</h3><p>答案肯定是否！</p><p>周报是<strong>职场通用基本功之一，员工通过每周周报的反复练习，不断提升自己复盘、思考和规划的基础能力。</strong></p><p>通过对过去一周工作的总结和沉淀，对未来一周的工作做计划和安排，回顾收获与不足，促成协同与互补。</p><p><strong>周报不仅是为了写给老板看的，更是写给自己看的，为自己创造一个“照镜子”的机会，沉淀经验，发现不足，快速改进。</strong></p><h3 id="周报撰写的方法"><a href="#周报撰写的方法" class="headerlink" title="周报撰写的方法"></a>周报撰写的方法</h3><table><thead><tr><th align="left">周报的三个部分</th><th align="left">撰写要点</th></tr></thead><tbody><tr><td align="left"><strong>第一部分，本周工作进展</strong></td><td align="left">也就是本周自己做了哪些事，分别取得了什么样的成果，围绕4个方面：</td></tr><tr><td align="left"></td><td align="left">①检查关键项目/任务的完成进度是否符合预期；</td></tr><tr><td align="left"></td><td align="left">②反馈各项目/任务的执行结果，如：完成情况/未达预期的原因/改进方案；</td></tr><tr><td align="left"></td><td align="left">③统计日程表中各任务的耗时情况是否正常，有没有效率特低或特高的情况，原因写到备注中；</td></tr><tr><td align="left"></td><td align="left">④回溯上一周面临的问题是否得到解决，解决方案是否有效，并简单总结经验教训。</td></tr><tr><td align="left"><strong>第二部分，下周任务安排</strong></td><td align="left">即对下周工作开展的简单思路，明确下周的工作重点，同时也能更加合理地管理时间，提升工作效率。可参考以下步骤进行规划：</td></tr><tr><td align="left"></td><td align="left">①列出下周的关键项目/任务；</td></tr><tr><td align="left"></td><td align="left">②明确各项项目/任务的产出指标；</td></tr><tr><td align="left"></td><td align="left">③细化任务，一方面要计划任务量，另一方面要计划时间分配，明确完成的时间节点。</td></tr><tr><td align="left"><strong>第三部分，本周工作感想</strong></td><td align="left">包括对工作的思考/疑问/不满/建议等等 。</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    总之，好的周报不仅让领导眼前一亮，并且能够让自己持续成长，不至于每当机遇来了却感叹没有掉到自己的手里。周期性的复盘自我才能一直持续高速成长。</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周报 </tag>
            
            <tag> 个人成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PYPI打包躺坑日记</title>
      <link href="posts/cea93702/"/>
      <url>posts/cea93702/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    作为一个测试，在使用 <code>PYTHON</code> 开发项目或者平台的时候会发现自己写的通用型功能可能每次都要拷贝到不同的项目中，如：我自己对数据库操作进行二次封装的 <code>sql_utils</code> ，可能由于一些扩展性需要或者修复一些缺陷就需要在每个项目里进行修改，操作起来相当繁琐并且可能出现失误。</p><p>​    大家肯定都用过 <code>pip</code> 来安装过依赖包，那么我们是否可以把自己写的公共模块通过 <code>PYPI</code> 来管理，这样通过 pip 就能安装了，是不是满满的成就感(╯▔▽▔)╯(╯▔▽▔)╯  ！！！心动不如行动！！</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>​    关于如何将自己的项目打包上传到 <code>PYPI</code> 进行统一管理的基本教程很多，这里就不重复搬运了，可以参考当时我找到的一篇<a href="https://blog.csdn.net/Coxhuang/article/details/88952367">教程</a>。主要记录下在这个过程中遇到的一些问题。</p><h3 id="基本命令行"><a href="#基本命令行" class="headerlink" title="基本命令行"></a>基本命令行</h3><p>在所有流程都执行完后，每次上传版本的命令行基本如下：</p><ol><li><p> 修改 <code>setup.py</code> 文件中的 <code>version</code> 字段版本值 ；</p></li><li><p> 执行 <code>python setup.py sdist build </code>，本地打包构建最新版本的 dist 包；</p></li><li><p> 执行 <code>twine upload --skip-existing dist/* </code> 上传新的版本包；</p></li><li><p> 使用方升级 <code>pip install --upgrade $&#123;package_name&#125; </code>。</p></li></ol><h3 id="过程中遇到的问题"><a href="#过程中遇到的问题" class="headerlink" title="过程中遇到的问题"></a>过程中遇到的问题</h3><h4 id="问题1：在执行上述命令行的第3步时候，上传一直报错-403"><a href="#问题1：在执行上述命令行的第3步时候，上传一直报错-403" class="headerlink" title="问题1：在执行上述命令行的第3步时候，上传一直报错 403"></a>问题1：在执行上述命令行的第3步时候，上传一直报错 403</h4><p>具体报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPError: 403 Client Error: Invalid or non-existent authentication information. <span class="keyword">for</span> url: https://upload.pypi.org/legacy/ </span><br></pre></td></tr></table></figure><p>查了下相关的问题， 如: <a href="https://github.com/pypa/twine/issues/424">官网ISSUES</a>，但看起来和我的不太一致，最终通过对比发现由于根目录下 <code>LICENSE</code> 文件中有一个用户名信息。</p><p><strong>解决方案：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admindeMacBook-Pro-2:date_utils xxx$ cat LICENSE</span><br><span class="line">Copyright (c) 2018 <span class="variable">$&#123;YOUR_USERNAME&#125;</span>  <span class="comment"># 这个地方应该填写自己的PYPI username</span></span><br></pre></td></tr></table></figure><h4 id="问题2：参考官网链接里面的操作，执行到如下命令时候报错"><a href="#问题2：参考官网链接里面的操作，执行到如下命令时候报错" class="headerlink" title="问题2：参考官网链接里面的操作，执行到如下命令时候报错"></a>问题2：参考官网链接里面的操作，执行到如下命令时候报错</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; python3 -m pip install --user --upgrade setuptools wheel </span><br><span class="line">error: invalid <span class="built_in">command</span> ‘bdist_wheel<span class="string">&#x27; </span></span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong><a href="https://stackoverflow.com/questions/34819221/why-is-python-setup-py-saying-invalid-command-bdist-wheel-on-travis-ci">参考链接</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install wheel </span><br></pre></td></tr></table></figure><h4 id="问题3：-更新代码并修改了version后执行步骤3，仍然报错"><a href="#问题3：-更新代码并修改了version后执行步骤3，仍然报错" class="headerlink" title="问题3： 更新代码并修改了version后执行步骤3，仍然报错"></a>问题3： 更新代码并修改了version后执行步骤3，仍然报错</h4><p>具体报错信息为：<code>400 Client Error: File already exists </code></p><p><strong>解决方案：</strong> <a href="https://stackoverflow.com/questions/52016336/how-to-upload-new-versions-of-project-to-pypi-with-twine">参考链接</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twine upload --skip-existing dist/* </span><br></pre></td></tr></table></figure><h4 id="问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。"><a href="#问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。" class="headerlink" title="问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。"></a>问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。</h4><p><strong>原因：</strong>如果存在了依赖非系统自带的库的时候，比如 <code>requests</code> ，默认情况下打包上传后，下载的库在运行时候会报 <code>request</code> 不存在，没有自动安装相应的依赖。</p><p><strong>解决办法：</strong></p><p>​    在 <code>setup.py</code> 文件中添加配置，具体代码如下：<a href="https://note.qidong.name/2018/01/python-setup-requires/">参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setup(</span><br><span class="line">...</span><br><span class="line">    install_requires=[</span><br><span class="line">        <span class="string">&quot;requests&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="问题5：在Mac上打包的公共库，-但在windows上安装一直报错。"><a href="#问题5：在Mac上打包的公共库，-但在windows上安装一直报错。" class="headerlink" title="问题5：在Mac上打包的公共库， 但在windows上安装一直报错。"></a>问题5：在Mac上打包的公共库， 但在windows上安装一直报错。</h4><p>具体报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: <span class="string">&#x27;gbk&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xbf in postion 2: illegal multibyte sequence</span></span><br></pre></td></tr></table></figure><p>原因是：是因为在 <code>setup.py</code> 文件时候，执行了 <code>open(README.rst)</code> 此处编码有问题。</p><p>解决办法：在 <code>setup.py</code> 文件中的代码进行如下修改。（但不一定是这个文件。具体要看是否有哪个代码使用了open()方法打开了中文字体的文件）<a href="https://blog.csdn.net/lqzdreamer/article/details/76549256">参考链接</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(README.rst) ==&gt; open(README.rst, encoding=&#x27;gb18030&#x27;, errors=&#x27;ignore&#x27;)</span><br></pre></td></tr></table></figure><h4 id="问题6-上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。"><a href="#问题6-上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。" class="headerlink" title="问题6: 上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。"></a>问题6: 上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。</h4><p>原因：因为本地配置了pip的安装源为<a href="http://mirrors.aliyun.com/pypi/simple/">阿里云的链接</a>，<strong>阿里云的pip源不是实时去同步PYPI上的包</strong>。</p><p>解决办法： 把本地配置的 <code>pip.conf</code>  里面的用户自定义配置的内容注释掉即可。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://packaging.python.org/tutorials/packaging-projects/#uploading-your-project-to-pypi">Packaging Python Projects</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PYPI </tag>
            
            <tag> Python公共库管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识思维</title>
      <link href="posts/50e7aed3/"/>
      <url>posts/50e7aed3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是思维"><a href="#什么是思维" class="headerlink" title="什么是思维"></a>什么是思维</h3><p>书本上的解释：</p><blockquote><p> 思维是大脑对接收到的信息进行加工处理，再反映在现实生活中的一种过程。</p></blockquote><p><strong>信息：</strong>泛指人类社会传播的一切内容。 </p><p><strong>加工处理：</strong>如：记忆、理解、筛选、推理、思考、想象等。 </p><p><strong>反映在现实生活中：</strong>指的是产生的动作、想法或者行动，这种动作可能是大脑内部的运转，也可能是通过说、写、画、行动等方式表达出来的肢体动作。 </p><p>书上的概念大多数时候都比较抽象 ㄟ(▔︹▔ㄟ) ，此处我为了方便记忆会用当前我已知的知识替换一部分名词，如：<font color=red><strong>思维 =&gt; 看法</strong> </font>。（思维会产生一个或多个看法，<a href="https://wiki.mbalib.com/wiki/%E6%80%9D%E7%BB%B4">MBA百科</a>上解释 思维 =&gt; 思考）</p><a id="more"></a><p>⚠️ <strong>个人理解</strong>： 思维（<strong>看法</strong>）不会凭空产生，当你知道某个信息A后，通过自己已有的认知对A形成关于该信息的看法（可能是多个）。</p><p>比如：</p><ul><li>你去了重来没去过的饭店A去吃饭，挺好吃的，这个时候就形成了饭店A菜还不错的思维（看法a）。</li><li>你第二次再次去了饭店A吃饭（由于上述的看法a），但是此次吃同样的菜很难吃，这个时候你又形成了饭店A菜怎么这么难吃的思维（看法b）</li><li>再准备出去吃饭的时候，你可能不会再考虑饭店A（由于看法b导致）。</li></ul><p>所以通俗易懂的来说就是：**”思维” 就是  “一个或者多个关于某个信息的看法”**（个人觉得这样理解挺方便😂）。</p><h3 id="思维形成的过程"><a href="#思维形成的过程" class="headerlink" title="思维形成的过程"></a>思维形成的过程</h3><p>​    从上面的实例来看，<font color=blue><strong>思维（看法）会在不断接受到信息后不断的改变。</strong></font>再来看一个具体的实例：</p><p>​    当我们去一个新公司上班。一进门，人事专员就面带微笑地迎接，给我们办理入职相关手续，这时候我们有可能会想：<strong>哇，新公司真不错，同事这么和蔼可亲、服务周到，看起来氛围也很好。</strong></p><p>​    在这一系列的思考后，我们是不是会放下内心的担忧或者矜持，对人事专员笑容以对呢？</p><p>​    接着人事专员让我们稍等，她去复印身份证，<strong>结果一等就等了20分钟。这时候，我们是不是又会情绪不安</strong>，心想：<strong>怎么回事，复印个身份证都能这么久，这个人做事靠谱吗？是不是半路被拉去做其他事，把我忘了？还是我入职的事情，有了什么变化？</strong></p><p>​    在这一系列的思考后，<strong>我们可能会来回走动、坐立不安，甚至开始四处找人呢？</strong></p><p><font color=red>此时再次设想存在如下两个场景：</font></p><p><strong>场景一：</strong>当我们找到人事专员，发现她在跟其他人聊天，这个时候我们看到她脸上的笑容，就不再认为她和蔼可亲了。</p><p>此时你是不是会觉得：<strong>这个人怎么回事啊？把我晾在一边，我这边的手续还没办完，又在跟别人说说笑笑，真不靠谱！</strong></p><p><strong>场景二：</strong>我们发现她在帮我们复印文件时弄了一手油墨，并且不断和我们道歉说复印机突然坏了，维修师傅明天才能到，为了不影响我们入职，她只能自己动手尝试修理，一不小心忘了时间……发现是这样的情况，我们会怎样思考呢？</p><p>此时你是不是会觉得：<strong>“原来是这样啊，我误会她了，人事专员还能修复印机真是厉害，公司员工的素质好高啊，真是个不错的公司！”</strong></p><p>所以，思维不仅是单向运动，而且还是<strong>动态循环</strong>的过程。我们会<font color=blue><strong>因为事情呈现的变化和结果，反过来影响思维，又持续不断地影响接下来的态度、行为，以及事情的结果。</strong></font></p><img src="https://i.loli.net/2021/02/20/qfkyZVjYCM8FRcx.png" alt="逻辑思维-1.png" style="zoom:35%;" /><p>在工作中也是这样。</p><p><strong>如果你存在上司对你有意见的看法， 那你的工作肯定做不好。</strong>因为任何不好的事情发生后，你可能都会先怪罪到你上司身上，并且消极怠工、破罐子破摔、拒不改错或者与上司起冲突。最终结果可能就是离职。最后我们还会认为：<font color=red><strong>果然，上司就是不待见自己！</strong></font></p><p><strong>如果你存在上司有意栽培你的看法时，那你的工作可能会越做越好。</strong> 上司指出我们方案中的错误，我们就会认为上司精益求精、借此指点我们，继而我们更虚心好学、热情请教、刨根问底、精益求精，结果肯定是自己逐渐进步和优秀。最后，我们会认为：<font color=blue><strong>上司果然是想培养自己！</strong></font></p><h4 id="思维方式"><a href="#思维方式" class="headerlink" title="思维方式"></a>思维方式</h4><blockquote><p>就这样在上图描述那样，一次又一次的思维循环里，思维过程重复多次，就会形成固定的思维方式，从而形成思维惯性，遇见相同或类似的信息时，按照同样的思维方式思考，就能得出同样的认知。 </p></blockquote><p>⚠️ <strong>个人理解</strong>：在上述过程中讲到了思维方式，我个人理解可以认为： <font color=red><strong>思维方式 =&gt; 做事方式</strong></font>。（后面如有遗漏可自行替换为做事方式）</p><p>比如：从小我们经过很多事情（在不特意训练的情况下），形成了一套属于自己的做事方式（大部分这个做事方法是不成熟的，就比如我刚工作的做事方式(╯▔︹▔)╯ ）。</p><ul><li>刚开始工作时，每当遇到问题时，夸张一点的做事方式：<strong>上来就直接问别人，如果解决了就完事了，没解决那就算了！！</strong>，在这种做事方式下，直接影响了个人的成长。所以急需改正。</li><li>在工作3～5年后，通过工作经验的积累，每当遇到问题，我的思维（<strong>做事</strong>）方式是：<strong>先解决这个问题，并且记录问题以及具体原因，通过5Why分析法追根溯源</strong>，这种思维<strong>（做事）</strong>方式让我在后续遇到类似的问题也能从容应对，让我的个人能力也突飞猛进。</li></ul><p>所以，如果我一直维持刚开始工作时候的固定的思维（<strong>做事</strong>）方式，那结果可想而知。</p><h4 id="固定思维方式的优点"><a href="#固定思维方式的优点" class="headerlink" title="固定思维方式的优点"></a>固定思维方式的优点</h4><p>​    当我们形成一种固定的思维（<strong>做事</strong>）方式后，常常会以这种方式去处理大部分的信息，优势在于有效率。也就是说，我们能把这种思维（<strong>做事</strong>）方式本身带来的红利发挥最大化。</p><ul><li>做过销售的人，往往更在乎结果。因为他们在做销售的过程中，业绩、收入取决于销售结果，所以有销售经验的人做其他工作往往更加看重结果是否达成。</li><li>做过编辑的人，看到文章，即使无须他们审核，也会快速找出其中格式错误、错别字、标点符号错误等问题。</li><li>做过行政工作的人，做事往往也会更加在乎细节。</li></ul><p>这些工作方式的差异，都是思维上重复多次后，形成固定思维（<strong>做事</strong>）方式的结果。</p><h4 id="固定思维方式的缺点"><a href="#固定思维方式的缺点" class="headerlink" title="固定思维方式的缺点"></a>固定思维方式的缺点</h4><p>​    容易忽略其他特质，比如：</p><ul><li>在乎结果的人容易忽视过程，甚至可能为短期结果而牺牲长远利益；</li><li>快速找到文章错误的人，往往不容易克服这些错误而去欣赏文章本身的意境；</li><li>在乎细节的人就不容易跳出局部看整体等。</li></ul><p>一个比较常见的实例，某些销售员由于工作原因，接触的人多了，就对人产生一些惯性思维，比如穿的破破烂烂的就没兴趣接待。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    如果掌握足够优秀或者成熟的思维（<strong>做事</strong>）方式，我们必然就会成为睿智、思考全面、轻松做正确选择的人。如果思维（<strong>做事</strong>）方式杂乱无章，没有形成结构，我们看待事情必然就会片面、局限、逻辑混乱，从而在失败里循环。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue + Element el-upload实现上传文件</title>
      <link href="posts/bb375789/"/>
      <url>posts/bb375789/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近在开发测试用例管理平台，其中需要实现上传用例的 <strong>Excel</strong> 文件。</p><h3 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h3><p>​    通过  <code>Element-ui</code> 很轻松就找到了对应的组件（<a href="https://element.eleme.cn/#/zh-CN/component/upload#tuo-zhuai-shang-chuan">Element-ui具体代码</a>），通过查找资料以及填坑，最终实现的效果如下：</p><img src="https://i.loli.net/2021/02/26/CZyFN5EdbTUOXgq.png" alt="finally-ui-import.png" style="zoom:40%;" /><a id="more"></a><p>具体核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-upload</span><br><span class="line">           class&#x3D;&quot;upload-demo&quot;</span><br><span class="line">           drag</span><br><span class="line">           :action&#x3D;&quot;doUpload&quot;</span><br><span class="line">           :data&#x3D;&quot;specialData&quot;</span><br><span class="line">           :on-change&#x3D;&quot;handleChange&quot;</span><br><span class="line">           :file-list&#x3D;&quot;fileList&quot;</span><br><span class="line">           :on-error&#x3D;&quot;handleError&quot;</span><br><span class="line">           :on-success&#x3D;&quot;handleSuccess&quot;</span><br><span class="line">           accept&#x3D;&quot;.xlsx, .xls&quot;</span><br><span class="line">           :before-upload&#x3D;&quot;onBeforeUpload&quot;</span><br><span class="line">           &gt;</span><br><span class="line">  &lt;i class&#x3D;&quot;el-icon-upload&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;&#x2F;em&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;el-upload__tip&quot; slot&#x3D;&quot;tip&quot; style&#x3D;&quot;color&#x3D;#4073ff&quot;&gt;只能上传excel文件，且不超过10MB&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;el-upload&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中对应的一些差异的js方法代码如下</span></span><br><span class="line"><span class="function"><span class="title">handleChange</span>(<span class="params">file, fileList</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.fileList = fileList;</span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此处使用 JSON.parse(err.message) 代替 JSON.stringify(err) </span></span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.parse(err.message)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg.err_msg)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>虽然 <code>Element-ui</code> 上的组件很丰富， 但是对于<strong>一个测试</strong>来说，有时候还是有些难以理解😭😭。</p><h4 id="问题1：action参数的使用问题。"><a href="#问题1：action参数的使用问题。" class="headerlink" title="问题1：action参数的使用问题。"></a>问题1：action参数的使用问题。</h4><p>在源码中 <code>action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;</code> 的使用，以及下面参数<code>action</code> 解释为：<strong>必选参数，上传的地址</strong>。这个地方就误以为只能使用 <code>URL</code> 格式，实际也可以 <code>:action</code> 直接对应后端的上传文件的API接口即可 。</p><p>解决方案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将源码中的 action=&quot;https://jsonplaceholder.typicode.com/posts/&quot; ==&gt; :action=&quot;doUpload&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">...</span><br><span class="line">  data() </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      doUpload:<span class="string">&#x27;/api/upload_excel_file&#x27;</span>,<span class="comment">// 对应后端的上传文件接口</span></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题2：需要传输指定的参数给后端接口。"><a href="#问题2：需要传输指定的参数给后端接口。" class="headerlink" title="问题2：需要传输指定的参数给后端接口。"></a>问题2：需要传输指定的参数给后端接口。</h4><p>解决方案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue 中上传组件新增 :data参数为指定需要传入给后端接口的data</span></span><br><span class="line">&lt;el-upload</span><br><span class="line">...</span><br><span class="line">  :action=<span class="string">&quot;doUpload&quot;</span></span><br><span class="line">  :data=<span class="string">&quot;specialData&quot;</span></span><br><span class="line">...</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">...</span><br><span class="line">  data() </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      doUpload:<span class="string">&#x27;/api/upload_excel_file&#x27;</span>,<span class="comment">// 对应后端的上传文件接口</span></span><br><span class="line">      specialData: &#123;</span><br><span class="line">        name: <span class="string">&quot;111&quot;</span>,<span class="comment">// 后端接口就能接收到该变量</span></span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体效果如下：</p><img src="https://i.loli.net/2021/02/26/7Jj2FYUrWc8n4L3.png" alt="upload-data.png" style="zoom:80%;" /><h4 id="问题3-针对于上传失败后，解析返回的错误信息不全。"><a href="#问题3-针对于上传失败后，解析返回的错误信息不全。" class="headerlink" title="问题3: 针对于上传失败后，解析返回的错误信息不全。"></a>问题3: 针对于上传失败后，解析返回的错误信息不全。</h4><p>具体现象如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.stringify(err)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">&#123;<span class="string">&quot;status&quot;</span>:<span class="number">400</span>,<span class="string">&quot;method&quot;</span>:<span class="string">&quot;post&quot;</span>,<span class="string">&quot;url&quot;</span>:<span class="string">&quot;/api/upload_excel_file&quot;</span>&#125; </span><br><span class="line"><span class="comment">// 实际err的信息应该如下（需要解析到里面的err_msg）：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code> JSON.stringify(err)</code> 去解析err 发现打印的数据没有想要的错误信息， 通过控制台调试的时候发现完整的err应该为如下格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>: &#123;</span><br><span class="line">  method: <span class="string">&quot;post&quot;</span></span><br><span class="line">  status: <span class="number">400</span></span><br><span class="line">  url: <span class="string">&quot;/api/upload_excel_file&quot;</span></span><br><span class="line">  message: <span class="string">&quot;&#123;↵  &quot;</span>code<span class="string">&quot;: 400, ↵  &quot;</span>data<span class="string">&quot;: &#123;&#125;, ↵  &quot;</span>err_msg<span class="string">&quot;: &quot;</span>\u5df2\u5b58\u5728\u76f8\u540c\u540d\u79f0\u7684\u6587\u4ef6<span class="string">&quot;↵&#125;↵&quot;</span></span><br><span class="line">  stack: <span class="string">&quot;Error: &#123;↵  &quot;</span>code<span class="string">&quot;: 400, ↵  &quot;</span>data<span class="string">&quot;: &#123;&#125;, </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>所以是 <code>JSON.stringify</code> 在转义的过程中少了一些字段（具体原因：<strong>JSON.stringify()只能序列化对象的可枚举的自有属性</strong>），此处解决办法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此处使用 JSON.parse(err.message) 代替 JSON.stringify(err) </span></span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.parse(err.message)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg.err_msg)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，基本已经满足了最初预定的需求。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://segmentfault.com/q/1010000019086550">Element upload组件如何获取它的on-error事件的报错信息</a><br><a href="https://segmentfault.com/a/1190000013796215">Element el-upload 上传组件详解</a><br><a href="https://element.eleme.cn/#/zh-CN/component/upload#tuo-zhuai-shang-chuan">Element 官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Element UI </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探Sqlmap（一）</title>
      <link href="posts/e96496d4/"/>
      <url>posts/e96496d4/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    基于<a href="https://beanskingdom.top/posts/6ad48805/#more">业务存在 Sql 注入危险</a> 的现状，开始研究相关工具的使用一一 Sqlmap。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    <code>Sqlmap</code> 是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。（<a href="https://github.com/sqlmapproject/sqlmap">Sqlmap源码</a>）</p><p>​    本文会简单描述下 <code>Sqlmap</code> 的使用方式，然后详细介绍下 <code>SqlmapAPI</code> 的大致原理。</p><a id="more"></a><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="一、-命令行方式"><a href="#一、-命令行方式" class="headerlink" title="一、 命令行方式"></a>一、 命令行方式</h4><p><strong>优点：</strong> 上手快，命令行输入/输出容易理解；问题定位方便。</p><p>​    对于<strong>新手初次使用该工具</strong>时候，建议<strong>使用命令行模式先将整个流程跑通</strong>（如参考：<a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a>，很详细的介绍了从Sql注入到破解数据库信息的整个过程），想了解更多命令行参数可以阅读源码目录 <code>lib/parse/cmdline</code> 文件获取更多参数的含义。</p><p><strong>大致的命令行格式如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对参数是直接拼接在链接后方的命令行</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;http://ip:port/user/login?username=foo&amp;passwd=bar&quot;</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;http://ip:port/user/login?username=foo&amp;passwd=bar&quot;</span> --batch --dbs</span><br></pre></td></tr></table></figure><p><strong>我常用的命令行参数有：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--dbms=<span class="string">&#x27;MySQL&#x27;</span><span class="comment"># 指定后台扫描数据库类型为 MYSQL</span></span><br><span class="line">--risk 3<span class="comment"># 执行中的风险系数，1~3，级别越高，可能会使用&#x27;or&#x27;等等语句，默认1</span></span><br><span class="line">--level 3<span class="comment"># 级别越高，发送的请求(payload)越多，默认1</span></span><br><span class="line">--random-agent<span class="comment"># Use randomly selected HTTP User-Agent header value</span></span><br><span class="line">--keep-alive<span class="comment"># Use persistent HTTP(s) connections</span></span><br><span class="line">--batch<span class="comment"># 自动选择默认的值，否则需要手动选择</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>注意：</strong> <strong>针对实践中的一些特定的场景，如加 <code>headers</code> 或对 <code>POST</code> 方法注入的命令行如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果需要自定义header，使用headers参数，注意：多个header之间用\n间隔</span></span><br><span class="line"><span class="comment"># 具体的data参数需要进行URL编码。</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;https://xxx/test/user&quot;</span> --headers=<span class="string">&quot;xxx: xxx\nxbbb: 4\nxcc: 111\nx-token: xxx&quot;</span> --data=<span class="string">&#x27;data=%7B%22id%22%3A%22111%22%2C%22new%22%3A%229%22%2C%20%22old%22%3A%221%22%7D&#x27;</span> --dbms=<span class="string">&#x27;MySQL &#x27;</span> --random-agent --batch </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如上请求的POST参数具体格式如下</span></span><br><span class="line">data=&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;111&quot;</span>,<span class="string">&quot;new&quot;</span>:<span class="string">&quot;9&quot;</span>, <span class="string">&quot;old&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line"><span class="comment"># 在注入的时候，要对data中所有的字段进行注入，则需要将上述data修改如下，在每个字段的value值后新增一个*号：</span></span><br><span class="line">data=&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;111*&quot;</span>,<span class="string">&quot;new&quot;</span>:<span class="string">&quot;9*&quot;</span>, <span class="string">&quot;old&quot;</span>:<span class="string">&quot;1*&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意</strong>⚠️： 对于data里面需要注入的参数带 * 号时候，转义后仍然需要是 * 号，不能直接转义，否则就导致最终仅仅是对 data最外层这个data进行了注入！！！</font></p><p><strong>缺点：</strong></p><ul><li>由于Sqlmap每检测一个站点都需要开启一个新的命令行窗口或者结束掉上一个检测任务。虽然 -m 参数可以批量扫描URL，但是模式也是一个结束扫描后才开始另一个扫描任务，执行效率较慢；</li><li>对于想获取历史任务的日志和结果操作不友好。</li></ul><p><strong>实际使用场景：我大多数时候是用该方式进行参数调试。</strong></p><h4 id="二、API请求"><a href="#二、API请求" class="headerlink" title="二、API请求"></a>二、API请求</h4><p><strong>优点：</strong> Sqlmap封装了较多的API接口，更方便操作扫描任务。</p><ul><li><p>通过 API接口下发扫描任务，无需每次执行扫描新开一个命令行窗口，通过Http接口即可执行扫描任务；</p></li><li><p>可通过 API接口获取历史执行结果以及日志进行聚合和分析。</p></li></ul><p>具体如何使用 SqlmapAPI不具体描述，可参考：<a href="https://paper.seebug.org/940/">细说Sqlmap</a>，比较详细的说明了 SqlmapAPI的使用。</p><h3 id="SqlmapAPI-原理"><a href="#SqlmapAPI-原理" class="headerlink" title="SqlmapAPI 原理"></a>SqlmapAPI 原理</h3><h4 id="SqlmapAPI-服务器启动"><a href="#SqlmapAPI-服务器启动" class="headerlink" title="SqlmapAPI 服务器启动"></a>SqlmapAPI 服务器启动</h4><p>SqlmapAPI的服务器启动逻辑还是很简单，下图为整个 <code>sqlmapapi.py</code> 脚本服务器启动流程。</p><img src="https://i.loli.net/2021/02/16/WJVaUkBYhstGRHv.png" alt="sqlmapAPI.png" style="zoom:45%;" /><h4 id="api-py"><a href="#api-py" class="headerlink" title="api.py"></a>api.py</h4><p>SqlmapAPI使用的是 <a href="https://docs.python.org/zh-cn/3/library/sqlite3.html">sqlite3</a> 数据库。在 <code>server()</code> 方法中主要是进行本地数据库的路径创建、连接以及创建必须的表结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个随机地址, 用于存放数据库文件</span></span><br><span class="line">_, Database.filepath = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.IPC, text=<span class="literal">False</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize IPC database</span></span><br><span class="line">DataStore.current_db = Database()</span><br><span class="line">DataStore.current_db.connect()</span><br><span class="line">DataStore.current_db.init()</span><br></pre></td></tr></table></figure><p>使用API模式进行sql注入测试时候，主要使用如下几个API接口（具体如何调用可参考：<a href="https://paper.seebug.org/940/">细说Sqlmap</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@get(<span class="string">&quot;/task/new&quot;</span>)<span class="comment"># 创建一个新的扫描任务</span></span><br><span class="line">@post(<span class="string">&quot;/scan/&lt;taskid&gt;/start&quot;</span>)<span class="comment"># 指定任务进行扫描</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/status&quot;</span>)<span class="comment"># 查看指定任务的状态</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/data&quot;</span>)<span class="comment"># 查看指定任务的执行结果</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/log&quot;</span>)<span class="comment"># 查看指定任务的扫描执行日志</span></span><br></pre></td></tr></table></figure><h4 id="Task执行原理"><a href="#Task执行原理" class="headerlink" title="Task执行原理"></a>Task执行原理</h4><p>此处仅介绍 <code>/scan/&lt;taskid&gt;/start</code>，主要通过 <code>DataStore.tasks[taskid].engine_start()</code> 进行执行指定任务执行扫描。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">engine_start</span>(<span class="params">self</span>):</span></span><br><span class="line">  handle, configFile = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.CONFIG, text=<span class="literal">True</span>)</span><br><span class="line">  os.close(handle)</span><br><span class="line">  saveConfig(self.options, configFile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&quot;sqlmap.py&quot;</span>):</span><br><span class="line">  self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">elif</span> os.path.exists(os.path.join(os.getcwd(), <span class="string">&quot;sqlmap.py&quot;</span>)):</span><br><span class="line">    self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, cwd=os.getcwd(), close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">elif</span> os.path.exists(os.path.join(os.path.abspath(os.path.dirname(sys.argv[<span class="number">0</span>])), <span class="string">&quot;sqlmap.py&quot;</span>)):</span><br><span class="line">    self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, cwd=os.path.join(os.path.abspath(os.path.dirname(sys.argv[<span class="number">0</span>]))), close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    self.process = Popen([<span class="string">&quot;sqlmap&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, close_fds=<span class="keyword">not</span> IS_WIN)</span><br></pre></td></tr></table></figure><p>从上面的代码来看，最终还是使用的 <code>sqlmap.py</code> 脚本来进行的任务扫描，也可以通过打印出源代码中 <code>configFile</code>  的路径，来查看每次任务的配置参数是什么。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，SqlmapAPI就介绍到此，可以看出来该脚本主要是启动一个本地数据库以及Web后台，来记录所有的任务相关信息。下一次将再继续分析 <code>sqlmap.py</code> 脚本中是如何进行sql注入的测试。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://octobug.gitbooks.io/sqlmap-wiki-zhcn/content/">sqlmap中文介绍</a><br><a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a><br><a href="https://github.com/sqlmapproject/sqlmap">Sqlmap源码</a><br><a href="https://www.freebuf.com/sectool/164608.html">Sqlmap超详细攻略</a><br><a href="https://paper.seebug.org/940/">细说Sqlmap</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全测试 </tag>
            
            <tag> Sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探安全测试</title>
      <link href="posts/6ad48805/"/>
      <url>posts/6ad48805/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    某天，A：你们Web后台存在安全问题，部分接口<font color=red><strong>存在SQL注入的问题</strong></font>。</p><p>​    B：…</p><p>​    B To C：接口存在SQL注入的问题，你去调研下Sqlmap。</p><p>​    C：… emm (⊙＿⊙)。</p><a id="more"></a><h3 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h3><ul><li>什么是安全问题？应用软件中又存在哪些方面的安全问题？</li><li>什么是安全测试？</li><li>常见的安全性缺陷和漏洞有哪些？</li><li>Sql注入，用于进行Sql注入的工具有哪些？</li></ul><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>​    现实生活中安全相关话题无处不在，如消防安全、卫生安全、人身安全等等，如：<strong>小区楼道中贴着一些禁止电动车在楼道中充电</strong>，因为这会存在着引发火灾的安全问题（严重的情况甚至影响到生命危险）。</p><p>​    那么应用软件中也存在安全问题，情况严重时候不仅会造成经济损失，还可能由于大量用户信息被泄漏而导致整个公司崩溃。常见的几种安全问题如下：</p><ul><li><strong>信息安全问题</strong>：如淘宝、京东中，用户一般都绑定了身份证、银行卡、手机号、家庭住址等个人隐私信息，如果这些信息泄漏给一些不法分子后，就会对一些指定用户进行电信诈骗；</li><li><strong>财产安全问题</strong>：如很多钓鱼网站，都是通过短信、微信、网页链接等方式模拟正规网页，骗取用户在上面进行操作，导致银行卡密码泄漏而造成财产损失；</li><li><strong>权限安全问题</strong>：由于权限控制不得当，非公司内部管理员也能通过某些方式对公司的私密信息进行操作，最终导致整个公司隐私泄漏或者信息错误。</li></ul><h4 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h4><p>​    个人理解安全测试应该是 <strong>一个识别应用程序潜在的安全性缺陷的过程</strong>，如：保证用户对数据或业务功能的访问，在预期的安全性情况下，操作者只能<strong>访问应用程序的特定功能、有限的数据</strong>等。</p><p>其它参考：<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95">百度–安全测试</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95">维基–渗透测试</a></p><p>​    常用的安全测试手段有：</p><ul><li>静态的代码安全测试；</li><li>动态的渗透测试；</li><li>程序数据扫描。</li></ul><h4 id="常见的软件安全性缺陷和漏洞有哪些"><a href="#常见的软件安全性缺陷和漏洞有哪些" class="headerlink" title="常见的软件安全性缺陷和漏洞有哪些"></a>常见的软件安全性缺陷和漏洞有哪些</h4><p>由于篇幅有限，暂仅对此次存在 <code>Sql注入</code> 的安全问题详细介绍。</p><ul><li><a href="https://baike.baidu.com/item/SQL%E6%B3%A8%E5%85%A5">SQL注入</a></li><li><a href="https://www.jianshu.com/p/9fc25e661ab9">XSS注入</a></li><li><a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E">远程代码执行</a></li><li><a href="https://www.netinbag.com/cn/internet/what-is-parameter-tampering.html">参数篡改</a></li><li><a href="https://www.anquanke.com/post/id/217290">弱口令</a></li><li>…</li></ul><h4 id="Sql注入"><a href="#Sql注入" class="headerlink" title="Sql注入"></a>Sql注入</h4><p>​    在没有深入之前，对于Sql注入的理解是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，然后获得该接口的返回或者绕过授权。对于存在Sql注入的威胁也仅仅是绕过登录或者获取某些普通数据。</p><p>​    然而通过资料的查询以及自身的Sqlmap实践后，才感觉一阵后怕，比较常见的威胁如下：</p><ul><li>猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。（<strong>如果存在Sql注入时，在没有特殊的安全措施下，可以理解数据库里面的所有信息都可以被获取到</strong>）</li><li>绕过认证，列如绕过验证登录网站后台。</li></ul><p>​    具体如何使用Sqlmap达到上面的效果这里就不细说了，网上这块教程比较多（如：<a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a>）。</p><h4 id="Sql注入的步骤"><a href="#Sql注入的步骤" class="headerlink" title="Sql注入的步骤"></a>Sql注入的步骤</h4><ol><li><p><strong>SQL注入点探测</strong>。</p><p>探测SQL注入点是关键的一步，通过适当的分析应用程序，可以判断什么地方存在SQL注入点。通常只要带有输入提交的动态网页，并且动态网页访问数据库，就可能存在SQL注入漏洞。如果程序员信息安全意识不强，<font color=red><strong>采用动态构造SQL语句访问数据库，并且对用户的输入未进行有效性验证，则存在SQL注入漏洞的可能性很大。</strong></font>一般通过页面的报错信息来确定是否存在SQL注入漏洞。</p></li><li><p><strong>收集后台数据库信息。</strong></p><p>不同数据库的注入方法、函数都不尽相同，因此在注入之前，我们先要判断一下数据库的类型。判断数据库类型的方法很多，可以输入特殊字符，如单引号，让程序返回错误信息，我们根据错误信息提示进行判断；还可以使用特定函数来判断，比如输入“1 and version（）&gt;0”，程序返回正常，说明 <code>version()</code> 函数被数据库识别并执行，而 <code>version()</code> 函数是 <code>MySQL</code> 特有的函数，因此可以推断后台数据库为MySQL。</p></li><li><p><strong>猜解用户名和密码。</strong></p><p>数据库中的表和字段命名一般都是有规律的。通过构造特殊SQL语句在数据库中依次猜解出表名、字段名、字段数、用户名和密码。 </p></li><li><p><strong>查找Web后台管理入口。</strong></p><p>WEB后台管理通常不对普通用户开放，要找到后台管理的登录网址，可以利用Web目录扫描工具（如：wwwscan、AWVS）快速搜索到可能的登录地址，然后逐一尝试，便可以找到后台管理平台的登录网址。</p></li><li><p><strong>入侵和破坏。</strong></p><p>一般后台管理具有较高权限和较多的功能，使用前面已破译的用户名、密码成功登录后台管理平台后，就可以任意进行破坏，比如上传<a href="https://baike.baidu.com/item/%E6%9C%A8%E9%A9%AC/530">木马</a>、篡改网页、修改和窃取信息等，还可以进一步提权，入侵Web服务器和数据库服务器。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    概念相关就介绍到此，下一篇将会具体介绍如何通过工具来进行相关Sql注入的测试一一 <code>Sqlmap</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> 安全测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全测试 </tag>
            
            <tag> Sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019~2020年回顾</title>
      <link href="posts/6a64e1dd/"/>
      <url>posts/6a64e1dd/</url>
      
        <content type="html"><![CDATA[<h3 id="感慨（吐槽自己…）"><a href="#感慨（吐槽自己…）" class="headerlink" title="感慨（吐槽自己…）"></a>感慨（吐槽自己…）</h3><p>​    瞬间就到了2021年了。。。依稀还记得2019年立的flags(╯▔︵▔)╯，重度拖延+健忘+各种琐事总能把一些想法扼杀在摇篮中。</p><p>比如：大一点方向就是全世界/全国旅游； 小一点方向就是学习潜水、滑雪等…</p><h3 id="庆幸"><a href="#庆幸" class="headerlink" title="庆幸"></a>庆幸</h3><p>​    让我感到欣慰的是，在2020年中下旬的开始，我的思维有了一些转变。我开始变得爱看书了（各种方面的都有，如：理财、PS、算法、逻辑思维等），这个也要归功于我主动看的第一本书籍 <code>《小强升职记》</code> （通俗易懂 + 符合现实），让我感同身受的同时，思维上也有了一个质的改变。</p><a id="more"></a><p>​    我完成了很多原来不可能会做的事情（容易量化的如下，实际还有更多就不一一列举了）：</p><ul><li>我主动看完了一本书；</li><li>我坚持了看书2个月；</li></ul><p>​    虽然按照书上的一些方法不那么有效（<em>并不是每一本书都能帮你解决什么问题，它们仅仅是一个个你的起点而已</em>），但通过不断的实践、修改、实践，我开始慢慢掌握了一个属于我自己的节奏，并且更加积极向上，我知道 2021 年会更加精彩。那些天马星空的想法也变的不那么遥不可及。</p><p>​    至此我也开始明白了一句话 一一 <code>书中自有黄金屋，书中自有颜如玉。</code></p><h3 id="2019～2020年的生活"><a href="#2019～2020年的生活" class="headerlink" title="2019～2020年的生活"></a>2019～2020年的生活</h3><blockquote><p>不如意事常八九，可与语人无二三。</p></blockquote><p>​    这一年半多的时间里，磕磕碰碰的事情挺多，过程中也一度沮丧或者低落过。特别是由于平时缺乏锻炼，感觉身体上也开始各种小毛病。（<font color=red><em>敲黑板！！！身体是革命的本钱，早期一定要注意</em></font>）。</p><p>​    刚好看到2018年时去马来西亚沙巴的一次团建（<em>早晨吹着海风躺在椰子树阴下的躺椅上，感叹着生活如此多娇</em>）。</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/9S43eH5lOTtANUZ.jpg"></center><h3 id="印象比较深刻的几个地方"><a href="#印象比较深刻的几个地方" class="headerlink" title="印象比较深刻的几个地方"></a>印象比较深刻的几个地方</h3><p>在面对这些大自然的美景时，整个人的心境都得到了升华，感觉什么烦恼都在那一刻抛到九霄云外。</p><h4 id="仙本那"><a href="#仙本那" class="headerlink" title="仙本那"></a>仙本那</h4><p>印象最深刻的是当时参观的<strong>巴瑶族人</strong>一一地球上最后一个海洋游牧民族，”<strong>一生</strong>“ 都在水上的民族。</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/QvZG5ALmpbjDqOR.jpg"></center><h4 id="塞班岛"><a href="#塞班岛" class="headerlink" title="塞班岛"></a>塞班岛</h4><p>天空和海水的搭配真的是很美（海天一色）！！！无需任何滤镜，感觉如画中一般。</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/XFHWT2khB8i4KtQ.jpg"></center><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/Jzw5jZWachnstgv.jpg"></center><h4 id="雁荡山"><a href="#雁荡山" class="headerlink" title="雁荡山"></a>雁荡山</h4><p>云海翻腾，山海共生。<br><img src="https://i.loli.net/2020/08/16/Dv1gQmIM3cpCTkP.jpg" alt="life_photo_5.png" style="zoom:60%;" /></p><img src="https://i.loli.net/2020/08/16/ePwQyk1zmsI9glp.jpg" alt="life_photo_6.png" style="zoom:60%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    <strong>其实生活也就那样一一酸甜苦辣</strong>。（乍得一看有点像是一篇游记(╯▔▽▔)╯ ）</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT + Valine躺坑之路</title>
      <link href="posts/a21b8f58/"/>
      <url>posts/a21b8f58/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    写了一段时间博客后，发现别人的文章有浏览次数以及评论功能★~★，这也某种程度上提高写 <em>Blog</em> 的动力，那我也来弄一个哈哈哈。。。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>​    然而，事实总是那么折磨人。。。使用的是 <em>nexT</em> 主题的 <em>v8.2.1</em> 版本，按照网上的<a href="https://qianfanguojin.github.io/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">教程</a>后一直没有达到最终的效果😭😭。</p><a id="more"></a><h4 id="问题1-使用-Valine-插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。"><a href="#问题1-使用-Valine-插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。" class="headerlink" title="问题1: 使用 Valine 插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。"></a>问题1: 使用 <em>Valine</em> 插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。</h4><p>具体原因：因为 <code>v8.2.1 版本已经将 Valine 功能去除掉了</code>。（详情见<a href="https://github.com/next-theme/hexo-theme-next/issues/188">官网解释</a>）也尝试了官网中的解决办法以及各种网上的方法，但是仍然无效。（瞎折腾了3个小时都没结果。。。气到内伤😭😭）</p><p>那就将版本降低到能使用的 <em>Valine</em> 的 <em>NexT</em> 版本呢？（如降低到<a href="https://github.com/theme-next/hexo-theme-next/releases/tag/v7.8.0">7.8.0</a>版本呢？？）<code>降低版本到7.8.0后，问题就解决了</code>。</p><h4 id="问题2-降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。"><a href="#问题2-降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。" class="headerlink" title="问题2: 降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。"></a>问题2: 降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击中文标题导航栏时候，console控制台中报错，并且页面上没有跳转到对应的标题位置。</span></span><br><span class="line">Cannot read property <span class="string">&#x27;getBoundingClientRect&#x27;</span> <span class="keyword">of</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>实际原因是:  <code>themes/next/source/js/utils.js</code> 中的代码存在遗漏，没有对中文进行URL解码。具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... <span class="comment">// 其他多余代码省略</span></span><br><span class="line"><span class="comment">// 在这个地方获取 event 的属性时候，中文的会被自动转成URI编码格式</span></span><br><span class="line"><span class="comment">// href=&quot;#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4&quot; </span></span><br><span class="line"><span class="comment">// 但文章中的Id仍然是中文的 &lt;h3 id=&quot;操作步骤&quot;&gt;, 所以导致此处的target为null。</span></span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(event.currentTarget.getAttribute(<span class="string">&#x27;href&#x27;</span>).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br><span class="line">... <span class="comment">// 其他多余代码省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法：将上述代码替换如下代码即可。</span></span><br><span class="line"><span class="keyword">var</span> str_id = <span class="built_in">decodeURI</span>(event.currentTarget.getAttribute(<span class="string">&#x27;href&#x27;</span>).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(str_id);</span><br><span class="line"><span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br></pre></td></tr></table></figure><p>至此， 终于得到了自己想要的效果。。。（＋﹏＋）（＋﹏＋）</p><img src="https://i.loli.net/2021/02/09/vLhxcG8jZfyk46u.png" alt="valine_result.png" style="zoom:50%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    很多时候遇到的问题，通过网上不一定能适用自己当前的场景，并不一定是别人的方式有问题。。。很可能是你的环境和别人的就不一样，所以<code>同样的操作不一定能解决同样现象的问题</code>。。。还是需要多排查定位看看主要的问题点在哪。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
            <tag> Valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Py-spy解决Python程序Hang住问题</title>
      <link href="posts/cb61081b/"/>
      <url>posts/cb61081b/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    已经集成的接口自动化测试 Job 在周期性定时运行的时候，会很小概率出现一直卡在那里，原本应该3min就执行完成的任务，偶尔过了半个小时还没结束。（(￣３￣)直觉告诉我这个地方肯定有问题。。。</p><p>​    但由于复现的概率较小，一个月可能出现一次，所以开始并没有什么太大的线索（仅靠一些猜测并不切实际）。</p><p>​    终于！！！在某一个阳光明媚的大好日子，<strong>它重现了</strong>。</p><a id="more"></a><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ol><li><p>赶紧先登录到服务器上看看进程情况，发现此时存在脚本发起的2个 Worker CPU占用100%（由于用的 <code>Pytest + Pytest-xdist</code>  分布式插件执行用例），当时第一反应是死循环了？？</p><img src="https://i.loli.net/2021/01/22/AVhg7RGzYIfuWtN.png" alt="process_hang_1.png" style="zoom:50%;" /></li><li><p>通过<strong>perf</strong> 、<strong>ps</strong>或者 <strong>pstack</strong> 打印对应的pid， 看到的结果并没有什么太大用，反而<strong>误导我以为是代码里面的一个文件锁导致该问题</strong>。</p><img src="https://i.loli.net/2021/01/22/E1Yq9cjRo2GOx5e.png" alt="process_hang_2.png" style="zoom:50%;" /></li><li><p>网上查询了一通后，发现一个神奇的工具一一 <a href="https://www.zhihu.com/question/310832912">py-spy</a> （更多使用方法见 <a href="https://pypi.org/project/py-spy/">官网</a>）</p><p>安装后使用命令 ：选定一个异常的进程，执行命令： <code>py-spy  top --pid 19785</code> 打印结果如下，很明显看出来当前Cpu都卡在 <code>check_retry_status</code> 方法上面。</p><img src="https://i.loli.net/2021/01/22/CuRZJnsj13eTXoQ.png" alt="process_hang_3.png" style="zoom:50%;" /></li><li><p>查看该代码，发现该方法中存在一个while循环，并且很凑巧的是。。。╮(╯3╰)╭ 里面<font color=red><strong>没有兜底</strong></font>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体代码如下，过于相信传进来的 retry_flag 一定是1/2， 如果出现不是这两个值的时候，此时这个方法则进入了死循环。。。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_retry_status</span>(<span class="params">cls, uid, atk, order_id, retry_flag, devuuid</span>):</span></span><br><span class="line">    max_count = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> max_count &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> retry_flag == <span class="number">2</span>:</span><br><span class="line">        retry_flag = functionA(xxx, ...)</span><br><span class="line">        max_count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> retry_flag == <span class="number">1</span>:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;验证充值订单失败&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>到这个地方，就很明显定位到了问题，在此处加上兜底并且加上对应日志记录functionA（<strong>第三方依赖</strong>）到底返回的是什么。（ 因为首次传入的 retry_flag 也是来自于functionA）</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    写代码要谨慎。。。特别是结果来自第三方依赖的时候。。。<strong>一定要进行兜底！！！</strong></p><p>​    （emm… 兜一下总比不兜强）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python Plugin </tag>
            
            <tag> py-spy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python调用gRPC接口</title>
      <link href="posts/2a44a0fd/"/>
      <url>posts/2a44a0fd/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近几个项目都是用的go语言编写的，使用的是 gRPC接口，是没有对外暴露http接口。但在部分场景下，由于可测性的需要必须直接调用 gRPC接口，达到数据的构造，所以需要通过 <code>Python</code> 代码完成调用服务器上的 gRPC接口 。</p><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><p>​    由于网上相关最简单的demo已经是烂了一地。。。我这边就不再去重复写一段demo了（可参考当时我看的一篇<a href="https://cloud.tencent.com/developer/article/1557398">Blog</a>，或自行搜索相关前置准备）。</p><p>​    主要记录在实际过程中运用遇到的一些问题，希望能给大家一些帮助。</p><a id="more"></a><h4 id="步骤一：在执行转化脚本命令时候报错，具体信息如下："><a href="#步骤一：在执行转化脚本命令时候报错，具体信息如下：" class="headerlink" title="步骤一：在执行转化脚本命令时候报错，具体信息如下："></a>步骤一：在执行转化脚本命令时候报错，具体信息如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. ./user.proto</span><br><span class="line"></span><br><span class="line">github.com/gogo/protobuf/gogoproto/gogo.proto: File not found.</span><br><span class="line">base.proto: File not found.</span><br><span class="line">user.proto:7:1: Import <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span> was not found or had errors.</span><br><span class="line">user.proto:8:1: Import <span class="string">&quot;base.proto&quot;</span> was not found or had errors.</span><br><span class="line">user.proto:47:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:59:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:86:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:239:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:258:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br></pre></td></tr></table></figure><p>针对报错问题一个个分析。</p><h5 id="问题1-github-com-gogo-protobuf-gogoproto-gogo-proto-File-not-found。"><a href="#问题1-github-com-gogo-protobuf-gogoproto-gogo-proto-File-not-found。" class="headerlink" title="问题1: github.com/gogo/protobuf/gogoproto/gogo.proto: File not found。"></a>问题1: github.com/gogo/protobuf/gogoproto/gogo.proto: File not found。</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于转化的脚本中直接以如下方法引用的 gogo.proto 文件，但在转换的时候肯定是找不到的</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span></span><br></pre></td></tr></table></figure><p>解决办法：</p><ol><li><p>将 <a href="https://github.com/gogo/protobuf/blob/master/gogoproto/gogo.proto">gogo.proto</a> 文件下载到本地，放到与需要转换的 user.proto 文件同级目录下;</p></li><li><p>修改 user.proto 的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将如下代码修改成 import &quot;gogo.proto&quot;</span></span><br><span class="line">import <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="问题2-base-proto-File-not-found。"><a href="#问题2-base-proto-File-not-found。" class="headerlink" title="问题2: base.proto: File not found。"></a>问题2: base.proto: File not found。</h5><p>解决方式同问题1，实际就将依赖的这个 base.proto 文件放到与需要转换的 user.proto 文件同级目录下即可。（<code>由于我的 base.proto 文件中也同问题1中一样引用了 gogo.proto，所以都需要重复问题1的步骤2</code>）</p><p>经过上面操作，终于将 user.proto 文件转成了对应的python脚本，具体样式如下。</p><img src="https://i.loli.net/2021/02/07/B8rjYhz1ZksDfiq.png" alt="python_convert_grpc.png" style="zoom:40%;" /><p>但你以为这就完事了？？(╯▔︹▔)╯ ， <code>Too young too simple</code></p><h4 id="步骤二：调用转换成python脚本的接口。"><a href="#步骤二：调用转换成python脚本的接口。" class="headerlink" title="步骤二：调用转换成python脚本的接口。"></a>步骤二：调用转换成python脚本的接口。</h4><p><em>注：由于无需本地启动一个服务端，所以可以简单点只写一个调用端即可（具体方式类似 <code>BloomRPC</code>，通过  <code>kubectl</code> 代理到远端的 <code>grpc</code>服务端， 具体原理可自行搜索）</em></p><p>在写客户端代码之前，就还存在一个隐藏问题。</p><h5 id="问题3-实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成-python脚本（根据个人需要进行转换）。"><a href="#问题3-实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成-python脚本（根据个人需要进行转换）。" class="headerlink" title="问题3: 实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成 python脚本（根据个人需要进行转换）。"></a>问题3: 实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成 python脚本（根据个人需要进行转换）。</h5><p>客户端代码大致如下（<em>我编写的demo中则无需转换其它文件</em>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> user_pb2_grpc, user_pb2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">userService</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_mobile_by_id</span>(<span class="params">cls</span>):</span></span><br><span class="line">      <span class="comment"># 连接上本地的gRPC代理服务端, 端口为kubectl本地代理的端口</span></span><br><span class="line">        channel = grpc.insecure_channel(<span class="string">&#x27;localhost:6666&#x27;</span>) </span><br><span class="line">        <span class="comment"># 根据对应服务初始化渠道</span></span><br><span class="line">        test_stub = user_pb2_grpc.UserStub(channel)          </span><br><span class="line">        user_id = <span class="number">1234</span></span><br><span class="line">        <span class="comment"># 根据具体的 Request 定义来传入参数, 否则会报错</span></span><br><span class="line">        <span class="keyword">return</span> test_stub.GetXxxById(user_pb2.GetXxxByIdRequest(userId=user_id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(userService.get_mobile_by_id())</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 执行效果如下</span></span><br><span class="line">(ENV) ➜  demo_python_convert_grpc python user_client.py</span><br><span class="line">mobileId: <span class="string">&quot;11166668888&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数按照 user_pb2.py中方法Request定义的FieldDescriptor中具体的name来传入</span></span><br><span class="line">fields=[</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;userId&#x27;</span>, full_name</span><br><span class="line">      ...]</span><br></pre></td></tr></table></figure><p>​    至此，整体调用 <code>gRPC接口</code> 的流程算是跑通了，后续就看各自业务需求来定制化了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    最后吐槽下，很多时候准备做一件事的时候，发现网上教程挺多的，但是也会发现那些 “教程” 可能<strong>千篇一律</strong>。。。有些甚至一摸一样╮(╯Д╰)╭ 。。。当你真正按照这些 “教程” 来操作的时候又会发现可能不那么简单，所以说：<font color=blue><strong>实践是检验真理的唯一标准</strong> ！！！</font></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> gRPC接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Set命令</title>
      <link href="posts/cf736c07/"/>
      <url>posts/cf736c07/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    有时候在执行shell脚本的时候，在运行/调试的过程中会有些报错看起来不是太明显，那如何高效的调试自己编写的shell脚本呢？？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>​    网上有一些解决方案，但是尝试了下后觉得使用 shell 中的 <strong>set</strong> 命令来解决更加方便和快捷。下面来看看 <strong>set</strong> 命令到底能够有哪些应用场景。</p><a id="more"></a><h4 id="（1）set-u"><a href="#（1）set-u" class="headerlink" title="（1）set -u"></a>（1）set -u</h4><p>​    执行脚本的时候，有时候会遇到变量未定义（如：拼写错误导致变量未定义），Bash 默认是忽略它并且继续执行的，在某些场景这可能会对后面的脚本造成不可预期的错误操作， 所以可以通过 <code>set -u</code> 来控制，具体案例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line"></span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>​    可以看到，<code>echo $a</code> 输出了一个空行，Bash 忽略了不存在的 $a，然后继续执行 <code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p><p>通过脚本在头部加上 <code>set -u</code> 后，遇到不存在的变量就会报错，并停止执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -u</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 4: a: unbound variable</span><br></pre></td></tr></table></figure><h4 id="（2）set-x"><a href="#（2）set-x" class="headerlink" title="（2）set -x"></a>（2）set -x</h4><p>​    在执行复杂脚本的时候，需要对脚本进行类似debug一样的操作，则可以通过设置 <code>set -x</code>，这样就会对脚本中的执行过程的变量以及具体执行的代码进行输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line">name=<span class="string">&quot;tester&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;name&#125;</span> == <span class="string">&quot;tester&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;failed...&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> end</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">+ name=tester</span><br><span class="line">+ [[ tester == \t\e\s\t\e\r ]]</span><br><span class="line">+ <span class="built_in">echo</span> hello</span><br><span class="line">hello</span><br><span class="line">+ <span class="built_in">echo</span> end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>​    可以看到，在进行条件判断的时候，变量name被具体值替换了，打印了代码走到了条件分支的哪一步，以及打印了相应的有输出的代码行，行首以+表示。这对于调试复杂的脚本是很有用的。</p><h4 id="（3）set-e"><a href="#（3）set-e" class="headerlink" title="（3）set -e"></a>（3）set -e</h4><p>​    如果脚本里面有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令，在实际开发中，这种会导致比较严重的影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 5: foo: <span class="built_in">command</span> not found</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>通过使用 <code>set -e</code> 则可以运行失败的命令就直接退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 6: foo: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>也可以通过下面的方式来指定具体某个代码块运行失败后自动退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -e      <span class="comment"># 表示打开遇到运行命令返回非0则退出</span></span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line"><span class="built_in">set</span> +e      <span class="comment"># 表示关闭遇到运行命令返回非0则退出</span></span><br></pre></td></tr></table></figure><h4 id="（4）set-o-pipefail"><a href="#（4）set-o-pipefail" class="headerlink" title="（4）set -o pipefail"></a>（4）set -o pipefail</h4><p>​    <code>set -e</code> 有一个例外情况，就是不适用于管道命令。Bash 会把<strong>最后一个子命令的返回值</strong>，作为<strong>整个命令的返回值</strong>。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code> 就失效了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">foo | <span class="built_in">echo</span> a</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 7: foo: <span class="built_in">command</span> not found</span><br><span class="line">a</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>​    上面代码中，<strong>foo</strong>是一个不存在的命令，但是 <code>foo | echo a</code> 这个管道命令会执行成功，导致后面的 <code>echo bar</code> 会继续执行。</p><p>​     <code>set -eo pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本会在该管道执行完后终止执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line"></span><br><span class="line">foo | <span class="built_in">echo</span> a</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 7: foo: <span class="built_in">command</span> not found</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>​    可以看出，管道任务失败后，echo bar则未进行执行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    set命令的上面这四个参数，一般都放在一起使用，常用的两种方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell 脚本调试 </tag>
            
            <tag> Linux 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之优化（一）</title>
      <link href="posts/a3ff5801/"/>
      <url>posts/a3ff5801/</url>
      
        <content type="html"><![CDATA[<p>​    继上一篇搭建完最基础的Hexo环境并且发布一篇Demo文章后，基本上能满足了平时的个人Blog编写以及发布，但很多地方还是用户体验不太好，于是再对自己的Blog进行一系列的优化😁😁。</p><h4 id="优化一：Hexo-主题优化"><a href="#优化一：Hexo-主题优化" class="headerlink" title="优化一：Hexo 主题优化"></a>优化一：Hexo 主题优化</h4><p>​    网上搜了下大部分都用的 <a href="https://github.com/next-theme/hexo-theme-next">nexT</a> 这个主题，于是就直接参照对应的 <a href="https://theme-next.js.org/docs/getting-started/">官网链接</a> 操作即可。（顺便继续记录一些遇到的坑~~）如果觉得默认的主题已经不错了的可以直接跳过改步骤（<strong>但后续优化<font color=red>基于nexT v8.2.1版本优化</font>，不一定全部通用于其他主题</strong>）。</p><a id="more"></a><ul><li><p><strong>问题1: 由于官网是英文版，在网上搜索中文版本代码过老导致启动进入 localhost:4000页面仅展示如下错误内容。</strong></p><p>如果你看的教程是 <code>https://theme-next.iissnan.com/getting-started.html</code>，那么就要注意了，该链接中的nexT代码过于老旧了，可能会存在一定的问题，建议使用 <a href="https://theme-next.js.org/docs/getting-started/">官网链接</a> 。</p></li></ul><p><strong>参照最新版的教程修改完主题后，最新的样式就如下图：</strong></p><img src="https://i.loli.net/2021/02/03/1jk4csEovyJWgnM.png" alt="hexo_default.png" style="zoom:30%;" /><p>​    这个时候问题来了，<strong>如果每篇文章都如上，篇幅比较长，那么就导致首页每次展示的文章数量过少。</strong></p><h4 id="优化二：文章折叠展示-对文章添加分类、标签等"><a href="#优化二：文章折叠展示-对文章添加分类、标签等" class="headerlink" title="优化二：文章折叠展示 + 对文章添加分类、标签等"></a>优化二：文章折叠展示 + 对文章添加分类、标签等</h4><ul><li><p>步骤一：修改nexT主题目录下的_config.yml配置 (将文件中的注释去掉即可)。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure></li><li><p>步骤二：给文章添加对应的属性（如：tags、categories、description）。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="string">首次搭建个人Blog</span> <span class="string">问题记录（一）</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-02-01 22:14:05</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">blog搭建</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo建站</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">hexo建站</span></span><br></pre></td></tr></table></figure><p><strong>问题2：设置首页新增了 <code>tags 和 categories</code> 页后，点击进入到对应的 tags 或者 categories 的时候没有想要的内容， 仅仅一个 tags 或者 categories 标签。</strong></p><p>原因: 在执行 <code>hexo new page &quot;tags&quot;</code> 这一步自动生成的index.md 文件中内容缺失导致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决办法如下操作，打开对应的 blog_dir/source/tags/index.md 文件, 在最后补充如下代码</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span><span class="comment"># about/categories页操作将tags替换成about/categories即可</span></span><br></pre></td></tr></table></figure></li><li><p>步骤三：文章折叠的<a href="http://theme-next.iissnan.com/faqs.html#%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95">解决办法</a> (个人选择了方法一)</p></li></ul><p>优化完后的效果如下：</p><img src="https://i.loli.net/2021/02/03/1I6TEuywBj2QG7R.png" alt="nexT_first.png" style="zoom:40%;" /><h4 id="优化三：-文章生成短链接"><a href="#优化三：-文章生成短链接" class="headerlink" title="优化三： 文章生成短链接"></a>优化三： 文章生成短链接</h4><p>点开上图的阅读全文后，发现整体的链接是一大串文字，这个时候看起来就比较怪异，并且复制出来后直接会是URL编码的格式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://beanskingdom.github.io/2021/02/01/Hexo-首次搭建遇到的问题/#more</span><br><span class="line">https://beanskingdom.github.io/2021/02/01/Hexo-%E9%A6%96%E6%AC%A1%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/#more</span><br></pre></td></tr></table></figure><p>此时可以通过Hexo-abbrlink生成唯一永久文章链接（<a href="https://github.com/Rozbo/hexo-abbrlink">参考链接</a>）。 </p><p>最终的效果则为：<code>xxx/posts/48255dc8/#more</code></p><h4 id="优化四：修改文内链接样式"><a href="#优化四：修改文内链接样式" class="headerlink" title="优化四：修改文内链接样式"></a>优化四：修改文内链接样式</h4><p>nexT默认文章链接样式如下图：</p><img src="https://i.loli.net/2021/02/03/q2CwmFHZsNoyYlW.png" alt="next_link_style.png" style="zoom:40%;" /><p>为了突出区别性，我们在对应文件中添加下列的代码即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">themes</span>/<span class="selector-tag">next</span>/<span class="selector-tag">source</span>/<span class="selector-tag">css</span>/_<span class="selector-tag">common</span>/<span class="selector-tag">components</span>/<span class="selector-tag">post</span>/<span class="selector-tag">post-body</span><span class="selector-class">.styl</span></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的样式如下：</p><img src="https://i.loli.net/2021/02/03/L4j9vFUxBl2o3cM.png" alt="next_link_update.png" style="zoom:40%;" /><h4 id="优化五：给主页文章添加阴影效果"><a href="#优化五：给主页文章添加阴影效果" class="headerlink" title="优化五：给主页文章添加阴影效果"></a>优化五：给主页文章添加阴影效果</h4><p>打开<code>themes/next/source/css/_common/components/post/index.styl</code>文件，将<code>post-block</code>代码进行如下更改：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (hexo-config(&#x27;motion.transition.post_block&#x27;)) &#123;</span><br><span class="line">  # 添加如下代码</span><br><span class="line">    <span class="selector-class">.post-block</span>&#123;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">        <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">        background:rgba(255,255,255,0.9) none repeat scroll !important; //添加透明效果</span><br><span class="line">        <span class="selector-tag">-webkit-box-shadow</span>: 0 0 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(202, 203, 203, .5);</span><br><span class="line">        <span class="selector-tag">-moz-box-shadow</span>: 0 0 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(202, 203, 204, .5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="优化六：文章内部的导航栏位置优化"><a href="#优化六：文章内部的导航栏位置优化" class="headerlink" title="优化六：文章内部的导航栏位置优化"></a>优化六：文章内部的导航栏位置优化</h4><p>默认文章内部的导航栏位置是在左侧，看文章时候比较怪异，所以优化到了右边。</p><p>打开 <code>themes/next/_config.yml</code> 文件，将如下代码修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="comment"># position: left# 将改行注释掉，再去掉下面一行的注释</span></span><br><span class="line">  position: right</span><br></pre></td></tr></table></figure><h4 id="优化七：给文章末尾添加结束语"><a href="#优化七：给文章末尾添加结束语" class="headerlink" title="优化七：给文章末尾添加结束语"></a>优化七：给文章末尾添加结束语</h4><ul><li><p>在 <code>themes/next/layout/_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件，添加代码至该文件中；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">      &lt;div style=<span class="string">&quot;text-align:center;color: #ccc;font-size:20px;&quot;</span>&gt;------------- 本 文 结 束 &lt;i class=<span class="string">&quot;fa fa-paw&quot;</span>&gt;&lt;/i&gt; 感 谢 您 的 阅 读 -------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>themes/next/layout/_macro/post.njk</code> 文件，在 post-body 后，post-footer 前，添加下面内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">&#x27;passage-end-tag.swig&#x27;</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在如下内容之前添加上述代码</span></span><br><span class="line"><span class="comment">#    &#123;#####################&#125;</span></span><br><span class="line"><span class="comment">#    &#123;### END POST BODY ###&#125;</span></span><br><span class="line"><span class="comment">#    &#123;#####################&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在主题配置文件 <code>_config.yml</code> 在末尾添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="优化八：给代码块添加复制功能"><a href="#优化八：给代码块添加复制功能" class="headerlink" title="优化八：给代码块添加复制功能"></a>优化八：给代码块添加复制功能</h4><p>打开 <code>themes/next/_config.yml</code> 主题配置文件，搜索 codeblock ,开启复制，修改代码如下。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">copy_button:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span><span class="comment"># 显示复制按钮</span></span><br><span class="line">  <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">flat</span><span class="comment"># 复制按钮展示形式</span></span><br></pre></td></tr></table></figure><h4 id="优化九：实现统计功能"><a href="#优化九：实现统计功能" class="headerlink" title="优化九：实现统计功能"></a>优化九：实现统计功能</h4><p>在根目录下安装 <code>hexo-wordcount</code>,运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>然后在主题的配置文件中，配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    至此，部分个人体验相关的优化已经结束，这个时候可以开心的写blog了，自己看起来效果也不错，但这样你满足了么？？</p><p>​    当然不满意啦！！！ 至少要看到有多少人来看我的blog吧？😄😄静待后续优化。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 首次搭建个人Blog问题记录</title>
      <link href="posts/48255dc8/"/>
      <url>posts/48255dc8/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    看到别人那么炫酷的个人Blog后，自己也突然有了一些想法，既而最近看了《小强升职记》中的第五章让目标落地，于是便马上开始规划起了自己的Blog。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>​    通过这个Blog记录生活中的点点滴滴。</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>​    由于这类型的文章在网上太多了。。。具体的搭建过程就不一一搬运了。（个人觉得比较详细的一个链接：<a href="https://www.cnblogs.com/shwee/p/11421156.html">Hexo+Github: 个人博客网站搭建完全教程(看这篇就够了)</a>）</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>​    emm…有一个比较详细的教程是多么重要的一件事，虽然别人的Blog上看起来也就1个小时的事，实际自己做起来却花费了大半天😭😭。。。总结了以下在搭建过程中自己遇到的坑。</p><ol><li><p><strong>执行修改_config.yml文件后，执行创建新的文章命令时候报错。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;Bigbean&#x27;s demo&quot;</span></span><br><span class="line">FATAL TypeError: Invalid config detected: <span class="string">&quot;url&quot;</span> should be string, not object!</span><br><span class="line"></span><br><span class="line">原因：拷贝其他教程的配置文件时候，url:  <span class="comment">#网址 这个地方未配置</span></span><br></pre></td></tr></table></figure></li><li><p><strong>发布了第一篇文章后，页面打开显示错误。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端里面报错 </span></span><br><span class="line">WARN  No layout: index.html</span><br></pre></td></tr></table></figure><p>原因：在步骤3中按照参考链接中改了配置后，实际并没有链接中的那个主题 <code>theme: landscape-plus</code>， </p><p>所以<font color=red><strong>修改_config.yml配置文件的时候一定要注意！！！再次提醒不要全部照抄，应该仅仅是改自己需要改的地方。</strong></font></p></li><li><p><strong>在执行 <code>hexo d</code> 发布的时候报错。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: git</span><br><span class="line"><span class="comment"># 这是因为没安装hexo-deployer-git插件，在站点目录下输入下面的插件安装就好了</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p><strong>怎么再通过github的链接直接访问网上远端的效果呢？</strong></p><p>进入 github 项目中点击 Settings，向下拉到最后有个 GitHub Pages，点击 Choose a theme 选择一个主题。然后等一会儿，再回到 GitHub Pages，就会变成你选择的主题。<a href="https://zhuanlan.zhihu.com/p/35668237">参考链接</a></p></li><li><p><strong>按照6中的操作后，github page一直未被识别，导致点击链接去看里面样式找不到。（<a href="https://www.cnblogs.com/shwee/p/11421156.html">参考链接</a>）</strong></p><p>原因： 要创建一个和你用户名相同的仓库，后面加 <strong>.github.io</strong>，只有这样，将来要部署到 <code>GitHub page</code> 的时候，才会被识别 。例如我的：<a href="https://beanskingdom.github.io/">beanskingdom.github.io</a></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        至此。。。终于完成了第一篇内容的发布，后续还会继续进行相关的优化，如：主题、评论、搜索等等。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
