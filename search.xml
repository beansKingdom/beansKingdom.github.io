<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一次Pytest库升级遇到的问题</title>
      <link href="posts/18a06f9f/"/>
      <url>posts/18a06f9f/</url>
      
        <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>​    公司内部的接口自动化框架在一次pytest升级后，用例中的logging模块无法正常打印日志（原来logging.info可以正常打印日志到日志文件中，现在是不会输出到对应的日志文件中）。</p><p>​    <strong>存在的变更：原来使用 pytest==5.4.3 版本（后续称之为低版本）的时候，升级pytest后是6.2.3版本（后续称之为高版本）。</strong></p><a id="more"></a><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><h4 id="问题1-为什么使用高版本的Pytest库后，日志无法打印出来呢？"><a href="#问题1-为什么使用高版本的Pytest库后，日志无法打印出来呢？" class="headerlink" title="问题1: 为什么使用高版本的Pytest库后，日志无法打印出来呢？"></a>问题1: 为什么使用高版本的Pytest库后，日志无法打印出来呢？</h4><p>​    先统一测试代码，发现<font color=blue><strong>根本原因在于</strong></font>：<strong>高版本Pytest场景中，logging对象的root.handlers默认存在两个Handler，直接跳过了部分处理代码，最终使用两个Handler中默认的 _FileHandler 将日志写入到了/dev/null 中了。</strong> </p><blockquote><p>/dev/null  ： 在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。<br>在程序员行话，尤其是Unix行话中，/dev/null 被称为位桶(bit bucket)或者黑洞(black hole)。空设备通常被用于丢弃不需要的输出流，或作为用于输入流的空文件。这些操作通常由重定向完成。</p></blockquote><p>​    而低版本Pytest场景中，logging对象的root.handlers为空，进行处理后使用的是自定义的文件目录写入日志。(可对比两者的 <code>FileHandler</code> 对象区别，如下两图（上图为高版本的handlers，下图为低版本），<font color=gray><em>由于涉及到个人电脑目录，对低版本的日志文件路径进行了打码</em></font>)</p><img src="https://i.loli.net/2021/05/17/Yhq2xblTWJ9AE7n.png" alt="pytest-高版本打印日志问题.png" style="zoom:33%;" /><img src="https://i.loli.net/2021/05/17/EGOeSAfT5xJcbgQ.png" alt="低版本pytest-logging-handler.png" style="zoom:33%;" /><p>上述所述的部分处理代码如下（<code>logging库的__init__.py文件</code>， 低版本中通过 <code>len(root.handlers) == 0</code> 生成了用户自定义的 FileHandler对象）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicConfig</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    force = kwargs.pop(<span class="string">&#x27;force&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">    encoding = kwargs.pop(<span class="string">&#x27;encoding&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    errors = kwargs.pop(<span class="string">&#x27;errors&#x27;</span>, <span class="string">&#x27;backslashreplace&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> force:</span><br><span class="line">      <span class="keyword">for</span> h <span class="keyword">in</span> root.handlers[:]:</span><br><span class="line">        root.removeHandler(h)</span><br><span class="line">        h.close()</span><br><span class="line">    <span class="comment"># 高版本的Pytest在此处logging库中直接跳到最后，最终使用的是默认的 FileHandler，将内容打印到了/dev/null</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(root.handlers) == <span class="number">0</span>:</span><br><span class="line">      handlers = kwargs.pop(<span class="string">&quot;handlers&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">      <span class="keyword">if</span> handlers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>再深入一点继续往下探索！</p><h4 id="问题2-为什么高版本Pytest场景中，logging对象的root-handlers默认存在两个Handler？？"><a href="#问题2-为什么高版本Pytest场景中，logging对象的root-handlers默认存在两个Handler？？" class="headerlink" title="问题2: 为什么高版本Pytest场景中，logging对象的root.handlers默认存在两个Handler？？"></a>问题2: 为什么高版本Pytest场景中，logging对象的root.handlers默认存在两个Handler？？</h4><p>根本原因：高版本的Pytest对 <code>class LoggingPlugin</code> 类进行了修改，相关修改后导致出现该问题的代码如下（<strong>见注释部分</strong>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingPlugin</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Attaches to the logging module and captures log messages for each test.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, config: Config</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">...</span><br><span class="line">      <span class="comment"># 由于配置中未传入log_file配置，导致log_file默认为/dev/null</span></span><br><span class="line">      log_file = get_option_ini(config, <span class="string">&quot;log_file&quot;</span>) <span class="keyword">or</span> os.devnull</span><br><span class="line">      <span class="keyword">if</span> log_file != os.devnull:</span><br><span class="line">        directory = os.path.dirname(os.path.abspath(log_file))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(directory):</span><br><span class="line">          os.makedirs(directory)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 根据默认的log_file 生成一个_FileHandler对象，最终日志被写入到了/dev/null中</span></span><br><span class="line">      self.log_file_handler = _FileHandler(log_file, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 生成另外一个 _LiveLoggingNullHandler</span></span><br><span class="line">      self.log_cli_handler = _LiveLoggingNullHandler()</span><br></pre></td></tr></table></figure><p>上述代码中就生成了root.handlers中的默认的两个Handler，相对于低版本中的处理逻辑如下，由于未传入log_file配置，最终生成的 <code>log_file_handler</code> 和 <code>log_cli_handler</code> 都为None，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingPlugin</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Attaches to the logging module and captures log messages for each test.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, config: Config</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">...</span><br><span class="line">        log_file = get_option_ini(config, <span class="string">&quot;log_file&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> log_file:</span><br><span class="line">            self.log_file_handler = logging.FileHandler(</span><br><span class="line">                log_file, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">            )  <span class="comment"># type: Optional[logging.FileHandler]</span></span><br><span class="line">            self.log_file_handler.setFormatter(self.log_file_formatter)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.log_file_handler = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        self.log_cli_handler = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>​    至此大概的解决方案思路也清晰了，通过配置对应的 <code>log_file</code> 配置来解决，此处有两种方式。</p><ul><li><p>一种是直接写到根目录下的 <code>pytest.ini</code> 文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_file = data_factory_210517.log<span class="comment"># 该方式比较死板，如果想修改日志文件名称需要修改pytest.ini文件</span></span><br></pre></td></tr></table></figure></li><li><p>另外一种是直接通过 py.test 命令行执行的时候添加 <code>--log-file=xxx.log</code>（<font color=blue><strong>推荐</strong></font>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py.test --log-file=xxx.log <span class="comment"># 可在脚本中，根据用户自定义动态生成日志文件名称</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    大部分场景下，建议还是不要随意升级使用的组件库😭😭。。否则突然的改版可能会引起莫名其妙的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pytest </tag>
            
            <tag> Logging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask 序列化与反序列化</title>
      <link href="posts/db0729cb/"/>
      <url>posts/db0729cb/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    为什么写这篇话题呢，印象中是有次面试中，面试官问我是否了解 <code>Flask</code> 中的序列化与反序列化。由于自身的客观原因，当时对于该问题只能硬着头皮回答：不太了解乀(ˉεˉ乀) 乀(ˉεˉ乀) 。。。（个人觉得还是：基础知识不扎实）</p><p>​    后来这个问题也一直没去关注。。。此次突然想起来后进行一下记录（同样的地方不要翻车两次┑(￣。。￣)┍ ）。</p><a id="more"></a><h3 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h3><p>​    大概先了解了下相关定义：<code>Serialization</code> 和 <code>Deserialization</code> 即序列化和反序列化。Flask中是<strong>将对象类型数据转为json即为序列化</strong>，<strong>将json转为对象类型数据即为反序列化</strong>。</p><p>​    <strong>Flask</strong>中的序列化和反序列化还是比较简单，下面分别进行下理解。</p><h4 id="序列化-jsonify"><a href="#序列化-jsonify" class="headerlink" title="序列化 jsonify()"></a>序列化 jsonify()</h4><p>​    Flask jsonify()的代码还是很简单， 可以理解在默认情况下，Flask的序列化就是直接使用了 <code>json.dumps()</code>，再通过 <code>Response</code> 对象直接返回了 ╮(╯Д╰)╭ ，核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 唯一就是在用法上有点区别， Flask的jsonify会对传入的参数进行取舍，具体逻辑如下</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:  <span class="comment"># single args are passed directly to dumps()</span></span><br><span class="line">  data = args[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  data = args <span class="keyword">or</span> kwargs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终将 data 通过 json.dumps() 进行序列化</span></span><br><span class="line"><span class="keyword">return</span> current_app.response_class(</span><br><span class="line">  dumps(data, indent=indent, separators=separators) + <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  mimetype=current_app.config[<span class="string">&quot;JSONIFY_MIMETYPE&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>看到网上其他人说了一些更深层次的内容， <a href="https://m.yisu.com/zixun/227014.html">参考链接</a>，<a href="https://www.kancloud.cn/schip/klause/1021392">参考链接2</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下用的都是 app.json_encoder， 如果有特殊需求，可以对该encoder进行自定义</span></span><br><span class="line"><span class="keyword">if</span> app:</span><br><span class="line">  ...</span><br><span class="line">  kwargs.setdefault(</span><br><span class="line">    <span class="string">&quot;cls&quot;</span>, bp.json_encoder <span class="keyword">if</span> bp <span class="keyword">and</span> bp.json_encoder <span class="keyword">else</span> app.json_encoder</span><br><span class="line">  )</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  ...</span><br><span class="line">  kwargs.setdefault(<span class="string">&quot;cls&quot;</span>, JSONEncoder)</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 用户也可以通过对 app.json_encoder 进行二次封装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONEncoder</span>(<span class="params">_json.JSONEncoder</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;The default Flask JSON encoder. This one extends the default</span></span><br><span class="line"><span class="string">    encoder by also supporting ``datetime``, ``UUID``, ``dataclasses``,</span></span><br><span class="line"><span class="string">    and ``Markup`` objects.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    # 通过该对象可以定制化，比如我们要返回给前端的是一个从数据库查询的模型对象。那么就可以通过重写该方法进行定制化。</span></span><br></pre></td></tr></table></figure><h4 id="反序列化-request-get-json"><a href="#反序列化-request-get-json" class="headerlink" title="反序列化 request.get_json()"></a>反序列化 request.get_json()</h4><p>​    同样的。。。 Flask的反序列化也挺简单，可以理解在默认情况下， Flask的反序列化就是直接使用了 <code>json.loads()</code>，核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data = self._get_data_for_json(cache=cache)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  rv = self.json_module.loads(data)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># self.json_module.loads()</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(s, <span class="built_in">bytes</span>):</span><br><span class="line">  <span class="comment"># Needed for Python &lt; 3.6</span></span><br><span class="line">  encoding = detect_utf_encoding(s)</span><br><span class="line">  s = s.decode(encoding)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _json.loads(s, **kw)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    额。。。本来以为是什么，实际查了下对应的资料后，从比较浅的层次来说， Flask中的序列化以及反序列化实际就是使用的 json库中自带的 <code>dumps</code> 和  <code>loads</code> 。（也可能是才疏学浅，没有太了解深层次的使用场景😂， 比如： <a href="https://m.yisu.com/zixun/227014.html">Flask序列化</a>），所以，不要被一些 “名词” 高大上的样子忽悠了，可能实际内容并不复杂，<strong>困难的是做出去解决这个问题的决心</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Python </tag>
            
            <tag> 序列化与反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断Excel文件中是否存在合并单元格</title>
      <link href="posts/eaf4f2e8/"/>
      <url>posts/eaf4f2e8/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在用例管理平台上可以编辑Excel用例文件，但如果上传了合并单元格的Excel用例文件，编辑时候处理起来会无法判断如何去拆解单元格，最终解决方式是：禁止上传存在合并单元格的Excel文件。（那么就<strong>需要在上传的时候校验文件中是否存在合并单元格。</strong>）</p><p>​    通过网上的资料查询了下，实现方案就是通过 <code>sheet.merged_cells</code> 来解决该问题，核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">workbook = xlrd.open_workbook(<span class="string">r&#x27;py.xlsx&#x27;</span>)</span><br><span class="line">sheet = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 如果该值返回的列表长度非0则存在合并单元格，否则不存在。</span></span><br><span class="line"><span class="keyword">return</span> sheet.merged_cells</span><br></pre></td></tr></table></figure><a id="more"></a><p>​    <font color=gray><em>PS: 本文主要是记录下过程中遇到的问题以及一些扩展。</em></font></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="问题1-后端报错：expected-str-bytes-or-os-PathLike-object-not-FileStorage"><a href="#问题1-后端报错：expected-str-bytes-or-os-PathLike-object-not-FileStorage" class="headerlink" title="问题1: 后端报错：expected str, bytes or os.PathLike object, not FileStorage"></a>问题1: 后端报错：expected str, bytes or os.PathLike object, not FileStorage</h4><p>​    由于文件是直接通过前端上传的，所以传到后端是一个 <code>FileStorage</code> 对象，通过上述方式实现会直接报错。如果仅仅是简单的通过 <code>file_storage.read()</code> 转换成 bytes 后，仍然会有其他新的报错（<code>embedded null byte</code>）。</p><p>​    最终使用如下方案来进行解决（因为后端原本都是使用 <code>Pandas</code> 库去处理Excel文件的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">book = openpyxl.load_workbook(case_file)</span><br><span class="line">writer = pd.ExcelWriter(case_file, engine=<span class="string">&#x27;openpyxl&#x27;</span>)</span><br><span class="line">writer.book = book</span><br><span class="line"></span><br><span class="line">writer.sheets = <span class="built_in">dict</span>((ws.title, ws) <span class="keyword">for</span> ws <span class="keyword">in</span> book.worksheets)</span><br><span class="line"><span class="keyword">for</span> sheet <span class="keyword">in</span> writer.sheets.values():</span><br><span class="line">  merged_list = sheet.merged_cells</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(merged_list.ranges) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;【%s】文件内容错误, 暂不支持文件中存在合并的单元格。&quot;</span> % case_file.filename)</span><br></pre></td></tr></table></figure><p>验证了下，在上传带有单元格的文件时，会触发异常，正准备高高兴兴码完代码休息下～(￣▽￣～)(～￣▽￣)～ 。然而出于基本的开发素质，我又验证了不带单元格的文件。然而打脸总是来的这么突然。。。😭。</p><p>​    上传失败，后端返回错误 <code>OSError: [Errno 22] Invalid argument</code>。（<strong>事实再次证明：不要以为功能简单就不验证</strong>(￣ε ￣) 。。。老铁，来吧！继续撸袖子修BUG。）</p><h4 id="问题2-OSError-Errno-22-Invalid-argument"><a href="#问题2-OSError-Errno-22-Invalid-argument" class="headerlink" title="问题2:  OSError: [Errno 22] Invalid argument"></a>问题2:  OSError: [Errno 22] Invalid argument</h4><p>​    通过本地调试，发现触发异常的位置在文件被上传保存后，再次去读取该文件内容的时候。抛错的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = pd.ExcelFile(file_abs_path)</span><br></pre></td></tr></table></figure><p>看了下文件的剧对路径，确定文件是存在的，然后去下载下来打开时，提示文件打开遇到错误。。。（并且此时的文件大小小于实际文件的大小，原文件17KB，上传后的文件12KB）。</p><img src="https://i.loli.net/2021/04/14/F69Xw2OopIKJg4G.png" alt="file-storage-4.png" style="zoom:50%;" /><p>​    通过一步步的调试，发现罪魁祸首在于 <code>openpyxl.load_workbook(case_file)</code>，该操作会直接对传入的 <strong>FileStorage</strong> 对象进行操作，导致文件内容变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原数据 case_file.read() 大小为16804，处理后case_file.read() 大小为11528</span></span><br><span class="line">openpyxl.load_workbook(case_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于为什么文件大小会变小，是因为操作中会将缓存内的文件内容读取，导致实际在缓存内的内容变少，有兴趣的可以深入研究，核心代码如下：</span></span><br><span class="line">reader = ExcelReader(filename, read_only, keep_vba, data_only, keep_links)</span><br><span class="line">reader.read()</span><br></pre></td></tr></table></figure><p><strong>最终解决方案则是</strong>：在问题1的代码块后， 新增代码：<code>case_file.stream.seek(0)</code>  即可，通过将原 <code>FileStorage</code> 对象缓存里面的内容指向最初的位置即可。</p><h4 id="问题3-xlrd-biffh-XLRDError-File-size-is-0-bytes"><a href="#问题3-xlrd-biffh-XLRDError-File-size-is-0-bytes" class="headerlink" title="问题3: xlrd.biffh.XLRDError: File size is 0 bytes"></a>问题3: xlrd.biffh.XLRDError: File size is 0 bytes</h4><p>在获得最终解决方案的过程之前，还遇到了问题3，因为 <strong>FileStorage</strong> 对象在内存中的内容已经被拿出来操作了，实际缓存中的数据大小变成了0，导致了上述的报错。（<a href="https://www.pythonheidong.com/blog/article/754328/9439a5fd9830ea11dd92/">参考链接</a>），如下是对于 <strong>FileStorage</strong> 对象的一个注解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.datastructures <span class="keyword">import</span> FileStorage</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStorage</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;The :class:`FileStorage` class is a thin wrapper over incoming files.</span></span><br><span class="line"><span class="string">    It is used by the request object to represent uploaded files.  All the</span></span><br><span class="line"><span class="string">    attributes of the wrapper stream are proxied by the file storage so</span></span><br><span class="line"><span class="string">    it&#x27;s possible to do ``storage.read()`` instead of the long form</span></span><br><span class="line"><span class="string">    ``storage.stream.read()``.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    通过上述一系列的骚操作（瞎折腾）后，终于完成了最初的需求。。。╮(╯Д╰)╭ ，因为过程中很多奇奇怪怪得报错导致整个过程还是挺艰辛的。</p><p>​    <strong>⚠️ 心得</strong>：大多数时候都是网上直接搜了解决方案，但是由于基础不扎实，在进行实施的时候，各种坑就埋在你脚下了。。。有些时候需要<strong>更多的去思考或者了解为什么使用这个方案，以及询问自己更多次为什么会出现这个问题，而不仅仅是解决。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
            <tag> Excel文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小强升职记读后感</title>
      <link href="posts/f1ff3319/"/>
      <url>posts/f1ff3319/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    时光飞逝。。。转眼就工作了6年了（已经转变成了一个老油条）┑(￣Д ￣)┍ ，有时候会感觉这时间都去哪里了？</p><p>​    在工作中平时有时候挺忙的，总感觉时间不太够用；有时候想起来要锻炼身体，但又觉得时间不太够，所以一拖再拖。缺乏人际关系的维护以及缺乏生活中的其他乐趣，感觉生活越发的枯燥无味。<strong>如果读者和我有同样的感受，那么强烈推荐继续阅读下去。</strong></p><p>​    有幸的是我察觉了这个问题的严重性，主动去找时间管理的书籍开始阅读，首先接触的是<a href="https://book.douban.com/subject/25852981/">《小强升职记》</a>，在通读全书后收益颇丰。（PS：如果已经是时间管理的大佬了就可以直接跳过该文章了。）</p><a id="more"></a><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>​    本书中以 “小强” 的故事向你娓娓道来，把时间管理的精华融入鲜活的情景。对于我这种工作年限的职场打工人来说，内容浅显易懂并且符合现实场景。</p><p>​    下面对每个章节进行了简单的整理以及一些个人的理解。</p><h4 id="1-时间去哪里了"><a href="#1-时间去哪里了" class="headerlink" title="1. 时间去哪里了"></a>1. 时间去哪里了</h4><p>​    在6年的工作中，有些时候总感觉自己很忙，但实际回想起来，都不知道是在忙什么。</p><p>​    本章的第一个问题就深深的触动了我一一<font color=red><strong>自己真的很忙么？</strong></font>通过事实先确认自己是否很忙，然后再去分析时间的真实去向。我按照书中的方法后，明显发现<strong>自己至少浪费了一半的时间</strong>在无意义的事情上（如果算每天仅工作8小时，也就是有4～5个小时是浪费的）。</p><p>​    本章节的重点在于：<code>发现自己的时间黑洞以及找到自己的高效时段。</code></p><img src="https://i.loli.net/2021/03/30/YJCM5HIQruhOe8t.png" alt="小强升职记-1.png" style="zoom:40%" /><h4 id="2-无压工作术"><a href="#2-无压工作术" class="headerlink" title="2. 无压工作术"></a>2. 无压工作术</h4><p>​    既然发现浪费了这么多时间，怎么快速的缓解以及改善这个问题呢？</p><p>​    第二章中先对所有的事情进行了一个分类一一四象限分类（使用矩阵法从重要、紧急两个维度进行划分），一个比较完美的状态应该是大多数时候在处理 <code>重要不紧急</code> 的事情（第二象限的事情）。但实际工作中并不如意，就我个人而言，大多数每天的工作可能都处于 <code>重要紧急</code>、<code>不重要紧急</code>、<code>不重要不紧急</code> ╮(╯Д╰)╭ 。</p><p>​    比如：早上原计划要完成功能A的开发或者测试，但是突然被通知早上要开会，任务被拖延到了下午，到了下午正准备开始或者开始了一半，突然又被通知去完成事件B、C、D等，在这种反复中断的情况下，最终原定的计划”顺利”的拖延到了第二天╮(╯Д╰)╭ 。这种情况对于职场新人可能屡见不鲜。</p><p>​    然后介绍了一些初级的时间管理方法，如：第二象限工作法、猴子法则、<code>衣柜整理法</code>。（PS：通过衣柜整理法，我初步的感觉到自己掌控了时间，而不是时间掌控我）</p><p>​    本章节的重点在于：<code>掌握衣柜整理法。</code></p><img src="https://i.loli.net/2021/03/30/3LnoKFDR9ksCcmB.png" alt="小强升职记-2.png" style="zoom:40%;" /><h4 id="3-遇到问题怎么办"><a href="#3-遇到问题怎么办" class="headerlink" title="3. 遇到问题怎么办"></a>3. 遇到问题怎么办</h4><p>​    在第二章中介绍了初级的时间管理方法，但肯定会遇到各种各样的问题（没有哪个方法是可以试用所有场景的）。第三章中紧接着就介绍了相对的应对措施。比如：</p><ul><li><p><strong>臣服精力、臣服环境、臣服天性；</strong></p><p>其中对于臣服天性让我印象比较深刻，书中通过引用了<a href="https://book.douban.com/subject/10828002/">《游戏改变世界》</a>这本书的理念，让我更加深刻理解如何去对待工作。</p><p><strong>为什么大家喜欢玩游戏</strong>，如英雄联盟、魔兽世界等？我个人理解最重要的一点就是：<strong>及时反馈</strong>。比如：英雄联盟里面的排位到了最强王者，那么平时和伙伴聊天的时候看着别人羡慕的表情，又或者魔兽世界里面工会成为第一个开荒成功的团队所带来的自豪感等等。</p><p>反过来就很容易得出<strong>为什么大家不喜欢工作</strong>，工作中常常是琐碎的杂事、大部分时候的工作又是没有任何的反馈等等，那么久而久之大家就厌烦了工作。（有兴趣的可自行阅读）</p></li><li><p><strong>做事靠系统，不是靠感觉。</strong></p><p>这个就需要我们多对平时的工作进行复盘（每日回顾、每周回顾等），总结出自己的经验，这样才不至于每次遇到问题都和无头苍蝇一样到处乱撞。</p></li></ul><p>​    本章节的重点在于：<code>学会臣服。</code></p><img src="https://i.loli.net/2021/03/30/jflcPNLtbX7OQ1M.png" alt="小强升职记-3.png" style="zoom:40%;" /><h4 id="4-如何养成一个好习惯"><a href="#4-如何养成一个好习惯" class="headerlink" title="4. 如何养成一个好习惯"></a>4. 如何养成一个好习惯</h4><p>​    很多时候，<font color=red><strong>道理大家都懂，但就是不那样去做</strong> </font>😂😂。。。就好像上述的几章已经很详细的介绍了时间管理该如何做，但是你要是不能按照上述的方法来做，那也等于白看。恰巧本章介绍了如何去养成一个好的习惯。</p><p>​    这个过程还是比较艰难的，每个人可能又不太一样，我是在实践2～3个月后，才算勉强初步养成了 <code>衣柜整理法</code> 的习惯。可能有人问：为什么要学时间管理？用一句话就是：自律即自由。（因为是你在主动掌控时间了，大多数时候可以选择什么时候干什么，而不是在什么时候被动的去干什么，比如：计划周末去公园踏春，但由于周内没按时完成工作任务，时间都用去玩游戏、逛街等等，那就只能周末被迫的加班完成。）</p><p>​    本章节重点在于：<code>通过借鉴书中方法，形成自己的养成好习惯的方法。</code></p><img src="https://i.loli.net/2021/03/30/1hepGAWuFvbkrjJ.png" alt="小强升职记-4.png" style="zoom:40%;" /><h4 id="5-如何让想法落地"><a href="#5-如何让想法落地" class="headerlink" title="5. 如何让想法落地"></a>5. 如何让想法落地</h4><p>​    随着工作的时间越来越久，有时候我会有些其他想法，比如：<strong>非工作方向</strong>就是全国旅游、学习潜水、滑雪等，<strong>工作方向</strong>就是开发一个内部平台、全方面的学习Docker、sonar扫描等…但这些想法大部分时间都<strong>仅仅是在自己脑海里面自嗨</strong>。。。</p><p>​    本章通过小强的一个想法，很接地气的描述了如何让这个想法落地，个人觉得该方法十分实用（有兴趣的可以仔细去阅读一遍）。该方法主要涉及的有： <code>SMART原则</code>、<code>思维脑图</code>、<code>甘特图</code>，这些在工作后就有所接触，所以该方法接纳起来还是比较容易。</p><p>​    还有一个比较新颖的观点是：<code>九宫格平衡人生</code>，这个再一次打开了我的思维，由于原来的时间大部分花费在工作上，所以很容易出现生活枯燥无味的想法。在接触了这个观点后，瞬间又觉得生活可以绚丽多彩。</p><p>​    本章节重点在于：<code>通过熟练掌握SMART原则、思维脑图、甘特图等工具，最终让想法真实落地。</code></p><img src="https://i.loli.net/2021/03/30/tPRj2b5TQimGZsg.png" alt="小强升职记-5.png" style="zoom:40%;" /><h3 id="书中语录"><a href="#书中语录" class="headerlink" title="书中语录"></a>书中语录</h3><ul><li><strong>时间管理，管理的是承诺；</strong></li><li><strong>做事靠系统，而不是靠感觉；</strong></li><li><strong>不要问自己 “该往哪儿走”，只要回答自己 “想往哪儿走”；</strong></li><li><strong>优秀的人有优秀的系统， 普通的人有普通的系统，失败的人没有系统；</strong></li><li><strong>力量来自于你的内心；</strong></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    整体而言，这本书对于一个未接触过时间管理的小白来说，还是很经典的一本书！个人认为在看完本书后，收益颇丰。</p><p>​    在实践了2～3个月后，也有了一些自己的见解，虽然书中的实例很接地气，但是真正在实践的过程中，不一定那么顺利。所以最主要的还是通过不断的实践，<code>将这一套 &quot;小强&quot;的时间管理方法变成自己的 &quot;时间管理方法&quot;！</code></p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 时间管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构化思维读后感</title>
      <link href="posts/6ac03032/"/>
      <url>posts/6ac03032/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在几次工作总结或者是处理事情上觉得自己的思维比较混乱，比如：在周会上想和组员进行一些内容分享，但由于开始没准备充分，在实际讲的过程中比较混乱，自己讲完后都觉得难以吸收；还有就是在表达自己想法的时候，思路比较天马行空，往往是讲着讲着就没什么逻辑关联，导致听起来云里雾里的。</p><p>​    于是网上搜索了下相关书籍，推荐了 <a href="http://byteliu.com/PDF/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86.pdf">《金字塔原理》</a>，但看了几章后感觉不太好时间，又找了这本 <a href="https://read678.com/JdBook/index/16756">《结构化思维》</a>，个人感觉还是很符合<strong>入门级别的结构化思维书籍</strong>（后续可以再进行金字塔原理的阅读），借此在看完整本后再进行一个整体回顾。（<em>PS：个人觉得这本书阅读完后收益还是挺多的。</em>）</p><a id="more"></a><h3 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h3><p>​    本书总共五章，下面分别对每一篇进行一个总结。前3章基本上是对于思维相关的介绍（如思维的意义、思维的过程等），第4章是详细的介绍了金字塔结构，第5章是介绍了常用的几种思维模型。</p><h4 id="第一章-初识思维"><a href="#第一章-初识思维" class="headerlink" title="第一章 初识思维"></a>第一章 初识思维</h4><p>​    本章节的内容还是比较简单，个人理解 <code>最主要的就是理解思维的意义</code>，如果对于看文章没什么太大兴趣的，推荐去看<strong>刘德华的《拆弹专家2》</strong>这部电影（刚好是我在看这本书的过程中看到的一部电影，很形象的描述了主角在影片中思维对他的影响），这也是书籍中介绍的故事思维可以更容易让人理解一个道理😂😂。（<font color=blue><em>脑图中有颜色标记的是我个人认为更加需要注意的点</em>，后面不再重复阐述</font>）</p><img src="https://i.loli.net/2021/03/23/xbE8FB4tQUAzih6.png" alt="结构化思维-1-初识思维.png" style="zoom:40%;" /><h4 id="第二章-深入思维"><a href="#第二章-深入思维" class="headerlink" title="第二章 深入思维"></a>第二章 深入思维</h4><p>​    本章节介绍的概念较多，其中我个人认为比较重要的有两个点。（⚠️ 注意：<strong>思维是一直在变化的</strong>，每个人在不同年龄或者不同场景下，都可能对同一件事情有不同的看法、态度。）</p><ul><li><p><strong>信息的获取</strong></p><p>在现实生活中可能常常看到墙壁上贴着宽带一年只要599、2室1厅一年仅要2000等等，当你真正打电话过去咨询的时候别人会告诉你这些都没了，大多数时候<font color=red><strong>你很容易获得的信息都是别人故意让你看到的信息</strong></font>，所以不要因为看到某些信息后就马上给出定论。</p></li><li><p><strong>信息的加工</strong></p><p>对于平时<strong>工作经历应该多进行归纳</strong>，这样才能形成属于自己特定的经验。再对自己<strong>总结的经验（结论）多进行演绎</strong>，这样才能验证这些经验（结论）的正确性，通过这样的良性循环，最终形成自己的方法论才能更好的成长。</p></li></ul><img src="https://i.loli.net/2021/03/23/fKapOt59MdQh8rC.png" alt="结构化思维-2-深入思维.png" style="zoom:40%;" /><h4 id="第三章-归纳与演绎"><a href="#第三章-归纳与演绎" class="headerlink" title="第三章 归纳与演绎"></a>第三章 归纳与演绎</h4><p>​        本章节比较细致介绍了归纳与演绎。这里就不做详细的阐述，有兴趣可以自行翻阅本书进行了解。</p><img src="https://i.loli.net/2021/03/23/M71tPoJSgCGxp5n.png" alt="结构化思维-3-归纳和演绎.png" style="zoom:40%;" /><h4 id="第四章-结构化思维"><a href="#第四章-结构化思维" class="headerlink" title="第四章 结构化思维"></a>第四章 结构化思维</h4><p>​    本章节是对于金字塔结构的一个专辑讲解，这也是我看完后对金字塔结构更深入的理解，方便后面对《金字塔原理》进行阅读。</p><p>​    个人理解 <code>最重要的为金字塔结构四个原则：结论先行、以上统下、归类分组、逻辑递进。</code>，然后在这四个中比较难的主要在于归类分组以及逻辑递进（这个也正好是我觉得自己最需要加强的能力），其中讲解的几个方法在看了后深有感触。比如：</p><ul><li><strong>归类分组</strong>：<strong>二分法、矩阵法、公式法、流程法</strong>这些在平时工作中常常遇见，所以运用起来更加容易上手。</li><li><strong>逻辑递进</strong>：<strong>时间顺序、重要性顺序</strong>等。</li></ul><img src="https://i.loli.net/2021/03/23/YRgfOQbKqvHAChk.png" alt="结构化思维-4.png" style="zoom:40%;" /><h4 id="第五章-常用的思维模型"><a href="#第五章-常用的思维模型" class="headerlink" title="第五章 常用的思维模型"></a>第五章 常用的思维模型</h4><p>​    本章最终是介绍了常用的思维模型（<font color=gray><em>部分思维模型可能觉得有点重复就未进行梳理</em></font>），个人再根据我自己的理解进行了一个排序：<strong>5W2H、流程思维、故事思维、客户思维</strong>。并且在我个人的工作经验中，发现 <code>流程思维</code> 和 <code>客户思维</code> 更是自己的短板，比如在客户思维中的实例中：加班较多并且也没有给自己加工资，此时仅仅是抱怨老板或者领导么？自己是否恰当的去反馈了这些问题呢？（如：你是否工作安排合理？ 你是否缺乏时间管理意识等等）。</p><img src="https://i.loli.net/2021/03/23/ATfn8eIqb3zvmVu.png" alt="结构化思维-5-思维模型.png" style="zoom:45%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    不管是生活中还是工作中，思维都起到一个重要的作用，乐观而又积极的思维会让你的生活丰富多彩，悲观而又消极的思维会让你的生活黯然失色，引用书中的一句话： <code>如果过往事实不能改变，我们就只能改变思维，改变面对事实的态度和行为，让未来过得更好，避免发生悲剧。改变思维才是改变一切的源头。</code> </p><p>​    看书的最重要的点就是能够把<font color=red><strong>看到的知识运用到实际场景中</strong></font>，这样也算对得起自己用来看书花费的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之Pandas库躺坑记</title>
      <link href="posts/617073a5/"/>
      <url>posts/617073a5/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​        最近在开发一个线上用例管理平台，需要使用 <code>Python语言</code> 对 <code>Excel文件</code> 进行一系列的操作，网上大致搜索了下常用的库，最后决定使用 <code>Pandas</code> 库（原因就不具体阐述了）。在使用的过程中，大部分的需求都能满足，但是还是有部分需求通过不断躺坑最终解决了。</p><p>Pandas 库常用的方法就不一一阐述了，可以参考如下链接。</p><ul><li><p><a href="http://www.fixbbs.com/p/0844377.html">Python Pandas读取修改excel操作攻略</a> </p></li><li><p><a href="https://blog.csdn.net/zhangchuang601/article/details/79583551">Pandas DataFrame数据的增、删、改、查</a></p></li></ul><p>在此将整个过程中遇到的一些特定的问题进行记录┑(￣。。￣)┍ ┑(￣。。￣)┍ 。</p><a id="more"></a><h3 id="特殊问题"><a href="#特殊问题" class="headerlink" title="特殊问题"></a>特殊问题</h3><h4 id="问题1-部分Excel文件单元格进行了合并或者单元格内容为空"><a href="#问题1-部分Excel文件单元格进行了合并或者单元格内容为空" class="headerlink" title="问题1. 部分Excel文件单元格进行了合并或者单元格内容为空"></a>问题1. 部分Excel文件单元格进行了合并或者单元格内容为空</h4><p>需要对合并了的单元格或者单元格内容为空的进行内容，通过Debug发现此时值为 <code>Nan</code>。</p><p><strong>解决办法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将单元格的值赋值给data</span></span><br><span class="line">data = df.iloc[iRow, iCol]</span><br><span class="line"><span class="comment"># 通过如下方法判断 data 是否为 Nan， 是则返回 True。</span></span><br><span class="line"><span class="built_in">isinstance</span>(data, <span class="built_in">float</span>) <span class="keyword">and</span> math.isnan(df.iloc[iRow, iCol])</span><br></pre></td></tr></table></figure><h4 id="问题2-使用Panads的to-excel方法会覆盖其他所有的sheet"><a href="#问题2-使用Panads的to-excel方法会覆盖其他所有的sheet" class="headerlink" title="问题2. 使用Panads的to_excel方法会覆盖其他所有的sheet"></a>问题2. 使用Panads的to_excel方法会覆盖其他所有的sheet</h4><p>具体问题：在使用pandas的 <code>df.to_excel(file_path)</code> 想要对一个有多张sheet的workbook操作时一定会尴尬的发现：永远只存在最后一次写进去的表，其他的sheet表都被清空了，并且最后一次写进去的表的样式也未保存。</p><p><strong>解决办法：</strong> <a href="https://zhuanlan.zhihu.com/p/85918022">参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># file_abs_path excel文件的绝对路径</span></span><br><span class="line">excel_sheet_handle = pd.read_excel(file_abs_path, sheet_name=<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="comment"># ... 中间对 sheet1 进行一系列值的改动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过下方的代码将其他 sheet 的内容与最新的 sheet1 表进行合并。</span></span><br><span class="line">book = openpyxl.load_workbook(file_abs_path)</span><br><span class="line">writer = pd.ExcelWriter(file_abs_path, engine=<span class="string">&#x27;openpyxl&#x27;</span>)</span><br><span class="line">writer.book = book</span><br><span class="line"></span><br><span class="line">writer.sheets = <span class="built_in">dict</span>((ws.title, ws) <span class="keyword">for</span> ws <span class="keyword">in</span> book.worksheets)</span><br><span class="line"><span class="comment"># index 为序号, header 为原来的表头</span></span><br><span class="line">excel_sheet_handle.to_excel(writer, sheet_name=<span class="string">&quot;sheet1&quot;</span>, index=<span class="literal">False</span>, header=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>通过如上的办法就可以将所有表都保存下来，并且保存了原有的样式， sheet1表的内容也修改正确。</p><h4 id="问题3-使用了问题2的办法后，使用Panads-drop-方法在最后出现重复行。"><a href="#问题3-使用了问题2的办法后，使用Panads-drop-方法在最后出现重复行。" class="headerlink" title="问题3. 使用了问题2的办法后，使用Panads.drop()方法在最后出现重复行。"></a>问题3. 使用了问题2的办法后，使用Panads.drop()方法在最后出现重复行。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file_abs_path excel文件的绝对路径</span></span><br><span class="line">excel_sheet_handle = pd.read_excel(file_abs_path, sheet_name=<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="comment"># 将文件的第2、3行删除掉</span></span><br><span class="line">excel_sheet_handle.drop([<span class="number">1</span>, <span class="number">2</span>], inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>具体问题现象</strong>如下：存在文件A，里面的sheet1表中有4行数据（如下），通过上述代码的drop删除后， 再调用问题2中的办法进行保存，发现sheet1表中仍然有4行， 内容为原来的第1、4、3、4 行内容，实际预期应该只是第1、4行的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># excel_sheet_handle.drop([1, 2], inplace=True)</span></span><br><span class="line"><span class="comment"># 原数据</span></span><br><span class="line">   A   B   C   D</span><br><span class="line">0  0   1   2   3</span><br><span class="line">1  4   5   6   7</span><br><span class="line">2  8   9  10  11</span><br><span class="line">3  3   2   6   7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预期应该为：</span></span><br><span class="line">   A   B   C   D</span><br><span class="line">0  0   1   2   3</span><br><span class="line">3  3   2   6   7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际结果为：</span></span><br><span class="line">   A   B   C   D</span><br><span class="line">0  0   1   2   3</span><br><span class="line">3  3   2   6   7</span><br><span class="line">2  8   9  10  11</span><br><span class="line">3  3   2   6   7</span><br></pre></td></tr></table></figure><p><strong>具体原因：</strong> 由于问题2中进行了原来的sheet内容读取，所以在writer中也记录了原来的 sheet1 的内容，导致 writer 在写入的时候又重新将原来的第3、4行与实际的 第1、4行进行了合并。</p><p><strong>最终解决办法</strong>（根据上述的实例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">max_row = <span class="number">4</span></span><br><span class="line"><span class="comment"># 共删除了2、3两行，所以删除的行数为2</span></span><br><span class="line">delete_row_count = <span class="number">2</span></span><br><span class="line">change_sheet = writer.sheets[<span class="string">&quot;sheet1&quot;</span>]</span><br><span class="line"><span class="comment"># 删除原来重复合并的第 3、4行。</span></span><br><span class="line">change_sheet.delete_rows(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">writer.save()</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h4 id="问题4-在指定行插入一行数据"><a href="#问题4-在指定行插入一行数据" class="headerlink" title="问题4. 在指定行插入一行数据"></a>问题4. 在指定行插入一行数据</h4><p><strong>具体需求</strong>：可能需要通过在不同的行插入指定的数据，比如，sheet表中共10行，需要在第5行插入一条数据。</p><p><strong>解决办法</strong>：<a href="https://blog.csdn.net/weixin_30797027/article/details/97422624">参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以先将表格分开，添加行后再合并，原数据如下， 在第1行（猫之前）插入 羊，数量9， </span></span><br><span class="line"><span class="comment">#   动物  数量</span></span><br><span class="line"><span class="comment"># 0  狗   3</span></span><br><span class="line"><span class="comment"># 1  猫   4</span></span><br><span class="line"><span class="comment"># 2  兔   6</span></span><br><span class="line"></span><br><span class="line">具体实现代码如下</span><br><span class="line">df1 = df.loc[:<span class="number">0</span>]</span><br><span class="line">df2 = df.loc[<span class="number">1</span>:]</span><br><span class="line">print(<span class="string">&#x27;df1 is:\n&#x27;</span>, df1)</span><br><span class="line">print(<span class="string">&#x27;df2 is:\n&#x27;</span>, df2)</span><br><span class="line">df3 = pd.DataFrame(&#123;<span class="string">&#x27;动物&#x27;</span> : [<span class="string">&#x27;羊&#x27;</span>], <span class="string">&#x27;数量&#x27;</span> : [ <span class="number">9</span> ]&#125;)</span><br><span class="line">df = df1.append(df3, ignore_index = <span class="literal">True</span>).append(df2, ignore_index = <span class="literal">True</span>)</span><br><span class="line">print(df)</span><br><span class="line"><span class="comment"># df1 is:</span></span><br><span class="line"><span class="comment">#    动物  数量</span></span><br><span class="line"><span class="comment"># 0  狗   3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># df2 is:</span></span><br><span class="line"><span class="comment">#    动物  数量</span></span><br><span class="line"><span class="comment"># 1  猫   4</span></span><br><span class="line"><span class="comment"># 2  兔   6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   动物  数量</span></span><br><span class="line"><span class="comment"># 0  狗   3</span></span><br><span class="line"><span class="comment"># 1  羊   9</span></span><br><span class="line"><span class="comment"># 2  猫   4</span></span><br><span class="line"><span class="comment"># 3  兔   6</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        只有真的多面对几次现实中的需求，才能真的掌握一个库的使用。。。否则仅仅是最基础的 <code>Demo</code> 演练。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
            <tag> excel文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构化思维</title>
      <link href="posts/ec1ab3bc/"/>
      <url>posts/ec1ab3bc/</url>
      
        <content type="html"><![CDATA[<h3 id="结构化思维"><a href="#结构化思维" class="headerlink" title="结构化思维"></a>结构化思维</h3><p>​    什么是结构化思维呢？在本书第一章 第三节简单介绍了结构化思维， 书上所举的鲁班的例子，但个人感觉上鲁班的思维与结构化思维也不太相似，因此对于结构化思维更加迷惑。。。（可能比较愚钝╮(╯Д╰)╭ 😭）</p><p>​    我在这里个人重新理解下：<font color=red><strong>结构化思维 =&gt; 结构化的做事方式</strong></font>，具体见如下两个实例。</p><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>​    通过网上查找的一些资料，如下两个实例体现出了结构化思维：</p><h4 id="场景一：记忆词组"><a href="#场景一：记忆词组" class="headerlink" title="场景一：记忆词组"></a>场景一：记忆词组</h4><p>有下图的一串词组让你来记忆，</p><img src="https://i.loli.net/2021/03/03/FH2QGJbpRXNKcmx.png" alt="结构化思维-1.png" style="zoom: 33%;" /><p><strong>方式一：</strong></p><p><strong>上来就马上开始从前到后的记忆，那么这个记忆的效果可能不太理想，要是数量越多，那效果一般越差</strong>。（<em>此处排除过目不忘的大佬。。。</em>）这种做事方式一般比较低效。<font color=red>就如像我一样刚入职场时┑(￣。。￣)┍ ，在领导布置任务后一般都不思考就马上一股脑动手了，很可能最后结果就是效率低下并且结果与领导希望得到的结果背道而驰。</font></p><img src="https://i.loli.net/2021/03/03/rBAd5syXfHE3zWM.png" alt="结构化思维-2.png" style="zoom:40%;" /><p><strong>方式二：</strong></p><p>一般经过学校或者工作的锻炼，部分人就会掌握一些比较巧妙的做事方式，比如：在看到上面词组后，大家会先将所有词组进行一个分类归纳，然后再来记忆，虽然从数量上反而还新增了3个节点（蔬菜、水果、动物），但实际在记忆的效率上肯定比方式一要高效。</p><h4 id="场景二：新人入职任务"><a href="#场景二：新人入职任务" class="headerlink" title="场景二：新人入职任务"></a>场景二：新人入职任务</h4><p>很多人应该都经历过新人入职培训，培训上面可能会布置一些新人入职第一天的任务，那你还记得培训上有哪些任务吗？比如讲师就将如下图的内容展示给你们，你们估计也就是填鸭式将一天课程从头到尾听一遍，事情过了就完了。</p><img src="https://i.loli.net/2021/03/03/1Bd9gmSQIwzUhLb.png" alt="结构化思维-4.png" style="zoom:33%;" /><p>上图就是普通的做事方式，从头到尾来一遍。</p><p>这个时候依然参考结构化思维，更好的办法是先让大家了解这些任务之间的关系，然后再从更小的一个维度去让大家了解具体任务是什么，如下图：</p><img src="https://i.loli.net/2021/03/03/voQyqiHkV8aB4s6.png" alt="结构化思维-3.png" style="zoom:33%;" /><p>通过上述结构化后的任务，更加容易理解需要做的任务以及之间的关联性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    通过上述的两个实例后，我大概对结构化思维有了如下的一些见解：</p><p>​    ⚠️ 个人理解：每个实例中的后者就是<strong>结构化</strong>的做事方式，前者则为普通的思维（做事）方式，当然除了结构化的做事方式我理解还有更多其他成熟的做事方式，每种方式可能解决的场景又不太一样。</p><p>结构化思维可以解决如下类型的问题：</p><ul><li>遇到大问题脑子一团乱，不知如何下手；</li><li>说了一堆话，别人却表示听不懂；</li><li>想写文章，却毫无思路，无从下笔。</li></ul><p>结构化的做事方式具体步骤如下：</p><ol><li>先所有的信息/任务收集在一起；</li><li><strong>将所有信息/任务在已知的认知中，进行一个加工、归纳分组，形成多个更小的有条理和逻辑的分组，每个分组与上下之间都是有紧密联系的；</strong></li><li>如果下层分组过大，则可以将下层分组再次重复步骤2分成更小的分组。（<strong>存在一些极端场景：那就是所有的信息/任务没有任何关联</strong>）；</li><li>处理/记忆 每个分组。</li></ol><p>所以，结构化思维的核心就是： “<strong>拆分任务为多个有逻辑联系的小任务</strong>“。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思维的影响</title>
      <link href="posts/1f0a8761/"/>
      <url>posts/1f0a8761/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    很多时候，<strong>你可能不知道思维对你的生活到底造成了多大的影响</strong>。（就如同以前的我。。。此处可将<font color=red><strong>思维替换为看法</strong></font>）刚好最近看了一部电影一一<strong>华仔的《拆弹专家2》</strong>，里面很明显的展示出了不同的思维对主角（刘德华）带来了多大的影响。</p><p>​    <font color=gray>备注：可能很多地方也推荐《金字塔原理》，但我个人觉得如果是入门可以先看《结构化思维》，里面有更多的实例，让人理解起来更加浅显易懂。</font></p><a id="more"></a><h3 id="思维的意义"><a href="#思维的意义" class="headerlink" title="思维的意义"></a>思维的意义</h3><p>​    <font color=blue><strong>思维的意义，它是我们解读事实的起点，是产生行为的源头，是决定结果的根本。</strong></font></p><p>​    本书中刚开始就用了很多比较形象的案例阐述了思维在这些案例中的影响（意义），我个人理解思维在情绪上大致可以总结为：<code>积极的思维</code> 和 <code>消极的思维</code> 两种（有兴趣可以自行查阅书中的案例）。</p><p>​    <font color=blue>在不同的思维下，对于做事情的态度和行为也会天差地别。</font></p><p><strong>从以下几个大部分人可能都经历过的实际场景来看</strong>（平时工作中的年终考核或者季度考核）<font color=gray><em>我不以偏概全，但如果把我自己代入到这个场景后我可能会有如下看法。</em></font></p><ul><li><p><strong>你得知你自己的绩效较差或者你觉得自己能拿A，但是实际只给了你B。</strong></p><p>以前的我第一看法可能就是：<strong>搞什么鬼？， 这领导是给我穿小鞋吧，然后开始对于后面的工作有所松懈，更极端点就是离职</strong>。</p></li><li><p><strong>在上面的场景下，你得知自己只得到了B，小明得到了A（并且你觉的小明不如自己）。</strong></p><p>以前的我第一看法可能是：<strong>他做的和我一样呀，感觉都还不如我做的好，不会是靠拍马屁上去的吧？</strong></p></li></ul><p>先不管上面的猜测或者臆断的看法是否是正确的，但是可以发现产生我上述的看法的根本原因之一就是一一<code>消极思维</code>。以至于对后面的工作也可能越做越差，那后续的绩效也可想而知。</p><p>⚠️ 注意：<strong>道理可能大家都懂，但是真的碰到后不按照道理说的来做那还不如不懂这个道理！！！</strong></p><p>看了这章节后，我明白了思维的重要性，现在的我至少在再次面对上面的场景时候，我能从更深层次去思考问题，关于上述的实例场景，具体可以分为如下几个步骤：</p><ol><li><strong>先保持冷静以及抛开所有上述自己开始的猜想或者臆断</strong>（如果有这些主观因素影响的话，后面的步骤可能效果不佳）；</li><li><strong>仔细思考下这一年或者这一个季度自己做的东西是否真的如自己想象中那么好？</strong><ul><li>如果是自己真的做的不好，那么后面<strong>需要进行反省以及制定对应的改进计划</strong>，并且将自己的改进计划与领导进行核对确认，避免大方向错误。（这牵涉到<strong>向上管理</strong>，有兴趣的可以搜索这方面书籍）；</li><li>如果真的是自己做的好，那么总结出自己做的好的内容，与领导进行核对，确认是否两端有误会，<strong>而不是直接放手不干</strong>。</li></ul></li><li><strong>仔细思考下小明是不是真的不如自己？</strong><ul><li>如果小明真的是不如自己，那么总结出自己做的比小明好的地方，与领导进行核对，确认是否两端有误会，<strong>而不是背地里猜忌</strong>。</li><li>如果小明真的做的比自己好，那么就需要<strong>提取出小明的优势，然后制定自己的改进计划，并且将自己的改进计划与领导进行核对确认，避免误解了小明做的好的地方。</strong></li></ul></li></ol><p><font color=gray><em>但如果上述步骤做了后，发现确实不是自己的问题的时候，如何抉择很重要，但绝不能因为这件事而影响以后的工作或者生活。</em></font></p><h3 id="本节总结"><a href="#本节总结" class="headerlink" title="本节总结"></a>本节总结</h3><p>​    最后还是再强调一句：<code>如果过往事实不能改变，我们就只能改变思维，改变面对事实的态度和行为，让未来过得更好，避免发生悲剧。改变思维才是改变一切的源头。</code></p><p>​    发生任何事情， <code>积极思维</code> 一般都比 <code>消极思维</code> 要好，当然有时候一些悲伤的事情，适当的 <code>消极思维</code> 也是可以的，但一定要注意及时调整自己的思维，否则浪费的就是自己的时间。（可能大家有更好的见解💡，欢迎一起讨论实践）。 </p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周报的意义</title>
      <link href="posts/6241996/"/>
      <url>posts/6241996/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在从刚开始工作至工作5年后，都对周报的作用没有太大的了解，并且<strong>觉得是一件浪费时间又不讨好的事情</strong>。至今我才恍然大悟，庆幸为时不晚。</p><p>​    写周报，在公司里每周都会发生，大部分情况下，周围的人都对周报没有表现出太大的兴趣，有人则对它异常反感，甚至称它是<strong>“职场鸡肋”</strong>；还有人有这样的疑问：<strong>每周雷同的“僵尸”周报浪费时间和精力，真的有存在的必要吗？</strong>而且，我们辛辛苦苦写的周报老板到底看了没有？</p><p>或多或少，大家应该都可能有过如下类似的想法：</p><blockquote><p>  【小明】忙了一周了但是周报上不知道该写啥？老板看没看呢？</p><p>  【小明】我做了什么领导不知道吗?记录一周的工作内容有什么价值？随便写写算了~</p><p>  【小明】每周忙的都是一样的，这个能写出个什么花来？</p></blockquote><a id="more"></a><h3 id="周报是否-“鸡肋”？"><a href="#周报是否-“鸡肋”？" class="headerlink" title="周报是否 “鸡肋”？"></a>周报是否 “鸡肋”？</h3><p>答案肯定是否！</p><p>周报是<strong>职场通用基本功之一，员工通过每周周报的反复练习，不断提升自己复盘、思考和规划的基础能力。</strong></p><p>通过对过去一周工作的总结和沉淀，对未来一周的工作做计划和安排，回顾收获与不足，促成协同与互补。</p><p><strong>周报不仅是为了写给老板看的，更是写给自己看的，为自己创造一个“照镜子”的机会，沉淀经验，发现不足，快速改进。</strong></p><h3 id="周报撰写的方法"><a href="#周报撰写的方法" class="headerlink" title="周报撰写的方法"></a>周报撰写的方法</h3><table><thead><tr><th align="left">周报的三个部分</th><th align="left">撰写要点</th></tr></thead><tbody><tr><td align="left"><strong>第一部分，本周工作进展</strong></td><td align="left">也就是本周自己做了哪些事，分别取得了什么样的成果，围绕4个方面：</td></tr><tr><td align="left"></td><td align="left">①检查关键项目/任务的完成进度是否符合预期；</td></tr><tr><td align="left"></td><td align="left">②反馈各项目/任务的执行结果，如：完成情况/未达预期的原因/改进方案；</td></tr><tr><td align="left"></td><td align="left">③统计日程表中各任务的耗时情况是否正常，有没有效率特低或特高的情况，原因写到备注中；</td></tr><tr><td align="left"></td><td align="left">④回溯上一周面临的问题是否得到解决，解决方案是否有效，并简单总结经验教训。</td></tr><tr><td align="left"><strong>第二部分，下周任务安排</strong></td><td align="left">即对下周工作开展的简单思路，明确下周的工作重点，同时也能更加合理地管理时间，提升工作效率。可参考以下步骤进行规划：</td></tr><tr><td align="left"></td><td align="left">①列出下周的关键项目/任务；</td></tr><tr><td align="left"></td><td align="left">②明确各项项目/任务的产出指标；</td></tr><tr><td align="left"></td><td align="left">③细化任务，一方面要计划任务量，另一方面要计划时间分配，明确完成的时间节点。</td></tr><tr><td align="left"><strong>第三部分，本周工作感想</strong></td><td align="left">包括对工作的思考/疑问/不满/建议等等 。</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    总之，好的周报不仅让领导眼前一亮，并且能够让自己持续成长，不至于每当机遇来了却感叹没有掉到自己的手里。周期性的复盘自我才能一直持续高速成长。</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周报 </tag>
            
            <tag> 个人成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PYPI打包躺坑日记</title>
      <link href="posts/cea93702/"/>
      <url>posts/cea93702/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    作为一个测试，在使用 <code>PYTHON</code> 开发项目或者平台的时候会发现自己写的通用型功能可能每次都要拷贝到不同的项目中，如：我自己对数据库操作进行二次封装的 <code>sql_utils</code> ，可能由于一些扩展性需要或者修复一些缺陷就需要在每个项目里进行修改，操作起来相当繁琐并且可能出现失误。</p><p>​    大家肯定都用过 <code>pip</code> 来安装过依赖包，那么我们是否可以把自己写的公共模块通过 <code>PYPI</code> 来管理，这样通过 pip 就能安装了，是不是满满的成就感(╯▔▽▔)╯(╯▔▽▔)╯  ！！！心动不如行动！！</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>​    关于如何将自己的项目打包上传到 <code>PYPI</code> 进行统一管理的基本教程很多，这里就不重复搬运了，可以参考当时我找到的一篇<a href="https://blog.csdn.net/Coxhuang/article/details/88952367">教程</a>。主要记录下在这个过程中遇到的一些问题。</p><h3 id="基本命令行"><a href="#基本命令行" class="headerlink" title="基本命令行"></a>基本命令行</h3><p>在所有流程都执行完后，每次上传版本的命令行基本如下：</p><ol><li><p> 修改 <code>setup.py</code> 文件中的 <code>version</code> 字段版本值 ；</p></li><li><p> 执行 <code>python setup.py sdist build </code>，本地打包构建最新版本的 dist 包；</p></li><li><p> 执行 <code>twine upload --skip-existing dist/* </code> 上传新的版本包；</p></li><li><p> 使用方升级 <code>pip install --upgrade $&#123;package_name&#125; </code>。</p></li></ol><h3 id="过程中遇到的问题"><a href="#过程中遇到的问题" class="headerlink" title="过程中遇到的问题"></a>过程中遇到的问题</h3><h4 id="问题1：在执行上述命令行的第3步时候，上传一直报错-403"><a href="#问题1：在执行上述命令行的第3步时候，上传一直报错-403" class="headerlink" title="问题1：在执行上述命令行的第3步时候，上传一直报错 403"></a>问题1：在执行上述命令行的第3步时候，上传一直报错 403</h4><p>具体报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPError: 403 Client Error: Invalid or non-existent authentication information. <span class="keyword">for</span> url: https://upload.pypi.org/legacy/ </span><br></pre></td></tr></table></figure><p>查了下相关的问题， 如: <a href="https://github.com/pypa/twine/issues/424">官网ISSUES</a>，但看起来和我的不太一致，最终通过对比发现由于根目录下 <code>LICENSE</code> 文件中有一个用户名信息。</p><p><strong>解决方案：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admindeMacBook-Pro-2:date_utils xxx$ cat LICENSE</span><br><span class="line">Copyright (c) 2018 <span class="variable">$&#123;YOUR_USERNAME&#125;</span>  <span class="comment"># 这个地方应该填写自己的PYPI username</span></span><br></pre></td></tr></table></figure><h4 id="问题2：参考官网链接里面的操作，执行到如下命令时候报错"><a href="#问题2：参考官网链接里面的操作，执行到如下命令时候报错" class="headerlink" title="问题2：参考官网链接里面的操作，执行到如下命令时候报错"></a>问题2：参考官网链接里面的操作，执行到如下命令时候报错</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; python3 -m pip install --user --upgrade setuptools wheel </span><br><span class="line">error: invalid <span class="built_in">command</span> ‘bdist_wheel<span class="string">&#x27; </span></span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong><a href="https://stackoverflow.com/questions/34819221/why-is-python-setup-py-saying-invalid-command-bdist-wheel-on-travis-ci">参考链接</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install wheel </span><br></pre></td></tr></table></figure><h4 id="问题3：-更新代码并修改了version后执行步骤3，仍然报错"><a href="#问题3：-更新代码并修改了version后执行步骤3，仍然报错" class="headerlink" title="问题3： 更新代码并修改了version后执行步骤3，仍然报错"></a>问题3： 更新代码并修改了version后执行步骤3，仍然报错</h4><p>具体报错信息为：<code>400 Client Error: File already exists </code></p><p><strong>解决方案：</strong> <a href="https://stackoverflow.com/questions/52016336/how-to-upload-new-versions-of-project-to-pypi-with-twine">参考链接</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twine upload --skip-existing dist/* </span><br></pre></td></tr></table></figure><h4 id="问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。"><a href="#问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。" class="headerlink" title="问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。"></a>问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。</h4><p><strong>原因：</strong>如果存在了依赖非系统自带的库的时候，比如 <code>requests</code> ，默认情况下打包上传后，下载的库在运行时候会报 <code>request</code> 不存在，没有自动安装相应的依赖。</p><p><strong>解决办法：</strong></p><p>​    在 <code>setup.py</code> 文件中添加配置，具体代码如下：<a href="https://note.qidong.name/2018/01/python-setup-requires/">参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setup(</span><br><span class="line">...</span><br><span class="line">    install_requires=[</span><br><span class="line">        <span class="string">&quot;requests&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="问题5：在Mac上打包的公共库，-但在windows上安装一直报错。"><a href="#问题5：在Mac上打包的公共库，-但在windows上安装一直报错。" class="headerlink" title="问题5：在Mac上打包的公共库， 但在windows上安装一直报错。"></a>问题5：在Mac上打包的公共库， 但在windows上安装一直报错。</h4><p>具体报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: <span class="string">&#x27;gbk&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xbf in postion 2: illegal multibyte sequence</span></span><br></pre></td></tr></table></figure><p>原因是：是因为在 <code>setup.py</code> 文件时候，执行了 <code>open(README.rst)</code> 此处编码有问题。</p><p>解决办法：在 <code>setup.py</code> 文件中的代码进行如下修改。（但不一定是这个文件。具体要看是否有哪个代码使用了open()方法打开了中文字体的文件）<a href="https://blog.csdn.net/lqzdreamer/article/details/76549256">参考链接</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(README.rst) ==&gt; open(README.rst, encoding=&#x27;gb18030&#x27;, errors=&#x27;ignore&#x27;)</span><br></pre></td></tr></table></figure><h4 id="问题6-上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。"><a href="#问题6-上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。" class="headerlink" title="问题6: 上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。"></a>问题6: 上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。</h4><p>原因：因为本地配置了pip的安装源为<a href="http://mirrors.aliyun.com/pypi/simple/">阿里云的链接</a>，<strong>阿里云的pip源不是实时去同步PYPI上的包</strong>。</p><p>解决办法： 把本地配置的 <code>pip.conf</code>  里面的用户自定义配置的内容注释掉即可。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://packaging.python.org/tutorials/packaging-projects/#uploading-your-project-to-pypi">Packaging Python Projects</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PYPI </tag>
            
            <tag> Python公共库管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识思维</title>
      <link href="posts/50e7aed3/"/>
      <url>posts/50e7aed3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是思维"><a href="#什么是思维" class="headerlink" title="什么是思维"></a>什么是思维</h3><p>书本上的解释：</p><blockquote><p> 思维是大脑对接收到的信息进行加工处理，再反映在现实生活中的一种过程。</p></blockquote><p><strong>信息：</strong>泛指人类社会传播的一切内容。 </p><p><strong>加工处理：</strong>如：记忆、理解、筛选、推理、思考、想象等。 </p><p><strong>反映在现实生活中：</strong>指的是产生的动作、想法或者行动，这种动作可能是大脑内部的运转，也可能是通过说、写、画、行动等方式表达出来的肢体动作。 </p><p>书上的概念大多数时候都比较抽象 ㄟ(▔︹▔ㄟ) ，此处我为了方便记忆会用当前我已知的知识替换一部分名词，如：<font color=red><strong>思维 =&gt; 看法</strong> </font>。（思维会产生一个或多个看法，<a href="https://wiki.mbalib.com/wiki/%E6%80%9D%E7%BB%B4">MBA百科</a>上解释 思维 =&gt; 思考）</p><a id="more"></a><p>⚠️ <strong>个人理解</strong>： 思维（<strong>看法</strong>）不会凭空产生，当你知道某个信息A后，通过自己已有的认知对A形成关于该信息的看法（可能是多个）。</p><p>比如：</p><ul><li>你去了重来没去过的饭店A去吃饭，挺好吃的，这个时候就形成了饭店A菜还不错的思维（看法a）。</li><li>你第二次再次去了饭店A吃饭（由于上述的看法a），但是此次吃同样的菜很难吃，这个时候你又形成了饭店A菜怎么这么难吃的思维（看法b）</li><li>再准备出去吃饭的时候，你可能不会再考虑饭店A（由于看法b导致）。</li></ul><p>所以通俗易懂的来说就是：**”思维” 就是  “一个或者多个关于某个信息的看法”**（个人觉得这样理解挺方便😂）。</p><h3 id="思维形成的过程"><a href="#思维形成的过程" class="headerlink" title="思维形成的过程"></a>思维形成的过程</h3><p>​    从上面的实例来看，<font color=blue><strong>思维（看法）会在不断接受到信息后不断的改变。</strong></font>再来看一个具体的实例：</p><p>​    当我们去一个新公司上班。一进门，人事专员就面带微笑地迎接，给我们办理入职相关手续，这时候我们有可能会想：<strong>哇，新公司真不错，同事这么和蔼可亲、服务周到，看起来氛围也很好。</strong></p><p>​    在这一系列的思考后，我们是不是会放下内心的担忧或者矜持，对人事专员笑容以对呢？</p><p>​    接着人事专员让我们稍等，她去复印身份证，<strong>结果一等就等了20分钟。这时候，我们是不是又会情绪不安</strong>，心想：<strong>怎么回事，复印个身份证都能这么久，这个人做事靠谱吗？是不是半路被拉去做其他事，把我忘了？还是我入职的事情，有了什么变化？</strong></p><p>​    在这一系列的思考后，<strong>我们可能会来回走动、坐立不安，甚至开始四处找人呢？</strong></p><p><font color=red>此时再次设想存在如下两个场景：</font></p><p><strong>场景一：</strong>当我们找到人事专员，发现她在跟其他人聊天，这个时候我们看到她脸上的笑容，就不再认为她和蔼可亲了。</p><p>此时你是不是会觉得：<strong>这个人怎么回事啊？把我晾在一边，我这边的手续还没办完，又在跟别人说说笑笑，真不靠谱！</strong></p><p><strong>场景二：</strong>我们发现她在帮我们复印文件时弄了一手油墨，并且不断和我们道歉说复印机突然坏了，维修师傅明天才能到，为了不影响我们入职，她只能自己动手尝试修理，一不小心忘了时间……发现是这样的情况，我们会怎样思考呢？</p><p>此时你是不是会觉得：<strong>“原来是这样啊，我误会她了，人事专员还能修复印机真是厉害，公司员工的素质好高啊，真是个不错的公司！”</strong></p><p>所以，思维不仅是单向运动，而且还是<strong>动态循环</strong>的过程。我们会<font color=blue><strong>因为事情呈现的变化和结果，反过来影响思维，又持续不断地影响接下来的态度、行为，以及事情的结果。</strong></font></p><img src="https://i.loli.net/2021/02/20/qfkyZVjYCM8FRcx.png" alt="逻辑思维-1.png" style="zoom:35%;" /><p>在工作中也是这样。</p><p><strong>如果你存在上司对你有意见的看法， 那你的工作肯定做不好。</strong>因为任何不好的事情发生后，你可能都会先怪罪到你上司身上，并且消极怠工、破罐子破摔、拒不改错或者与上司起冲突。最终结果可能就是离职。最后我们还会认为：<font color=red><strong>果然，上司就是不待见自己！</strong></font></p><p><strong>如果你存在上司有意栽培你的看法时，那你的工作可能会越做越好。</strong> 上司指出我们方案中的错误，我们就会认为上司精益求精、借此指点我们，继而我们更虚心好学、热情请教、刨根问底、精益求精，结果肯定是自己逐渐进步和优秀。最后，我们会认为：<font color=blue><strong>上司果然是想培养自己！</strong></font></p><h4 id="思维方式"><a href="#思维方式" class="headerlink" title="思维方式"></a>思维方式</h4><blockquote><p>就这样在上图描述那样，一次又一次的思维循环里，思维过程重复多次，就会形成固定的思维方式，从而形成思维惯性，遇见相同或类似的信息时，按照同样的思维方式思考，就能得出同样的认知。 </p></blockquote><p>⚠️ <strong>个人理解</strong>：在上述过程中讲到了思维方式，我个人理解可以认为： <font color=red><strong>思维方式 =&gt; 做事方式</strong></font>。（后面如有遗漏可自行替换为做事方式）</p><p>比如：从小我们经过很多事情（在不特意训练的情况下），形成了一套属于自己的做事方式（大部分这个做事方法是不成熟的，就比如我刚工作的做事方式(╯▔︹▔)╯ ）。</p><ul><li>刚开始工作时，每当遇到问题时，夸张一点的做事方式：<strong>上来就直接问别人，如果解决了就完事了，没解决那就算了！！</strong>，在这种做事方式下，直接影响了个人的成长。所以急需改正。</li><li>在工作3～5年后，通过工作经验的积累，每当遇到问题，我的思维（<strong>做事</strong>）方式是：<strong>先解决这个问题，并且记录问题以及具体原因，通过5Why分析法追根溯源</strong>，这种思维<strong>（做事）</strong>方式让我在后续遇到类似的问题也能从容应对，让我的个人能力也突飞猛进。</li></ul><p>所以，如果我一直维持刚开始工作时候的固定的思维（<strong>做事</strong>）方式，那结果可想而知。</p><h4 id="固定思维方式的优点"><a href="#固定思维方式的优点" class="headerlink" title="固定思维方式的优点"></a>固定思维方式的优点</h4><p>​    当我们形成一种固定的思维（<strong>做事</strong>）方式后，常常会以这种方式去处理大部分的信息，优势在于有效率。也就是说，我们能把这种思维（<strong>做事</strong>）方式本身带来的红利发挥最大化。</p><ul><li>做过销售的人，往往更在乎结果。因为他们在做销售的过程中，业绩、收入取决于销售结果，所以有销售经验的人做其他工作往往更加看重结果是否达成。</li><li>做过编辑的人，看到文章，即使无须他们审核，也会快速找出其中格式错误、错别字、标点符号错误等问题。</li><li>做过行政工作的人，做事往往也会更加在乎细节。</li></ul><p>这些工作方式的差异，都是思维上重复多次后，形成固定思维（<strong>做事</strong>）方式的结果。</p><h4 id="固定思维方式的缺点"><a href="#固定思维方式的缺点" class="headerlink" title="固定思维方式的缺点"></a>固定思维方式的缺点</h4><p>​    容易忽略其他特质，比如：</p><ul><li>在乎结果的人容易忽视过程，甚至可能为短期结果而牺牲长远利益；</li><li>快速找到文章错误的人，往往不容易克服这些错误而去欣赏文章本身的意境；</li><li>在乎细节的人就不容易跳出局部看整体等。</li></ul><p>一个比较常见的实例，某些销售员由于工作原因，接触的人多了，就对人产生一些惯性思维，比如穿的破破烂烂的就没兴趣接待。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    如果掌握足够优秀或者成熟的思维（<strong>做事</strong>）方式，我们必然就会成为睿智、思考全面、轻松做正确选择的人。如果思维（<strong>做事</strong>）方式杂乱无章，没有形成结构，我们看待事情必然就会片面、局限、逻辑混乱，从而在失败里循环。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue + Element el-upload实现上传文件</title>
      <link href="posts/bb375789/"/>
      <url>posts/bb375789/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近在开发测试用例管理平台，其中需要实现上传用例的 <strong>Excel</strong> 文件。</p><h3 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h3><p>​    通过  <code>Element-ui</code> 很轻松就找到了对应的组件（<a href="https://element.eleme.cn/#/zh-CN/component/upload#tuo-zhuai-shang-chuan">Element-ui具体代码</a>），通过查找资料以及填坑，最终实现的效果如下：</p><img src="https://i.loli.net/2021/02/26/CZyFN5EdbTUOXgq.png" alt="finally-ui-import.png" style="zoom:40%;" /><a id="more"></a><p>具体核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-upload</span><br><span class="line">           class&#x3D;&quot;upload-demo&quot;</span><br><span class="line">           drag</span><br><span class="line">           :action&#x3D;&quot;doUpload&quot;</span><br><span class="line">           :data&#x3D;&quot;specialData&quot;</span><br><span class="line">           :on-change&#x3D;&quot;handleChange&quot;</span><br><span class="line">           :file-list&#x3D;&quot;fileList&quot;</span><br><span class="line">           :on-error&#x3D;&quot;handleError&quot;</span><br><span class="line">           :on-success&#x3D;&quot;handleSuccess&quot;</span><br><span class="line">           accept&#x3D;&quot;.xlsx, .xls&quot;</span><br><span class="line">           :before-upload&#x3D;&quot;onBeforeUpload&quot;</span><br><span class="line">           &gt;</span><br><span class="line">  &lt;i class&#x3D;&quot;el-icon-upload&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;&#x2F;em&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;el-upload__tip&quot; slot&#x3D;&quot;tip&quot; style&#x3D;&quot;color&#x3D;#4073ff&quot;&gt;只能上传excel文件，且不超过10MB&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;el-upload&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中对应的一些差异的js方法代码如下</span></span><br><span class="line"><span class="function"><span class="title">handleChange</span>(<span class="params">file, fileList</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.fileList = fileList;</span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此处使用 JSON.parse(err.message) 代替 JSON.stringify(err) </span></span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.parse(err.message)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg.err_msg)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>虽然 <code>Element-ui</code> 上的组件很丰富， 但是对于<strong>一个测试</strong>来说，有时候还是有些难以理解😭😭。</p><h4 id="问题1：action参数的使用问题。"><a href="#问题1：action参数的使用问题。" class="headerlink" title="问题1：action参数的使用问题。"></a>问题1：action参数的使用问题。</h4><p>在源码中 <code>action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;</code> 的使用，以及下面参数<code>action</code> 解释为：<strong>必选参数，上传的地址</strong>。这个地方就误以为只能使用 <code>URL</code> 格式，实际也可以 <code>:action</code> 直接对应后端的上传文件的API接口即可 。</p><p>解决方案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将源码中的 action=&quot;https://jsonplaceholder.typicode.com/posts/&quot; ==&gt; :action=&quot;doUpload&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">...</span><br><span class="line">  data() </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      doUpload:<span class="string">&#x27;/api/upload_excel_file&#x27;</span>,<span class="comment">// 对应后端的上传文件接口</span></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题2：需要传输指定的参数给后端接口。"><a href="#问题2：需要传输指定的参数给后端接口。" class="headerlink" title="问题2：需要传输指定的参数给后端接口。"></a>问题2：需要传输指定的参数给后端接口。</h4><p>解决方案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue 中上传组件新增 :data参数为指定需要传入给后端接口的data</span></span><br><span class="line">&lt;el-upload</span><br><span class="line">...</span><br><span class="line">  :action=<span class="string">&quot;doUpload&quot;</span></span><br><span class="line">  :data=<span class="string">&quot;specialData&quot;</span></span><br><span class="line">...</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">...</span><br><span class="line">  data() </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      doUpload:<span class="string">&#x27;/api/upload_excel_file&#x27;</span>,<span class="comment">// 对应后端的上传文件接口</span></span><br><span class="line">      specialData: &#123;</span><br><span class="line">        name: <span class="string">&quot;111&quot;</span>,<span class="comment">// 后端接口就能接收到该变量</span></span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体效果如下：</p><img src="https://i.loli.net/2021/02/26/7Jj2FYUrWc8n4L3.png" alt="upload-data.png" style="zoom:80%;" /><h4 id="问题3-针对于上传失败后，解析返回的错误信息不全。"><a href="#问题3-针对于上传失败后，解析返回的错误信息不全。" class="headerlink" title="问题3: 针对于上传失败后，解析返回的错误信息不全。"></a>问题3: 针对于上传失败后，解析返回的错误信息不全。</h4><p>具体现象如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.stringify(err)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">&#123;<span class="string">&quot;status&quot;</span>:<span class="number">400</span>,<span class="string">&quot;method&quot;</span>:<span class="string">&quot;post&quot;</span>,<span class="string">&quot;url&quot;</span>:<span class="string">&quot;/api/upload_excel_file&quot;</span>&#125; </span><br><span class="line"><span class="comment">// 实际err的信息应该如下（需要解析到里面的err_msg）：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code> JSON.stringify(err)</code> 去解析err 发现打印的数据没有想要的错误信息， 通过控制台调试的时候发现完整的err应该为如下格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>: &#123;</span><br><span class="line">  method: <span class="string">&quot;post&quot;</span></span><br><span class="line">  status: <span class="number">400</span></span><br><span class="line">  url: <span class="string">&quot;/api/upload_excel_file&quot;</span></span><br><span class="line">  message: <span class="string">&quot;&#123;↵  &quot;</span>code<span class="string">&quot;: 400, ↵  &quot;</span>data<span class="string">&quot;: &#123;&#125;, ↵  &quot;</span>err_msg<span class="string">&quot;: &quot;</span>\u5df2\u5b58\u5728\u76f8\u540c\u540d\u79f0\u7684\u6587\u4ef6<span class="string">&quot;↵&#125;↵&quot;</span></span><br><span class="line">  stack: <span class="string">&quot;Error: &#123;↵  &quot;</span>code<span class="string">&quot;: 400, ↵  &quot;</span>data<span class="string">&quot;: &#123;&#125;, </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>所以是 <code>JSON.stringify</code> 在转义的过程中少了一些字段（具体原因：<strong>JSON.stringify()只能序列化对象的可枚举的自有属性</strong>），此处解决办法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此处使用 JSON.parse(err.message) 代替 JSON.stringify(err) </span></span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.parse(err.message)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg.err_msg)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，基本已经满足了最初预定的需求。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://segmentfault.com/q/1010000019086550">Element upload组件如何获取它的on-error事件的报错信息</a><br><a href="https://segmentfault.com/a/1190000013796215">Element el-upload 上传组件详解</a><br><a href="https://element.eleme.cn/#/zh-CN/component/upload#tuo-zhuai-shang-chuan">Element 官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Element UI </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探Sqlmap（一）</title>
      <link href="posts/e96496d4/"/>
      <url>posts/e96496d4/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    基于<a href="https://beanskingdom.top/posts/6ad48805/#more">业务存在 Sql 注入危险</a> 的现状，开始研究相关工具的使用一一 Sqlmap。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    <code>Sqlmap</code> 是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。（<a href="https://github.com/sqlmapproject/sqlmap">Sqlmap源码</a>）</p><p>​    本文会简单描述下 <code>Sqlmap</code> 的使用方式，然后详细介绍下 <code>SqlmapAPI</code> 的大致原理。</p><a id="more"></a><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="一、-命令行方式"><a href="#一、-命令行方式" class="headerlink" title="一、 命令行方式"></a>一、 命令行方式</h4><p><strong>优点：</strong> 上手快，命令行输入/输出容易理解；问题定位方便。</p><p>​    对于<strong>新手初次使用该工具</strong>时候，建议<strong>使用命令行模式先将整个流程跑通</strong>（如参考：<a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a>，很详细的介绍了从Sql注入到破解数据库信息的整个过程），想了解更多命令行参数可以阅读源码目录 <code>lib/parse/cmdline</code> 文件获取更多参数的含义。</p><p><strong>大致的命令行格式如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对参数是直接拼接在链接后方的命令行</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;http://ip:port/user/login?username=foo&amp;passwd=bar&quot;</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;http://ip:port/user/login?username=foo&amp;passwd=bar&quot;</span> --batch --dbs</span><br></pre></td></tr></table></figure><p><strong>我常用的命令行参数有：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--dbms=<span class="string">&#x27;MySQL&#x27;</span><span class="comment"># 指定后台扫描数据库类型为 MYSQL</span></span><br><span class="line">--risk 3<span class="comment"># 执行中的风险系数，1~3，级别越高，可能会使用&#x27;or&#x27;等等语句，默认1</span></span><br><span class="line">--level 3<span class="comment"># 级别越高，发送的请求(payload)越多，默认1</span></span><br><span class="line">--random-agent<span class="comment"># Use randomly selected HTTP User-Agent header value</span></span><br><span class="line">--keep-alive<span class="comment"># Use persistent HTTP(s) connections</span></span><br><span class="line">--batch<span class="comment"># 自动选择默认的值，否则需要手动选择</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>注意：</strong> <strong>针对实践中的一些特定的场景，如加 <code>headers</code> 或对 <code>POST</code> 方法注入的命令行如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果需要自定义header，使用headers参数，注意：多个header之间用\n间隔</span></span><br><span class="line"><span class="comment"># 具体的data参数需要进行URL编码。</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;https://xxx/test/user&quot;</span> --headers=<span class="string">&quot;xxx: xxx\nxbbb: 4\nxcc: 111\nx-token: xxx&quot;</span> --data=<span class="string">&#x27;data=%7B%22id%22%3A%22111%22%2C%22new%22%3A%229%22%2C%20%22old%22%3A%221%22%7D&#x27;</span> --dbms=<span class="string">&#x27;MySQL &#x27;</span> --random-agent --batch </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如上请求的POST参数具体格式如下</span></span><br><span class="line">data=&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;111&quot;</span>,<span class="string">&quot;new&quot;</span>:<span class="string">&quot;9&quot;</span>, <span class="string">&quot;old&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line"><span class="comment"># 在注入的时候，要对data中所有的字段进行注入，则需要将上述data修改如下，在每个字段的value值后新增一个*号：</span></span><br><span class="line">data=&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;111*&quot;</span>,<span class="string">&quot;new&quot;</span>:<span class="string">&quot;9*&quot;</span>, <span class="string">&quot;old&quot;</span>:<span class="string">&quot;1*&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意</strong>⚠️： 对于data里面需要注入的参数带 * 号时候，转义后仍然需要是 * 号，不能直接转义，否则就导致最终仅仅是对 data最外层这个data进行了注入！！！</font></p><p><strong>缺点：</strong></p><ul><li>由于Sqlmap每检测一个站点都需要开启一个新的命令行窗口或者结束掉上一个检测任务。虽然 -m 参数可以批量扫描URL，但是模式也是一个结束扫描后才开始另一个扫描任务，执行效率较慢；</li><li>对于想获取历史任务的日志和结果操作不友好。</li></ul><p><strong>实际使用场景：我大多数时候是用该方式进行参数调试。</strong></p><h4 id="二、API请求"><a href="#二、API请求" class="headerlink" title="二、API请求"></a>二、API请求</h4><p><strong>优点：</strong> Sqlmap封装了较多的API接口，更方便操作扫描任务。</p><ul><li><p>通过 API接口下发扫描任务，无需每次执行扫描新开一个命令行窗口，通过Http接口即可执行扫描任务；</p></li><li><p>可通过 API接口获取历史执行结果以及日志进行聚合和分析。</p></li></ul><p>具体如何使用 SqlmapAPI不具体描述，可参考：<a href="https://paper.seebug.org/940/">细说Sqlmap</a>，比较详细的说明了 SqlmapAPI的使用。</p><h3 id="SqlmapAPI-原理"><a href="#SqlmapAPI-原理" class="headerlink" title="SqlmapAPI 原理"></a>SqlmapAPI 原理</h3><h4 id="SqlmapAPI-服务器启动"><a href="#SqlmapAPI-服务器启动" class="headerlink" title="SqlmapAPI 服务器启动"></a>SqlmapAPI 服务器启动</h4><p>SqlmapAPI的服务器启动逻辑还是很简单，下图为整个 <code>sqlmapapi.py</code> 脚本服务器启动流程。</p><img src="https://i.loli.net/2021/02/16/WJVaUkBYhstGRHv.png" alt="sqlmapAPI.png" style="zoom:45%;" /><h4 id="api-py"><a href="#api-py" class="headerlink" title="api.py"></a>api.py</h4><p>SqlmapAPI使用的是 <a href="https://docs.python.org/zh-cn/3/library/sqlite3.html">sqlite3</a> 数据库。在 <code>server()</code> 方法中主要是进行本地数据库的路径创建、连接以及创建必须的表结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个随机地址, 用于存放数据库文件</span></span><br><span class="line">_, Database.filepath = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.IPC, text=<span class="literal">False</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize IPC database</span></span><br><span class="line">DataStore.current_db = Database()</span><br><span class="line">DataStore.current_db.connect()</span><br><span class="line">DataStore.current_db.init()</span><br></pre></td></tr></table></figure><p>使用API模式进行sql注入测试时候，主要使用如下几个API接口（具体如何调用可参考：<a href="https://paper.seebug.org/940/">细说Sqlmap</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@get(<span class="string">&quot;/task/new&quot;</span>)<span class="comment"># 创建一个新的扫描任务</span></span><br><span class="line">@post(<span class="string">&quot;/scan/&lt;taskid&gt;/start&quot;</span>)<span class="comment"># 指定任务进行扫描</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/status&quot;</span>)<span class="comment"># 查看指定任务的状态</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/data&quot;</span>)<span class="comment"># 查看指定任务的执行结果</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/log&quot;</span>)<span class="comment"># 查看指定任务的扫描执行日志</span></span><br></pre></td></tr></table></figure><h4 id="Task执行原理"><a href="#Task执行原理" class="headerlink" title="Task执行原理"></a>Task执行原理</h4><p>此处仅介绍 <code>/scan/&lt;taskid&gt;/start</code>，主要通过 <code>DataStore.tasks[taskid].engine_start()</code> 进行执行指定任务执行扫描。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">engine_start</span>(<span class="params">self</span>):</span></span><br><span class="line">  handle, configFile = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.CONFIG, text=<span class="literal">True</span>)</span><br><span class="line">  os.close(handle)</span><br><span class="line">  saveConfig(self.options, configFile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&quot;sqlmap.py&quot;</span>):</span><br><span class="line">  self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">elif</span> os.path.exists(os.path.join(os.getcwd(), <span class="string">&quot;sqlmap.py&quot;</span>)):</span><br><span class="line">    self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, cwd=os.getcwd(), close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">elif</span> os.path.exists(os.path.join(os.path.abspath(os.path.dirname(sys.argv[<span class="number">0</span>])), <span class="string">&quot;sqlmap.py&quot;</span>)):</span><br><span class="line">    self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, cwd=os.path.join(os.path.abspath(os.path.dirname(sys.argv[<span class="number">0</span>]))), close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    self.process = Popen([<span class="string">&quot;sqlmap&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, close_fds=<span class="keyword">not</span> IS_WIN)</span><br></pre></td></tr></table></figure><p>从上面的代码来看，最终还是使用的 <code>sqlmap.py</code> 脚本来进行的任务扫描，也可以通过打印出源代码中 <code>configFile</code>  的路径，来查看每次任务的配置参数是什么。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，SqlmapAPI就介绍到此，可以看出来该脚本主要是启动一个本地数据库以及Web后台，来记录所有的任务相关信息。下一次将再继续分析 <code>sqlmap.py</code> 脚本中是如何进行sql注入的测试。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://octobug.gitbooks.io/sqlmap-wiki-zhcn/content/">sqlmap中文介绍</a><br><a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a><br><a href="https://github.com/sqlmapproject/sqlmap">Sqlmap源码</a><br><a href="https://www.freebuf.com/sectool/164608.html">Sqlmap超详细攻略</a><br><a href="https://paper.seebug.org/940/">细说Sqlmap</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全测试 </tag>
            
            <tag> Sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探安全测试</title>
      <link href="posts/6ad48805/"/>
      <url>posts/6ad48805/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    某天，A：你们Web后台存在安全问题，部分接口<font color=red><strong>存在SQL注入的问题</strong></font>。</p><p>​    B：…</p><p>​    B To C：接口存在SQL注入的问题，你去调研下Sqlmap。</p><p>​    C：… emm (⊙＿⊙)。</p><a id="more"></a><h3 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h3><ul><li>什么是安全问题？应用软件中又存在哪些方面的安全问题？</li><li>什么是安全测试？</li><li>常见的安全性缺陷和漏洞有哪些？</li><li>Sql注入，用于进行Sql注入的工具有哪些？</li></ul><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>​    现实生活中安全相关话题无处不在，如消防安全、卫生安全、人身安全等等，如：<strong>小区楼道中贴着一些禁止电动车在楼道中充电</strong>，因为这会存在着引发火灾的安全问题（严重的情况甚至影响到生命危险）。</p><p>​    那么应用软件中也存在安全问题，情况严重时候不仅会造成经济损失，还可能由于大量用户信息被泄漏而导致整个公司崩溃。常见的几种安全问题如下：</p><ul><li><strong>信息安全问题</strong>：如淘宝、京东中，用户一般都绑定了身份证、银行卡、手机号、家庭住址等个人隐私信息，如果这些信息泄漏给一些不法分子后，就会对一些指定用户进行电信诈骗；</li><li><strong>财产安全问题</strong>：如很多钓鱼网站，都是通过短信、微信、网页链接等方式模拟正规网页，骗取用户在上面进行操作，导致银行卡密码泄漏而造成财产损失；</li><li><strong>权限安全问题</strong>：由于权限控制不得当，非公司内部管理员也能通过某些方式对公司的私密信息进行操作，最终导致整个公司隐私泄漏或者信息错误。</li></ul><h4 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h4><p>​    个人理解安全测试应该是 <strong>一个识别应用程序潜在的安全性缺陷的过程</strong>，如：保证用户对数据或业务功能的访问，在预期的安全性情况下，操作者只能<strong>访问应用程序的特定功能、有限的数据</strong>等。</p><p>其它参考：<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95">百度–安全测试</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95">维基–渗透测试</a></p><p>​    常用的安全测试手段有：</p><ul><li>静态的代码安全测试；</li><li>动态的渗透测试；</li><li>程序数据扫描。</li></ul><h4 id="常见的软件安全性缺陷和漏洞有哪些"><a href="#常见的软件安全性缺陷和漏洞有哪些" class="headerlink" title="常见的软件安全性缺陷和漏洞有哪些"></a>常见的软件安全性缺陷和漏洞有哪些</h4><p>由于篇幅有限，暂仅对此次存在 <code>Sql注入</code> 的安全问题详细介绍。</p><ul><li><a href="https://baike.baidu.com/item/SQL%E6%B3%A8%E5%85%A5">SQL注入</a></li><li><a href="https://www.jianshu.com/p/9fc25e661ab9">XSS注入</a></li><li><a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E">远程代码执行</a></li><li><a href="https://www.netinbag.com/cn/internet/what-is-parameter-tampering.html">参数篡改</a></li><li><a href="https://www.anquanke.com/post/id/217290">弱口令</a></li><li>…</li></ul><h4 id="Sql注入"><a href="#Sql注入" class="headerlink" title="Sql注入"></a>Sql注入</h4><p>​    在没有深入之前，对于Sql注入的理解是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，然后获得该接口的返回或者绕过授权。对于存在Sql注入的威胁也仅仅是绕过登录或者获取某些普通数据。</p><p>​    然而通过资料的查询以及自身的Sqlmap实践后，才感觉一阵后怕，比较常见的威胁如下：</p><ul><li>猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。（<strong>如果存在Sql注入时，在没有特殊的安全措施下，可以理解数据库里面的所有信息都可以被获取到</strong>）</li><li>绕过认证，列如绕过验证登录网站后台。</li></ul><p>​    具体如何使用Sqlmap达到上面的效果这里就不细说了，网上这块教程比较多（如：<a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a>）。</p><h4 id="Sql注入的步骤"><a href="#Sql注入的步骤" class="headerlink" title="Sql注入的步骤"></a>Sql注入的步骤</h4><ol><li><p><strong>SQL注入点探测</strong>。</p><p>探测SQL注入点是关键的一步，通过适当的分析应用程序，可以判断什么地方存在SQL注入点。通常只要带有输入提交的动态网页，并且动态网页访问数据库，就可能存在SQL注入漏洞。如果程序员信息安全意识不强，<font color=red><strong>采用动态构造SQL语句访问数据库，并且对用户的输入未进行有效性验证，则存在SQL注入漏洞的可能性很大。</strong></font>一般通过页面的报错信息来确定是否存在SQL注入漏洞。</p></li><li><p><strong>收集后台数据库信息。</strong></p><p>不同数据库的注入方法、函数都不尽相同，因此在注入之前，我们先要判断一下数据库的类型。判断数据库类型的方法很多，可以输入特殊字符，如单引号，让程序返回错误信息，我们根据错误信息提示进行判断；还可以使用特定函数来判断，比如输入“1 and version（）&gt;0”，程序返回正常，说明 <code>version()</code> 函数被数据库识别并执行，而 <code>version()</code> 函数是 <code>MySQL</code> 特有的函数，因此可以推断后台数据库为MySQL。</p></li><li><p><strong>猜解用户名和密码。</strong></p><p>数据库中的表和字段命名一般都是有规律的。通过构造特殊SQL语句在数据库中依次猜解出表名、字段名、字段数、用户名和密码。 </p></li><li><p><strong>查找Web后台管理入口。</strong></p><p>WEB后台管理通常不对普通用户开放，要找到后台管理的登录网址，可以利用Web目录扫描工具（如：wwwscan、AWVS）快速搜索到可能的登录地址，然后逐一尝试，便可以找到后台管理平台的登录网址。</p></li><li><p><strong>入侵和破坏。</strong></p><p>一般后台管理具有较高权限和较多的功能，使用前面已破译的用户名、密码成功登录后台管理平台后，就可以任意进行破坏，比如上传<a href="https://baike.baidu.com/item/%E6%9C%A8%E9%A9%AC/530">木马</a>、篡改网页、修改和窃取信息等，还可以进一步提权，入侵Web服务器和数据库服务器。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    概念相关就介绍到此，下一篇将会具体介绍如何通过工具来进行相关Sql注入的测试一一 <code>Sqlmap</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> 安全测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全测试 </tag>
            
            <tag> Sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019~2020年回顾</title>
      <link href="posts/6a64e1dd/"/>
      <url>posts/6a64e1dd/</url>
      
        <content type="html"><![CDATA[<h3 id="感慨（吐槽自己…）"><a href="#感慨（吐槽自己…）" class="headerlink" title="感慨（吐槽自己…）"></a>感慨（吐槽自己…）</h3><p>​    瞬间就到了2021年了。。。依稀还记得2019年立的flags(╯▔︵▔)╯，重度拖延+健忘+各种琐事总能把一些想法扼杀在摇篮中。</p><p>比如：大一点方向就是全世界/全国旅游； 小一点方向就是学习潜水、滑雪等…</p><h3 id="庆幸"><a href="#庆幸" class="headerlink" title="庆幸"></a>庆幸</h3><p>​    让我感到欣慰的是，在2020年中下旬的开始，我的思维有了一些转变。我开始变得爱看书了（各种方面的都有，如：理财、PS、算法、逻辑思维等），这个也要归功于我主动看的第一本书籍 <code>《小强升职记》</code> （通俗易懂 + 符合现实），让我感同身受的同时，思维上也有了一个质的改变。</p><a id="more"></a><p>​    我完成了很多原来不可能会做的事情（容易量化的如下，实际还有更多就不一一列举了）：</p><ul><li>我主动看完了一本书；</li><li>我坚持了看书2个月；</li></ul><p>​    虽然按照书上的一些方法不那么有效（<em>并不是每一本书都能帮你解决什么问题，它们仅仅是一个个你的起点而已</em>），但通过不断的实践、修改、实践，我开始慢慢掌握了一个属于我自己的节奏，并且更加积极向上，我知道 2021 年会更加精彩。那些天马星空的想法也变的不那么遥不可及。</p><p>​    至此我也开始明白了一句话 一一 <code>书中自有黄金屋，书中自有颜如玉。</code></p><h3 id="2019～2020年的生活"><a href="#2019～2020年的生活" class="headerlink" title="2019～2020年的生活"></a>2019～2020年的生活</h3><blockquote><p>不如意事常八九，可与语人无二三。</p></blockquote><p>​    这一年半多的时间里，磕磕碰碰的事情挺多，过程中也一度沮丧或者低落过。特别是由于平时缺乏锻炼，感觉身体上也开始各种小毛病。（<font color=red><em>敲黑板！！！身体是革命的本钱，早期一定要注意</em></font>）。</p><p>​    刚好看到2018年时去马来西亚沙巴的一次团建（<em>早晨吹着海风躺在椰子树阴下的躺椅上，感叹着生活如此多娇</em>）。</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/9S43eH5lOTtANUZ.jpg"></center><h3 id="印象比较深刻的几个地方"><a href="#印象比较深刻的几个地方" class="headerlink" title="印象比较深刻的几个地方"></a>印象比较深刻的几个地方</h3><p>在面对这些大自然的美景时，整个人的心境都得到了升华，感觉什么烦恼都在那一刻抛到九霄云外。</p><h4 id="仙本那"><a href="#仙本那" class="headerlink" title="仙本那"></a>仙本那</h4><p>印象最深刻的是当时参观的<strong>巴瑶族人</strong>一一地球上最后一个海洋游牧民族，”<strong>一生</strong>“ 都在水上的民族。</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/QvZG5ALmpbjDqOR.jpg"></center><h4 id="塞班岛"><a href="#塞班岛" class="headerlink" title="塞班岛"></a>塞班岛</h4><p>天空和海水的搭配真的是很美（海天一色）！！！无需任何滤镜，感觉如画中一般。</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/XFHWT2khB8i4KtQ.jpg"></center><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/Jzw5jZWachnstgv.jpg"></center><h4 id="雁荡山"><a href="#雁荡山" class="headerlink" title="雁荡山"></a>雁荡山</h4><p>云海翻腾，山海共生。<br><img src="https://i.loli.net/2020/08/16/Dv1gQmIM3cpCTkP.jpg" alt="life_photo_5.png" style="zoom:60%;" /></p><img src="https://i.loli.net/2020/08/16/ePwQyk1zmsI9glp.jpg" alt="life_photo_6.png" style="zoom:60%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    <strong>其实生活也就那样一一酸甜苦辣</strong>。（乍得一看有点像是一篇游记(╯▔▽▔)╯ ）</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT + Valine躺坑之路</title>
      <link href="posts/a21b8f58/"/>
      <url>posts/a21b8f58/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    写了一段时间博客后，发现别人的文章有浏览次数以及评论功能★~★，这也某种程度上提高写 <em>Blog</em> 的动力，那我也来弄一个哈哈哈。。。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>​    然而，事实总是那么折磨人。。。使用的是 <em>nexT</em> 主题的 <em>v8.2.1</em> 版本，按照网上的<a href="https://qianfanguojin.github.io/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">教程</a>后一直没有达到最终的效果😭😭。</p><a id="more"></a><h4 id="问题1-使用-Valine-插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。"><a href="#问题1-使用-Valine-插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。" class="headerlink" title="问题1: 使用 Valine 插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。"></a>问题1: 使用 <em>Valine</em> 插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。</h4><p>具体原因：因为 <code>v8.2.1 版本已经将 Valine 功能去除掉了</code>。（详情见<a href="https://github.com/next-theme/hexo-theme-next/issues/188">官网解释</a>）也尝试了官网中的解决办法以及各种网上的方法，但是仍然无效。（瞎折腾了3个小时都没结果。。。气到内伤😭😭）</p><p>那就将版本降低到能使用的 <em>Valine</em> 的 <em>NexT</em> 版本呢？（如降低到<a href="https://github.com/theme-next/hexo-theme-next/releases/tag/v7.8.0">7.8.0</a>版本呢？？）<code>降低版本到7.8.0后，问题就解决了</code>。</p><h4 id="问题2-降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。"><a href="#问题2-降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。" class="headerlink" title="问题2: 降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。"></a>问题2: 降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击中文标题导航栏时候，console控制台中报错，并且页面上没有跳转到对应的标题位置。</span></span><br><span class="line">Cannot read property <span class="string">&#x27;getBoundingClientRect&#x27;</span> <span class="keyword">of</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>实际原因是:  <code>themes/next/source/js/utils.js</code> 中的代码存在遗漏，没有对中文进行URL解码。具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... <span class="comment">// 其他多余代码省略</span></span><br><span class="line"><span class="comment">// 在这个地方获取 event 的属性时候，中文的会被自动转成URI编码格式</span></span><br><span class="line"><span class="comment">// href=&quot;#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4&quot; </span></span><br><span class="line"><span class="comment">// 但文章中的Id仍然是中文的 &lt;h3 id=&quot;操作步骤&quot;&gt;, 所以导致此处的target为null。</span></span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(event.currentTarget.getAttribute(<span class="string">&#x27;href&#x27;</span>).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br><span class="line">... <span class="comment">// 其他多余代码省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法：将上述代码替换如下代码即可。</span></span><br><span class="line"><span class="keyword">var</span> str_id = <span class="built_in">decodeURI</span>(event.currentTarget.getAttribute(<span class="string">&#x27;href&#x27;</span>).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(str_id);</span><br><span class="line"><span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br></pre></td></tr></table></figure><p>至此， 终于得到了自己想要的效果。。。（＋﹏＋）（＋﹏＋）</p><img src="https://i.loli.net/2021/02/09/vLhxcG8jZfyk46u.png" alt="valine_result.png" style="zoom:50%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    很多时候遇到的问题，通过网上不一定能适用自己当前的场景，并不一定是别人的方式有问题。。。很可能是你的环境和别人的就不一样，所以<code>同样的操作不一定能解决同样现象的问题</code>。。。还是需要多排查定位看看主要的问题点在哪。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
            <tag> Valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Py-spy解决Python程序Hang住问题</title>
      <link href="posts/cb61081b/"/>
      <url>posts/cb61081b/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    已经集成的接口自动化测试 Job 在周期性定时运行的时候，会很小概率出现一直卡在那里，原本应该3min就执行完成的任务，偶尔过了半个小时还没结束。（(￣３￣)直觉告诉我这个地方肯定有问题。。。</p><p>​    但由于复现的概率较小，一个月可能出现一次，所以开始并没有什么太大的线索（仅靠一些猜测并不切实际）。</p><p>​    终于！！！在某一个阳光明媚的大好日子，<strong>它重现了</strong>。</p><a id="more"></a><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ol><li><p>赶紧先登录到服务器上看看进程情况，发现此时存在脚本发起的2个 Worker CPU占用100%（由于用的 <code>Pytest + Pytest-xdist</code>  分布式插件执行用例），当时第一反应是死循环了？？</p><img src="https://i.loli.net/2021/01/22/AVhg7RGzYIfuWtN.png" alt="process_hang_1.png" style="zoom:50%;" /></li><li><p>通过<strong>perf</strong> 、<strong>ps</strong>或者 <strong>pstack</strong> 打印对应的pid， 看到的结果并没有什么太大用，反而<strong>误导我以为是代码里面的一个文件锁导致该问题</strong>。</p><img src="https://i.loli.net/2021/01/22/E1Yq9cjRo2GOx5e.png" alt="process_hang_2.png" style="zoom:50%;" /></li><li><p>网上查询了一通后，发现一个神奇的工具一一 <a href="https://www.zhihu.com/question/310832912">py-spy</a> （更多使用方法见 <a href="https://pypi.org/project/py-spy/">官网</a>）</p><p>安装后使用命令 ：选定一个异常的进程，执行命令： <code>py-spy  top --pid 19785</code> 打印结果如下，很明显看出来当前Cpu都卡在 <code>check_retry_status</code> 方法上面。</p><img src="https://i.loli.net/2021/01/22/CuRZJnsj13eTXoQ.png" alt="process_hang_3.png" style="zoom:50%;" /></li><li><p>查看该代码，发现该方法中存在一个while循环，并且很凑巧的是。。。╮(╯3╰)╭ 里面<font color=red><strong>没有兜底</strong></font>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体代码如下，过于相信传进来的 retry_flag 一定是1/2， 如果出现不是这两个值的时候，此时这个方法则进入了死循环。。。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_retry_status</span>(<span class="params">cls, uid, atk, order_id, retry_flag, devuuid</span>):</span></span><br><span class="line">    max_count = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> max_count &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> retry_flag == <span class="number">2</span>:</span><br><span class="line">        retry_flag = functionA(xxx, ...)</span><br><span class="line">        max_count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> retry_flag == <span class="number">1</span>:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;验证充值订单失败&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>到这个地方，就很明显定位到了问题，在此处加上兜底并且加上对应日志记录functionA（<strong>第三方依赖</strong>）到底返回的是什么。（ 因为首次传入的 retry_flag 也是来自于functionA）</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    写代码要谨慎。。。特别是结果来自第三方依赖的时候。。。<strong>一定要进行兜底！！！</strong></p><p>​    （emm… 兜一下总比不兜强）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python Plugin </tag>
            
            <tag> py-spy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python调用gRPC接口</title>
      <link href="posts/2a44a0fd/"/>
      <url>posts/2a44a0fd/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近几个项目都是用的go语言编写的，使用的是 gRPC接口，是没有对外暴露http接口。但在部分场景下，由于可测性的需要必须直接调用 gRPC接口，达到数据的构造，所以需要通过 <code>Python</code> 代码完成调用服务器上的 gRPC接口 。</p><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><p>​    由于网上相关最简单的demo已经是烂了一地。。。我这边就不再去重复写一段demo了（可参考当时我看的一篇<a href="https://cloud.tencent.com/developer/article/1557398">Blog</a>，或自行搜索相关前置准备）。</p><p>​    主要记录在实际过程中运用遇到的一些问题，希望能给大家一些帮助。</p><a id="more"></a><h4 id="步骤一：在执行转化脚本命令时候报错，具体信息如下："><a href="#步骤一：在执行转化脚本命令时候报错，具体信息如下：" class="headerlink" title="步骤一：在执行转化脚本命令时候报错，具体信息如下："></a>步骤一：在执行转化脚本命令时候报错，具体信息如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. ./user.proto</span><br><span class="line"></span><br><span class="line">github.com/gogo/protobuf/gogoproto/gogo.proto: File not found.</span><br><span class="line">base.proto: File not found.</span><br><span class="line">user.proto:7:1: Import <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span> was not found or had errors.</span><br><span class="line">user.proto:8:1: Import <span class="string">&quot;base.proto&quot;</span> was not found or had errors.</span><br><span class="line">user.proto:47:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:59:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:86:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:239:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:258:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br></pre></td></tr></table></figure><p>针对报错问题一个个分析。</p><h5 id="问题1-github-com-gogo-protobuf-gogoproto-gogo-proto-File-not-found。"><a href="#问题1-github-com-gogo-protobuf-gogoproto-gogo-proto-File-not-found。" class="headerlink" title="问题1: github.com/gogo/protobuf/gogoproto/gogo.proto: File not found。"></a>问题1: github.com/gogo/protobuf/gogoproto/gogo.proto: File not found。</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于转化的脚本中直接以如下方法引用的 gogo.proto 文件，但在转换的时候肯定是找不到的</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span></span><br></pre></td></tr></table></figure><p>解决办法：</p><ol><li><p>将 <a href="https://github.com/gogo/protobuf/blob/master/gogoproto/gogo.proto">gogo.proto</a> 文件下载到本地，放到与需要转换的 user.proto 文件同级目录下;</p></li><li><p>修改 user.proto 的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将如下代码修改成 import &quot;gogo.proto&quot;</span></span><br><span class="line">import <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="问题2-base-proto-File-not-found。"><a href="#问题2-base-proto-File-not-found。" class="headerlink" title="问题2: base.proto: File not found。"></a>问题2: base.proto: File not found。</h5><p>解决方式同问题1，实际就将依赖的这个 base.proto 文件放到与需要转换的 user.proto 文件同级目录下即可。（<code>由于我的 base.proto 文件中也同问题1中一样引用了 gogo.proto，所以都需要重复问题1的步骤2</code>）</p><p>经过上面操作，终于将 user.proto 文件转成了对应的python脚本，具体样式如下。</p><img src="https://i.loli.net/2021/02/07/B8rjYhz1ZksDfiq.png" alt="python_convert_grpc.png" style="zoom:40%;" /><p>但你以为这就完事了？？(╯▔︹▔)╯ ， <code>Too young too simple</code></p><h4 id="步骤二：调用转换成python脚本的接口。"><a href="#步骤二：调用转换成python脚本的接口。" class="headerlink" title="步骤二：调用转换成python脚本的接口。"></a>步骤二：调用转换成python脚本的接口。</h4><p><em>注：由于无需本地启动一个服务端，所以可以简单点只写一个调用端即可（具体方式类似 <code>BloomRPC</code>，通过  <code>kubectl</code> 代理到远端的 <code>grpc</code>服务端， 具体原理可自行搜索）</em></p><p>在写客户端代码之前，就还存在一个隐藏问题。</p><h5 id="问题3-实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成-python脚本（根据个人需要进行转换）。"><a href="#问题3-实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成-python脚本（根据个人需要进行转换）。" class="headerlink" title="问题3: 实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成 python脚本（根据个人需要进行转换）。"></a>问题3: 实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成 python脚本（根据个人需要进行转换）。</h5><p>客户端代码大致如下（<em>我编写的demo中则无需转换其它文件</em>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> user_pb2_grpc, user_pb2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">userService</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_mobile_by_id</span>(<span class="params">cls</span>):</span></span><br><span class="line">      <span class="comment"># 连接上本地的gRPC代理服务端, 端口为kubectl本地代理的端口</span></span><br><span class="line">        channel = grpc.insecure_channel(<span class="string">&#x27;localhost:6666&#x27;</span>) </span><br><span class="line">        <span class="comment"># 根据对应服务初始化渠道</span></span><br><span class="line">        test_stub = user_pb2_grpc.UserStub(channel)          </span><br><span class="line">        user_id = <span class="number">1234</span></span><br><span class="line">        <span class="comment"># 根据具体的 Request 定义来传入参数, 否则会报错</span></span><br><span class="line">        <span class="keyword">return</span> test_stub.GetXxxById(user_pb2.GetXxxByIdRequest(userId=user_id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(userService.get_mobile_by_id())</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 执行效果如下</span></span><br><span class="line">(ENV) ➜  demo_python_convert_grpc python user_client.py</span><br><span class="line">mobileId: <span class="string">&quot;11166668888&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数按照 user_pb2.py中方法Request定义的FieldDescriptor中具体的name来传入</span></span><br><span class="line">fields=[</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;userId&#x27;</span>, full_name</span><br><span class="line">      ...]</span><br></pre></td></tr></table></figure><p>​    至此，整体调用 <code>gRPC接口</code> 的流程算是跑通了，后续就看各自业务需求来定制化了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    最后吐槽下，很多时候准备做一件事的时候，发现网上教程挺多的，但是也会发现那些 “教程” 可能<strong>千篇一律</strong>。。。有些甚至一摸一样╮(╯Д╰)╭ 。。。当你真正按照这些 “教程” 来操作的时候又会发现可能不那么简单，所以说：<font color=blue><strong>实践是检验真理的唯一标准</strong> ！！！</font></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> gRPC接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Set命令</title>
      <link href="posts/cf736c07/"/>
      <url>posts/cf736c07/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    有时候在执行shell脚本的时候，在运行/调试的过程中会有些报错看起来不是太明显，那如何高效的调试自己编写的shell脚本呢？？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>​    网上有一些解决方案，但是尝试了下后觉得使用 shell 中的 <strong>set</strong> 命令来解决更加方便和快捷。下面来看看 <strong>set</strong> 命令到底能够有哪些应用场景。</p><a id="more"></a><h4 id="（1）set-u"><a href="#（1）set-u" class="headerlink" title="（1）set -u"></a>（1）set -u</h4><p>​    执行脚本的时候，有时候会遇到变量未定义（如：拼写错误导致变量未定义），Bash 默认是忽略它并且继续执行的，在某些场景这可能会对后面的脚本造成不可预期的错误操作， 所以可以通过 <code>set -u</code> 来控制，具体案例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line"></span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>​    可以看到，<code>echo $a</code> 输出了一个空行，Bash 忽略了不存在的 $a，然后继续执行 <code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p><p>通过脚本在头部加上 <code>set -u</code> 后，遇到不存在的变量就会报错，并停止执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -u</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 4: a: unbound variable</span><br></pre></td></tr></table></figure><h4 id="（2）set-x"><a href="#（2）set-x" class="headerlink" title="（2）set -x"></a>（2）set -x</h4><p>​    在执行复杂脚本的时候，需要对脚本进行类似debug一样的操作，则可以通过设置 <code>set -x</code>，这样就会对脚本中的执行过程的变量以及具体执行的代码进行输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line">name=<span class="string">&quot;tester&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;name&#125;</span> == <span class="string">&quot;tester&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;failed...&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> end</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">+ name=tester</span><br><span class="line">+ [[ tester == \t\e\s\t\e\r ]]</span><br><span class="line">+ <span class="built_in">echo</span> hello</span><br><span class="line">hello</span><br><span class="line">+ <span class="built_in">echo</span> end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>​    可以看到，在进行条件判断的时候，变量name被具体值替换了，打印了代码走到了条件分支的哪一步，以及打印了相应的有输出的代码行，行首以+表示。这对于调试复杂的脚本是很有用的。</p><h4 id="（3）set-e"><a href="#（3）set-e" class="headerlink" title="（3）set -e"></a>（3）set -e</h4><p>​    如果脚本里面有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令，在实际开发中，这种会导致比较严重的影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 5: foo: <span class="built_in">command</span> not found</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>通过使用 <code>set -e</code> 则可以运行失败的命令就直接退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 6: foo: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>也可以通过下面的方式来指定具体某个代码块运行失败后自动退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -e      <span class="comment"># 表示打开遇到运行命令返回非0则退出</span></span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line"><span class="built_in">set</span> +e      <span class="comment"># 表示关闭遇到运行命令返回非0则退出</span></span><br></pre></td></tr></table></figure><h4 id="（4）set-o-pipefail"><a href="#（4）set-o-pipefail" class="headerlink" title="（4）set -o pipefail"></a>（4）set -o pipefail</h4><p>​    <code>set -e</code> 有一个例外情况，就是不适用于管道命令。Bash 会把<strong>最后一个子命令的返回值</strong>，作为<strong>整个命令的返回值</strong>。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code> 就失效了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">foo | <span class="built_in">echo</span> a</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 7: foo: <span class="built_in">command</span> not found</span><br><span class="line">a</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>​    上面代码中，<strong>foo</strong>是一个不存在的命令，但是 <code>foo | echo a</code> 这个管道命令会执行成功，导致后面的 <code>echo bar</code> 会继续执行。</p><p>​     <code>set -eo pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本会在该管道执行完后终止执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line"></span><br><span class="line">foo | <span class="built_in">echo</span> a</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 7: foo: <span class="built_in">command</span> not found</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>​    可以看出，管道任务失败后，echo bar则未进行执行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    set命令的上面这四个参数，一般都放在一起使用，常用的两种方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell 脚本调试 </tag>
            
            <tag> Linux 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之优化（一）</title>
      <link href="posts/a3ff5801/"/>
      <url>posts/a3ff5801/</url>
      
        <content type="html"><![CDATA[<p>​    继上一篇搭建完最基础的Hexo环境并且发布一篇Demo文章后，基本上能满足了平时的个人Blog编写以及发布，但很多地方还是用户体验不太好，于是再对自己的Blog进行一系列的优化😁😁。</p><h4 id="优化一：Hexo-主题优化"><a href="#优化一：Hexo-主题优化" class="headerlink" title="优化一：Hexo 主题优化"></a>优化一：Hexo 主题优化</h4><p>​    网上搜了下大部分都用的 <a href="https://github.com/next-theme/hexo-theme-next">nexT</a> 这个主题，于是就直接参照对应的 <a href="https://theme-next.js.org/docs/getting-started/">官网链接</a> 操作即可。（顺便继续记录一些遇到的坑~~）如果觉得默认的主题已经不错了的可以直接跳过改步骤（<strong>但后续优化<font color=red>基于nexT v8.2.1版本优化</font>，不一定全部通用于其他主题</strong>）。</p><a id="more"></a><ul><li><p><strong>问题1: 由于官网是英文版，在网上搜索中文版本代码过老导致启动进入 localhost:4000页面仅展示如下错误内容。</strong></p><p>如果你看的教程是 <code>https://theme-next.iissnan.com/getting-started.html</code>，那么就要注意了，该链接中的nexT代码过于老旧了，可能会存在一定的问题，建议使用 <a href="https://theme-next.js.org/docs/getting-started/">官网链接</a> 。</p></li></ul><p><strong>参照最新版的教程修改完主题后，最新的样式就如下图：</strong></p><img src="https://i.loli.net/2021/02/03/1jk4csEovyJWgnM.png" alt="hexo_default.png" style="zoom:30%;" /><p>​    这个时候问题来了，<strong>如果每篇文章都如上，篇幅比较长，那么就导致首页每次展示的文章数量过少。</strong></p><h4 id="优化二：文章折叠展示-对文章添加分类、标签等"><a href="#优化二：文章折叠展示-对文章添加分类、标签等" class="headerlink" title="优化二：文章折叠展示 + 对文章添加分类、标签等"></a>优化二：文章折叠展示 + 对文章添加分类、标签等</h4><ul><li><p>步骤一：修改nexT主题目录下的_config.yml配置 (将文件中的注释去掉即可)。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure></li><li><p>步骤二：给文章添加对应的属性（如：tags、categories、description）。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="string">首次搭建个人Blog</span> <span class="string">问题记录（一）</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-02-01 22:14:05</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">blog搭建</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo建站</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">hexo建站</span></span><br></pre></td></tr></table></figure><p><strong>问题2：设置首页新增了 <code>tags 和 categories</code> 页后，点击进入到对应的 tags 或者 categories 的时候没有想要的内容， 仅仅一个 tags 或者 categories 标签。</strong></p><p>原因: 在执行 <code>hexo new page &quot;tags&quot;</code> 这一步自动生成的index.md 文件中内容缺失导致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决办法如下操作，打开对应的 blog_dir/source/tags/index.md 文件, 在最后补充如下代码</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span><span class="comment"># about/categories页操作将tags替换成about/categories即可</span></span><br></pre></td></tr></table></figure></li><li><p>步骤三：文章折叠的<a href="http://theme-next.iissnan.com/faqs.html#%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95">解决办法</a> (个人选择了方法一)</p></li></ul><p>优化完后的效果如下：</p><img src="https://i.loli.net/2021/02/03/1I6TEuywBj2QG7R.png" alt="nexT_first.png" style="zoom:40%;" /><h4 id="优化三：-文章生成短链接"><a href="#优化三：-文章生成短链接" class="headerlink" title="优化三： 文章生成短链接"></a>优化三： 文章生成短链接</h4><p>点开上图的阅读全文后，发现整体的链接是一大串文字，这个时候看起来就比较怪异，并且复制出来后直接会是URL编码的格式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://beanskingdom.github.io/2021/02/01/Hexo-首次搭建遇到的问题/#more</span><br><span class="line">https://beanskingdom.github.io/2021/02/01/Hexo-%E9%A6%96%E6%AC%A1%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/#more</span><br></pre></td></tr></table></figure><p>此时可以通过Hexo-abbrlink生成唯一永久文章链接（<a href="https://github.com/Rozbo/hexo-abbrlink">参考链接</a>）。 </p><p>最终的效果则为：<code>xxx/posts/48255dc8/#more</code></p><h4 id="优化四：修改文内链接样式"><a href="#优化四：修改文内链接样式" class="headerlink" title="优化四：修改文内链接样式"></a>优化四：修改文内链接样式</h4><p>nexT默认文章链接样式如下图：</p><img src="https://i.loli.net/2021/02/03/q2CwmFHZsNoyYlW.png" alt="next_link_style.png" style="zoom:40%;" /><p>为了突出区别性，我们在对应文件中添加下列的代码即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">themes</span>/<span class="selector-tag">next</span>/<span class="selector-tag">source</span>/<span class="selector-tag">css</span>/_<span class="selector-tag">common</span>/<span class="selector-tag">components</span>/<span class="selector-tag">post</span>/<span class="selector-tag">post-body</span><span class="selector-class">.styl</span></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的样式如下：</p><img src="https://i.loli.net/2021/02/03/L4j9vFUxBl2o3cM.png" alt="next_link_update.png" style="zoom:40%;" /><h4 id="优化五：给主页文章添加阴影效果"><a href="#优化五：给主页文章添加阴影效果" class="headerlink" title="优化五：给主页文章添加阴影效果"></a>优化五：给主页文章添加阴影效果</h4><p>打开<code>themes/next/source/css/_common/components/post/index.styl</code>文件，将<code>post-block</code>代码进行如下更改：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (hexo-config(&#x27;motion.transition.post_block&#x27;)) &#123;</span><br><span class="line">  # 添加如下代码</span><br><span class="line">    <span class="selector-class">.post-block</span>&#123;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">        <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">        background:rgba(255,255,255,0.9) none repeat scroll !important; //添加透明效果</span><br><span class="line">        <span class="selector-tag">-webkit-box-shadow</span>: 0 0 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(202, 203, 203, .5);</span><br><span class="line">        <span class="selector-tag">-moz-box-shadow</span>: 0 0 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(202, 203, 204, .5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="优化六：文章内部的导航栏位置优化"><a href="#优化六：文章内部的导航栏位置优化" class="headerlink" title="优化六：文章内部的导航栏位置优化"></a>优化六：文章内部的导航栏位置优化</h4><p>默认文章内部的导航栏位置是在左侧，看文章时候比较怪异，所以优化到了右边。</p><p>打开 <code>themes/next/_config.yml</code> 文件，将如下代码修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="comment"># position: left# 将改行注释掉，再去掉下面一行的注释</span></span><br><span class="line">  position: right</span><br></pre></td></tr></table></figure><h4 id="优化七：给文章末尾添加结束语"><a href="#优化七：给文章末尾添加结束语" class="headerlink" title="优化七：给文章末尾添加结束语"></a>优化七：给文章末尾添加结束语</h4><ul><li><p>在 <code>themes/next/layout/_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件，添加代码至该文件中；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">      &lt;div style=<span class="string">&quot;text-align:center;color: #ccc;font-size:20px;&quot;</span>&gt;------------- 本 文 结 束 &lt;i class=<span class="string">&quot;fa fa-paw&quot;</span>&gt;&lt;/i&gt; 感 谢 您 的 阅 读 -------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>themes/next/layout/_macro/post.njk</code> 文件，在 post-body 后，post-footer 前，添加下面内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">&#x27;passage-end-tag.swig&#x27;</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在如下内容之前添加上述代码</span></span><br><span class="line"><span class="comment">#    &#123;#####################&#125;</span></span><br><span class="line"><span class="comment">#    &#123;### END POST BODY ###&#125;</span></span><br><span class="line"><span class="comment">#    &#123;#####################&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在主题配置文件 <code>_config.yml</code> 在末尾添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="优化八：给代码块添加复制功能"><a href="#优化八：给代码块添加复制功能" class="headerlink" title="优化八：给代码块添加复制功能"></a>优化八：给代码块添加复制功能</h4><p>打开 <code>themes/next/_config.yml</code> 主题配置文件，搜索 codeblock ,开启复制，修改代码如下。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">copy_button:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span><span class="comment"># 显示复制按钮</span></span><br><span class="line">  <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">flat</span><span class="comment"># 复制按钮展示形式</span></span><br></pre></td></tr></table></figure><h4 id="优化九：实现统计功能"><a href="#优化九：实现统计功能" class="headerlink" title="优化九：实现统计功能"></a>优化九：实现统计功能</h4><p>在根目录下安装 <code>hexo-wordcount</code>,运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>然后在主题的配置文件中，配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    至此，部分个人体验相关的优化已经结束，这个时候可以开心的写blog了，自己看起来效果也不错，但这样你满足了么？？</p><p>​    当然不满意啦！！！ 至少要看到有多少人来看我的blog吧？😄😄静待后续优化。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 首次搭建个人Blog问题记录</title>
      <link href="posts/48255dc8/"/>
      <url>posts/48255dc8/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    看到别人那么炫酷的个人Blog后，自己也突然有了一些想法，既而最近看了《小强升职记》中的第五章让目标落地，于是便马上开始规划起了自己的Blog。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>​    通过这个Blog记录生活中的点点滴滴。</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>​    由于这类型的文章在网上太多了。。。具体的搭建过程就不一一搬运了。（个人觉得比较详细的一个链接：<a href="https://www.cnblogs.com/shwee/p/11421156.html">Hexo+Github: 个人博客网站搭建完全教程(看这篇就够了)</a>）</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>​    emm…有一个比较详细的教程是多么重要的一件事，虽然别人的Blog上看起来也就1个小时的事，实际自己做起来却花费了大半天😭😭。。。总结了以下在搭建过程中自己遇到的坑。</p><ol><li><p><strong>执行修改_config.yml文件后，执行创建新的文章命令时候报错。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;Bigbean&#x27;s demo&quot;</span></span><br><span class="line">FATAL TypeError: Invalid config detected: <span class="string">&quot;url&quot;</span> should be string, not object!</span><br><span class="line"></span><br><span class="line">原因：拷贝其他教程的配置文件时候，url:  <span class="comment">#网址 这个地方未配置</span></span><br></pre></td></tr></table></figure></li><li><p><strong>发布了第一篇文章后，页面打开显示错误。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端里面报错 </span></span><br><span class="line">WARN  No layout: index.html</span><br></pre></td></tr></table></figure><p>原因：在步骤3中按照参考链接中改了配置后，实际并没有链接中的那个主题 <code>theme: landscape-plus</code>， </p><p>所以<font color=red><strong>修改_config.yml配置文件的时候一定要注意！！！再次提醒不要全部照抄，应该仅仅是改自己需要改的地方。</strong></font></p></li><li><p><strong>在执行 <code>hexo d</code> 发布的时候报错。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: git</span><br><span class="line"><span class="comment"># 这是因为没安装hexo-deployer-git插件，在站点目录下输入下面的插件安装就好了</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p><strong>怎么再通过github的链接直接访问网上远端的效果呢？</strong></p><p>进入 github 项目中点击 Settings，向下拉到最后有个 GitHub Pages，点击 Choose a theme 选择一个主题。然后等一会儿，再回到 GitHub Pages，就会变成你选择的主题。<a href="https://zhuanlan.zhihu.com/p/35668237">参考链接</a></p></li><li><p><strong>按照6中的操作后，github page一直未被识别，导致点击链接去看里面样式找不到。（<a href="https://www.cnblogs.com/shwee/p/11421156.html">参考链接</a>）</strong></p><p>原因： 要创建一个和你用户名相同的仓库，后面加 <strong>.github.io</strong>，只有这样，将来要部署到 <code>GitHub page</code> 的时候，才会被识别 。例如我的：<a href="https://beanskingdom.github.io/">beanskingdom.github.io</a></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        至此。。。终于完成了第一篇内容的发布，后续还会继续进行相关的优化，如：主题、评论、搜索等等。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
