<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python-Flask入门</title>
      <link href="python-Python-Flask%E5%85%A5%E9%97%A8/"/>
      <url>python-Python-Flask%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    团队准备开发QA工具平台，一方面锻炼编程能力，一方面是提高团队的工作效率，如可测性、数据构造等（避免仅仅是写一些重复的接口用例）。团队成员的现状如下：</p><ul><li>比较熟悉的是<strong>Python</strong>语言；</li><li>以前基本没有工具平台的开发经验。</li></ul><p>根据上述的背景来看，在进行整体技术栈选型的时候以下两点比较重要。</p><ul><li>上手速度要快；</li><li>社区比较活跃，相关文档比较多。</li></ul><a id="more"></a><h3 id="框架选型"><a href="#框架选型" class="headerlink" title="框架选型"></a>框架选型</h3><p>在进行后端框架的选型之前，先简单的对框架进行一些了解。</p><blockquote><p>框架（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性</p></blockquote><p>它本身一般不完整到可以解决特定问题，其主要的特性是为了扩展各种功能已满足用户的需求。</p><h4 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h4><p>Python的常用Web框架挺多，但在Github上比较火的有 <a href="https://github.com/django/django"><strong>Django</strong></a>、<a href="https://github.com/pallets/flask"><strong>Flask</strong></a>（<a href="https://github.com/tornadoweb/tornado"><strong>Tornado</strong></a> 与前两者的star数量基本已经相差好几倍了）。</p><ul><li><p><a href="https://www.djangoproject.com/">Django</a> 一一 <strong>企业级开发框架</strong></p><p>诞生于2003年，相对于其他WEB框架来说，它主要优点是功能齐全，缺点则是模块之间紧密耦合，开发者需要学习Django自己定义的这一整套技术。</p></li><li><p><a href="http://docs.jinkan.org/docs/flask/">Flask</a> 一一 <strong>快速建站</strong></p><p>诞生于2010年，其定义就是面向简单需求和小型应用的微框架(啥叫微框架，就是毛坯房的意思。给你个毛胚房，你自己装修去)，这样的好处就是具有较高的扩展性。 </p></li><li><p>Tornado 一一 <strong>高并发处理</strong></p><p>诞生于2009年9月10日，其主要特点是：提供了异步I/O支持、超时事件处理。</p></li><li><p>Twisted、Pyramid、Web2py等</p></li></ul><h4 id="不同框架的区别"><a href="#不同框架的区别" class="headerlink" title="不同框架的区别"></a>不同框架的区别</h4><ul><li><p><strong>Full-Stack Web框架：</strong>框架功能很全，不用自己造轮子，比如(cache、session、登陆、auth授权等等)以及它强大的中间件，提供全方案Web开发支持。比如<a href="https://www.djangoproject.com/"><strong>Django框架</strong></a>。</p><p>  当然功能强大和全面的反面就是有点复杂（相对的），不太灵活。所以Django上手要慢一点，自己造一个轮子替换Django某些内置功能或者使用第三方功能时不太灵活。</p></li><li><p><strong>Non Full-Stack Web框架：</strong>框架小巧，灵活，很多功能需要开发者以插件的形式向里安装，也可以自己定制，比如<a href="http://flask.pocoo.org/"><strong>Flask框架</strong></a>。</p></li><li><p><strong>Asynchronous 异步框架：</strong>框架本身的速度比较快，I/O性能吞吐高并发，当然异步编程的理解难度要大一点。像<a href="http://www.tornadoweb.org/en/latest/"><strong>Tornado</strong></a>和<a href="https://sanic.readthedocs.io/en/latest/"><strong>Sanic框架</strong></a>。</p></li></ul><h4 id="为什么选择Flask"><a href="#为什么选择Flask" class="headerlink" title="为什么选择Flask"></a>为什么选择Flask</h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;截至2019年9月2日，Flask在Github上的星数是46179颗，Django的Github星数是43806颗，两者几乎难分伯仲，其它Python Web框架与Flask和Django星数相差甚远。考虑到Django早发布5年，而Flask在星数上还领先2000多颗，由此可以得知Flask当前略微占优。</p></blockquote><p>选Flask框架的原因主要基于如下几个点：</p><ol><li><p>简约的设计哲学 一一 <code>Less is more</code></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></li><li><p>通俗易懂的 <a href="http://docs.jinkan.org/docs/flask/quickstart.html#a-minimal-application">快速入门</a>。</p></li><li><p>装饰器表示路由。(面向切面编程-JAVA中的AOP)。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/add&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_add</span>():</span></span><br><span class="line">    params = request.get_json().get(<span class="string">&#x27;params&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> params <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(params, <span class="built_in">dict</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;params is error&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(params.setdefault(<span class="string">&#x27;a&#x27;</span>, <span class="number">0</span>) + params.setdefault(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p> 通过本地Debug可以明显发现，代码启动后自动通过 <code>app.route(&#39;xxx&#39;)</code> 就自动将前端访问的路由地址与后端的代码给绑定到了一起，并且在后续的请求中，通过装饰器自动定位到具体的后端方法。</p> <img src="https://i.loli.net/2020/02/29/J2TYOn7oWSrNdZc.png" width="700px" title="内部分享-photo-1.png"></li></ol><ol start="4"><li><p><a href="https://spacewander.github.io/explore-flask-zh/7-blueprints.html">蓝图</a> 一一 <code>Blueprint</code></p><p> 常见的情况：当功能多了后就会出现如下代码的样式，很多个路由都在一个文件中，维护以及可读性都很差。这个时候就需要方便的管理这些路由。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/add&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world1</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user_info&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world2</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/compute&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world3</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 蓝图便类似一个有效的菜单栏，通过将不同的功能的子菜单在不同的文件中单独维护，然后集中在通过 <code>app.register\_blueprint(xxx)</code> 注册到代码中。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint, jsonify</span><br><span class="line"></span><br><span class="line">compute_method_api = Blueprint(<span class="string">&#x27;compute_method&#x27;</span>, __name__)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@compute_method_api.route(<span class="params"><span class="string">&quot;/compute_add&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sonar_error_info</span>():</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(<span class="number">1</span> + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><p>通过上面介绍，在需要开发的平台不太复杂的情况下，<strong>Flask</strong>比较符合新手作为快速入门的框架（个人意见）。</p><h3 id="Flask-框架介绍"><a href="#Flask-框架介绍" class="headerlink" title="Flask 框架介绍"></a>Flask 框架介绍</h3><p>​    Flask是一种使用Python编写的轻量级的Web框架，WSGI工具采用Werkzeug，模板引擎使用Jinja2，下图表示 WSGI 的一个过程。</p><center class="half">    <img title="分享内容_photo_3.png" src="https://i.loli.net/2020/03/02/ix9YUBVyktaSjL4.png" width="600px"></center>首先从官网的一个最小的 Flask应用进行分析，运行如下代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>（在不去了解内部原理的情况下）光从代码来看，仅仅做了如下几点：</p><blockquote><ol><li>首先，导入了 Flask 类，这个类的对象将会是我们的 WSGI 应用程序。</li><li>接下来，创建一个该类的实例对象，第一个参数是应用模块或者包的名称。这样 Flask 才知道到哪去找模板、静态文件等等。详情见 Flask 的文档。</li><li>然后，我们使用 route() 装饰器告诉 Flask 什么样的 URL 能触发我们的函数。这个函数的名字也在生成 URL 时被特定的函数采用，这个函数返回我们想要显示在用户浏览器中的信息。</li><li>最后我们用run()函数来让应用运行在本地服务器上。 </li></ol></blockquote><p>那具体上面的Demo代码实现原理是如何呢？具体分为3个步骤，分别对应着上面的代码层面的逻辑： 见如下图：</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/09/03/YysnAWX4Ic3CBwG.png" width="800px"></center><ul><li><p><strong>实例一个Flask类的对象，里面进行了各种参数的初始化，主要讲下里面如下几个参数：</strong></p><ol><li><p><strong>self.static_url_path：</strong>用于改变url的path，默认静态文件放在static下面，所以url是static/filename 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__, static_url_path=<span class="string">&quot;/static/change&quot;</span>)</span><br><span class="line"><span class="comment"># 如上指定static_url_path路径后那么默认的static/filename就访问不到静态资源了，必须通过static/change/filename才能访问到。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>self.static_folder：</strong> 用来改变静态资源目录，默认是static目录下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__, static_folder=<span class="string">&quot;my_static&quot;</span>)</span><br><span class="line"><span class="comment"># static_folder=&quot;my_static&quot; 那么默认的static/filename就访问不到静态资源了，必须通过my_static/filename才能访问到静态资源。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>self.blueprints:</strong> 用于更好的管理多个Api文件。（更多相关可以自行搜索<strong>Flask 蓝图</strong>）</p><p>举个例子：如果把所有的路由都如Demo代码里面的app.route一样写到一个文件中，那随着项目的增加，此文件的维护性会越来越差，所以通过先将不同的模块都分别写到对应的文件中，然后通过蓝图的注册到Flask实例对象中的<strong>self.blueprints</strong>。</p></li><li><p><strong>self.url_map:</strong> 用于存储所有的路由规则。</p></li></ol></li><li><p><strong>@app.route(‘xxx’) 进行所有路由规则进行添加。</strong></p><p>基本的原理就是通过解析所有带有<strong>route</strong>装饰器的方法，通过将 <strong>rule</strong> 与 <strong>function_name</strong> 进行一一绑定并且存储到<strong>self.url_map</strong>中，大概的存储格式如下图：(rule为route(‘xxx’)中的xxx， endpoint为绑定的方法名，<strong>像Demo代码中 rule 为 ‘/‘, endpoint 为 ‘hello_world’</strong>)</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/09/03/MLYfheoj4drTm9i.png" width="700px"></center></li><li><p><strong>app.run(host=’0.0.0.0’, port=5000)</strong> 启动应用。</p><p>从源码中发现flask启动server的时候实际就是直接使用的 Werkzeug.serving 的 run_simple(…)，在这里可以简单的理解内部启动了一个BaseWSGIServer。</p></li></ul><p>在浏览器中输入 <code>http://0.0.0.0:5000/</code> 就会返回Hello World了。那Flask又是如何处理的浏览器发起的请求的呢？大概原理如下图：</p><center class="half">    <img title="flask_server_2.png" src="https://i.loli.net/2020/09/03/MaOVwzQStm6gLYv.png"></center><p>整个处理请求的逻辑简单的可以看分为两部分：</p><ul><li><p><strong>Werkzeug.serving</strong></p><p>简单点说就是创建一个线程，并且为此次请求实例化一个通用处理器 <code>BaseRequestHandler</code> 用于初始化此次请求的信息等，然后直接调用Flask.app去执行该请求，最终通过start_response对结果进行相应处理后返回。</p></li><li><p><strong>Flask.app</strong></p><ul><li>Full_dispatch_request: 对请求进行预处理（如蓝图）以及结果的格式化。 </li><li>Dispatch_request: 根据self.view_functions里面的Rule找到指定的Function，然后执行func返回结果。</li><li>Make_response：将dispatch_request处理完的返回值变成符合http协议的响应结果。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  request_started.send(self)</span><br><span class="line">  rv = self.preprocess_request()</span><br><span class="line">  <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    rv = self.dispatch_request()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  rv = self.handle_user_exception(e)</span><br><span class="line"><span class="keyword">return</span> self.finalize_request(rv)</span><br></pre></td></tr></table></figure></li></ul><p>下图梳理了 Flask 框架的一个整体流程图（有兴趣的可以更深入的去了解下相关内容）。</p><p><img src="https://i.loli.net/2020/03/02/FOHxSV7WRLy4Uoh.png" alt="分享内容_photo_2.png"></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://dormousehole.readthedocs.io/en/latest/">Flask 中文文档v1.1.1</a></li><li><a href="https://flask.palletsprojects.com/en/1.1.x/">Flask 英文文档v1.1.x</a></li><li><a href="https://github.com/pallets/flask">Flask Github</a></li><li><a href="https://github.com/django/django">Django Github</a></li><li><a href="https://zhuanlan.zhihu.com/p/59841196">什么是Web框架、web框架有什么功能？</a></li><li><a href="https://www.zhihu.com/question/28902969">为什么Flask能火</a></li><li><a href="http://chuann.cc/Python/flask/analyze_principle_of_flask.html">Flask原理解读</a></li><li><a href="https://juejin.im/post/5dc22fd56fb9a04a8f39bddd">Flask的组成</a></li><li><a href="https://blog.csdn.net/sinat_36651044/article/details/77462831">WSGI各个主要函数的解释</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Python </tag>
            
            <tag> Web框架 </tag>
            
            <tag> 平台建设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 字符串包含</title>
      <link href="shell-Shell-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB/"/>
      <url>shell-Shell-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<p>​    记录下 Shell 中常见的几种  判断字符串A是否包含字符串B的方法。</p><a id="more"></a><h3 id="方法一：利用grep查找"><a href="#方法一：利用grep查找" class="headerlink" title="方法一：利用grep查找"></a>方法一：利用grep查找</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="string">&quot;test str&quot;</span></span><br><span class="line">B=<span class="string">&quot;test&quot;</span></span><br><span class="line">result=$(<span class="built_in">echo</span> <span class="variable">$A</span> | grep <span class="string">&quot;<span class="variable">$&#123;B&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$result</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;包含&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;不包含&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="方法二：利用字符串运算符"><a href="#方法二：利用字符串运算符" class="headerlink" title="方法二：利用字符串运算符"></a>方法二：利用字符串运算符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="string">&quot;test str&quot;</span></span><br><span class="line">B=<span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$A</span> =~ <span class="variable">$B</span> ]];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;包含&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;不包含&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="方法三：利用通配符"><a href="#方法三：利用通配符" class="headerlink" title="方法三：利用通配符"></a>方法三：利用通配符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="string">&quot;test str&quot;</span></span><br><span class="line">B=<span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$A</span> == *<span class="variable">$B</span>* ]];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;包含&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;不包含&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
            <tag> 字符串包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell关联数组</title>
      <link href="shell-Shell%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/"/>
      <url>shell-Shell%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在大部分的编程语言中都支持 “键值对” 的这种数据结构，比如：Python中的dict、Java中的HashMap等等。对于Shell中实际也是存在类似的这种用法，也就是 “<strong>Shell关联数组</strong>“。</p><p>​    刚好最近在写Shell脚本的时候使用了该功能，便进行相关使用方法以及注意点的记录。</p><a id="more"></a><h3 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h3><h4 id="初始化-amp-访问元素"><a href="#初始化-amp-访问元素" class="headerlink" title="初始化 &amp; 访问元素"></a>初始化 &amp; 访问元素</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A userInfo</span><br><span class="line"><span class="built_in">declare</span> userInfo</span><br><span class="line">userInfo[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;tom&quot;</span></span><br><span class="line">userInfo[<span class="string">&quot;age&quot;</span>]=8</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;userInfo[&quot;name&quot;]&#125;</span></span><br><span class="line"><span class="comment"># =&gt; tom</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;userInfo[&quot;age&quot;]&#125;</span></span><br><span class="line"><span class="comment"># =&gt; 8</span></span><br></pre></td></tr></table></figure><p>⚠️ 注意事项：</p><h5 id="问题1-declare-A-userInfo-初始化关联数组的方式在本地MAC上不可用。"><a href="#问题1-declare-A-userInfo-初始化关联数组的方式在本地MAC上不可用。" class="headerlink" title="问题1: declare -A userInfo 初始化关联数组的方式在本地MAC上不可用。"></a>问题1: <code>declare -A userInfo</code> 初始化关联数组的方式在本地MAC上不可用。</h5><p><a href="https://stackoverflow.com/questions/27002192/bash-declare-a-does-not-work-on-macos">原因</a>：<code>declare -A</code> Shell关联数组的用法是在 Bash 4+ 的功能，我本地MAC的 Bash版本是 3.X。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx@xxxMacBook-Pro:~$ <span class="built_in">echo</span> <span class="variable">$&#123;BASH_VERSION&#125;</span></span><br><span class="line">3.2.57(1)-release</span><br></pre></td></tr></table></figure><p>解决方法可以参考：<a href="https://blog.csdn.net/liumiaocn/article/details/110463957">MAC 升级bash</a>（本人未实践，仅供参考）</p><h5 id="问题2-部分网页在访问元素时使用-的方式，此方法会报错。应该使用-。"><a href="#问题2-部分网页在访问元素时使用-的方式，此方法会报错。应该使用-。" class="headerlink" title="问题2: 部分网页在访问元素时使用 () 的方式，此方法会报错。应该使用 {}。"></a>问题2: 部分网页在访问元素时使用 () 的方式，此方法会报错。应该使用 {}。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@2fba7896990f ~]<span class="comment"># echo $(userInfo[&quot;name&quot;])</span></span><br><span class="line">-bash: userInfo[name]: <span class="built_in">command</span> not found</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决办法：</span></span><br><span class="line">[root@2fba7896990f ~]<span class="comment"># echo $&#123;userInfo[&quot;name&quot;]&#125;</span></span><br><span class="line">tom</span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A userInfo</span><br><span class="line">userInfo[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;userInfo[&quot;name&quot;]&#125;</span></span><br><span class="line"><span class="comment"># =&gt; tom</span></span><br><span class="line"><span class="built_in">unset</span> userInfo[<span class="string">&quot;name&quot;</span>]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;userInfo[&quot;name&quot;]&#125;</span></span><br><span class="line"><span class="comment"># =&gt; 无结果</span></span><br></pre></td></tr></table></figure><p>⚠️ 注意事项：</p><h5 id="问题3-获取关联数组的值时，未使用-，返回结果错误。"><a href="#问题3-获取关联数组的值时，未使用-，返回结果错误。" class="headerlink" title="问题3: 获取关联数组的值时，未使用 {}，返回结果错误。"></a>问题3: 获取关联数组的值时，未使用 {}，返回结果错误。</h5><p>由于Shell中的变量实际可以不使用{}，比如以下代码输出的结果是一致的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a&#125;</span></span><br></pre></td></tr></table></figure><p>但在使用关联数组获取对应key的值时候，必须带{}。否则输出结果异常。具体实例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A userInfo</span><br><span class="line">userInfo[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;tom1&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$userInfo</span>[<span class="string">&quot;name&quot;</span>]</span><br><span class="line"><span class="comment"># =&gt; [name]</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;userInfo[&quot;name&quot;]&#125;</span></span><br><span class="line"><span class="comment"># =&gt; tom1</span></span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>获取所有元素的值（两种方式结果相同）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;userInfo[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;userInfo[*]&#125;</span></span><br><span class="line"><span class="comment"># =&gt; tom 8</span></span><br></pre></td></tr></table></figure></li><li><p>获取所有元素的下标（两种方式结果相同）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!userInfo[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!userInfo[*]&#125;</span></span><br><span class="line"><span class="comment"># =&gt; name age</span></span><br></pre></td></tr></table></figure></li><li><p>判断元素是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断 &quot;name&quot; 的key值存在</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;userInfo[&#x27;name&#x27;]&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;key: name exist&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>遍历所有键值并输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;!userInfo[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;key&#125;</span> -&gt; <span class="variable">$&#123;userInfo[$key]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># =&gt; name -&gt; tom</span></span><br><span class="line"><span class="comment"># =&gt; age -&gt; 8</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://c.biancheng.net/view/3009.html">Shell关联数组</a></li><li><a href="https://codeantenna.com/a/W4W5n7DEws">Bash shell关联数组提高查找效率</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter唯一ID</title>
      <link href="tools-Jmeter%E5%94%AF%E4%B8%80ID/"/>
      <url>tools-Jmeter%E5%94%AF%E4%B8%80ID/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在使用Jmeter进行一些高并发的压测时候，请求参数重需要构造唯一的订单ID。</p><p>​    开始时使用了 <code>$&#123;__Random(100000,999999,)&#125;</code> 以及 <code>__time()</code> 的组合来生成唯一订单ID，但由于TPS较大的情况下，最终导致了出现重复订单ID😂。。。</p><p>于是梳理了下后续可能压测的场景，根据此方案制定了最终的解决方案。后续可能压测的场景如下：</p><ul><li>场景一：一个线程组中存在多个线程并发生成唯一ID；</li><li>场景二：多个线程组 + 每个线程组中是多个线程并发生成唯一ID；</li><li>场景三：多个Jmeter脚本 + 多个线程组 + 每个线程组中是多个线程并发生成唯一ID；</li></ul><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>PS：以下方法均在 <code>BeanShell PreProcessor</code> 中进行验证得出的结果。</p><h4 id="方法一：-通过-UUID-函数生成随机字符串；"><a href="#方法一：-通过-UUID-函数生成随机字符串；" class="headerlink" title="方法一： 通过 UUID() 函数生成随机字符串；"></a>方法一： 通过 <code>UUID()</code> 函数生成随机字符串；</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String randomStr = <span class="string">&quot;<span class="variable">$&#123;__UUID&#125;</span>&quot;</span>;</span><br><span class="line">log.info(<span class="string">&quot;test: &quot;</span> + randomStr);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志打印如下：</span></span><br><span class="line">2021-12-16 18:07:52,667 INFO o.a.j.u.BeanShellTestElement: <span class="built_in">test</span>: 863a7d5a-2487-4cba-ad9d-2b159487019b</span><br></pre></td></tr></table></figure><p>该方法简单又快速，但这种带字符串的看起来不太符合订单ID（如果仅仅是生成唯一ID，可以使用该方法）。</p><h4 id="方法二：使用多个函数组合-（推荐）"><a href="#方法二：使用多个函数组合-（推荐）" class="headerlink" title="方法二：使用多个函数组合 （推荐）"></a>方法二：使用多个函数组合 （推荐）</h4><p>组合的函数如下：</p><ul><li><p><code>ctx.getThread().getThreadName()</code>：当前的线程组名，但大部分时候形式是：x-x，所以需要进行裁剪；</p></li><li><p><code>$&#123;__threadNum&#125;</code>：在单个线程组中的线程号，这个在单个组中是递增并且唯一的；</p></li><li><p><code>$&#123;__counter(,)&#125;</code>：计数器进行计数；</p></li><li><p> <code>Date()</code> ：当前时间戳；（代码中使用了格式化生成年月日 时分秒毫秒的格式）</p></li></ul><p>最终脚本内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(<span class="string">&quot;yyyyMMddHHmmssSSS&quot;</span>);</span><br><span class="line">String groupId = ((ctx.getThread().getThreadName().toString()).split(<span class="string">&quot; &quot;</span>)[1]).split(<span class="string">&quot;-&quot;</span>)[0];</span><br><span class="line">Integer threadNum = <span class="variable">$&#123;__threadNum&#125;</span>;</span><br><span class="line">Integer threadCount = <span class="variable">$&#123;__counter(,)&#125;</span>;</span><br><span class="line">String randomNumStr = String.valueOf(threadNum) + String.valueOf(threadCount) + groupId;</span><br><span class="line">String orderId = sdf.format(new Date()) + randomNumStr ;</span><br><span class="line">log.info(<span class="string">&quot;test groupId: &quot;</span> + groupId);</span><br><span class="line">log.info(<span class="string">&quot;test threadNum: &quot;</span> + threadNum);</span><br><span class="line">log.info(<span class="string">&quot;test threadCount: &quot;</span> + threadCount);</span><br><span class="line">log.info(<span class="string">&quot;test randomNumStr: &quot;</span> + randomNumStr);</span><br><span class="line">log.info(<span class="string">&quot;test orderId: &quot;</span> + orderId);</span><br><span class="line"></span><br><span class="line">2021-12-16 19:02:08,259 INFO o.a.j.u.BeanShellTestElement: <span class="built_in">test</span> groupId: 1</span><br><span class="line">2021-12-16 19:02:08,259 INFO o.a.j.u.BeanShellTestElement: <span class="built_in">test</span> threadNum: 1</span><br><span class="line">2021-12-16 19:02:08,259 INFO o.a.j.u.BeanShellTestElement: <span class="built_in">test</span> threadCount: 2</span><br><span class="line">2021-12-16 19:02:08,259 INFO o.a.j.u.BeanShellTestElement: <span class="built_in">test</span> randomNumStr: 121</span><br><span class="line">2021-12-16 19:02:08,260 INFO o.a.j.u.BeanShellTestElement: <span class="built_in">test</span> orderId: 20211216190208259121</span><br></pre></td></tr></table></figure><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>​    但个人感觉场景三一一多个脚本同时运行时，可能会存在问题。 其 <code>groupId</code>、 <code>threadNum</code>、<code>threadCount</code> 拼接起来仍然存在会一致的情况。因为这些值并不是跨脚本唯一的。比如：groupId可能都是1， threadNum也是1，threadCount也是2。</p><p>于是做了一个试验去进行验证：</p><blockquote><p> 同时执行3个脚本，每个脚本存在一个线程组， 每个线程组配置的100个并发，持续5分钟看是否出现重复的订单ID。</p></blockquote><p>结果：<strong>共生成了 8442274 个订单，但无重复。</strong> 当然这可能存在运气😂，这个暂时先使用该方法作为最终解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> Jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jmeter </tag>
            
            <tag> 性能压测工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Supervisor</title>
      <link href="Linux-Linux-supervisor-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
      <url>Linux-Linux-supervisor-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近在搭建混沌工程所需要的专项测试环境，原来一般都是直接通过 <code>nohup + &amp;</code> 的方式，但该方式存在一个问题，如果由于<strong>服务器重启或者进程被kill掉了，那这个时候就需要再手动的去启动相应的进程。</strong> 这样对于只有一两个进程来说还好，但对于需要维护很多台虚拟机或者很多进程的时候则会比较繁琐。所以便牵扯到守护进程一一<code>Supervisor</code>。</p><a id="more"></a><h3 id="什么是守护进程"><a href="#什么是守护进程" class="headerlink" title="什么是守护进程"></a>什么是守护进程</h3><blockquote><p>在linux或者unix操作系统中，守护进程（Daemon）是一种运行在后台的特殊进程，它独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。由于在linux中，每个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端被称为这些进程的控制终端，当控制终端被关闭的时候，相应的进程都会自动关闭。但是守护进程却能突破这种限制，它脱离于终端并且在后台运行，并且它脱离终端的目的是为了避免进程在运行的过程中的信息在任何终端中显示并且进程也不会被任何终端所产生的终端信息所打断。它从被执行的时候开始运转，直到整个系统关闭才退出。</p></blockquote><h3 id="Supervisor"><a href="#Supervisor" class="headerlink" title="Supervisor"></a>Supervisor</h3><p>比较容易弄混淆的几个名词：</p><ul><li><strong>supervisor</strong>：要安装的软件的名称；</li><li><strong>supervisord</strong>：装好 <code>supervisor</code> 软件后，<code>supervisord</code> 用于启动 <code>supervisor</code>  服务；</li><li><strong>supervisorctl</strong>：用于管理 <code>supervisor</code> 配置文件中 <code>program</code> 和 <code>supervisor</code> 服务本身。</li></ul><p>在 Linux 上有很多可以管理进程的工具，使用 Supervisor 来做这个事情。原因有两点：</p><ul><li>它是微软官方文档推荐的，降低学习成本。</li><li>它并不一定是最好的，但一定是文档最全的。</li></ul><h3 id="Docker上安装-supervisor"><a href="#Docker上安装-supervisor" class="headerlink" title="Docker上安装 supervisor"></a>Docker上安装 supervisor</h3><p>下面主要介绍下在新的Docker环境上安装supervisor的过程中可能遇到的问题。（也可参考<a href="http://supervisord.org/installing.html">supervisor官网</a>的安装方式）</p><h4 id="问题一：新启动的Docker，通过yum安装-supervisor-失败。"><a href="#问题一：新启动的Docker，通过yum安装-supervisor-失败。" class="headerlink" title="问题一：新启动的Docker，通过yum安装 supervisor 失败。"></a>问题一：新启动的Docker，通过yum安装 supervisor 失败。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@fafebfab0828 /]<span class="comment"># yum install -y supervisor</span></span><br><span class="line">Loaded plugins: fastestmirror, ovl</span><br><span class="line">Determining fastest mirrors</span><br><span class="line"> * base: mirrors.nju.edu.cn</span><br><span class="line"> * extras: mirrors.nju.edu.cn</span><br><span class="line"> * updates: mirrors.nju.edu.cn</span><br><span class="line">...</span><br><span class="line">No package supervisor available.</span><br><span class="line">Error: Nothing to <span class="keyword">do</span></span><br></pre></td></tr></table></figure><p>即使通过修改了yum源的配置，仍然存在这个问题。</p><p><strong>根本原因</strong>：新启动的Docker中，不存在 EPEL（Extra Packages for Enterprise Linux）企业版Linux额外包，PHEL分布非标准包的社区类库。</p><p><strong>解决方案</strong>：</p><ol><li><p><a href="https://www.cxyzjd.com/article/qq_40738539/108718784">安装EPEL包</a>（<font color=green>推荐</font>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum install -y supervisor</span><br></pre></td></tr></table></figure></li><li><p>通过 <a href="https://mirrors.tuna.tsinghua.edu.cn/epel/7/x86_64/Packages/">Centos pkg 官网</a> （链接为Centos7，如是其他系统需找到对应链接）找到对应的 <code>supervisor</code> 安装包。</p><p>⚠️ PS： 其缺点是该安装包如果还依赖其他的包就会挺麻烦，可能还需要按照该方式下载其他的依赖包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时安装 supervisor 还是依赖 python-meld3 和 python-setuptools</span></span><br><span class="line">[root@28c67f46fd89 home]<span class="comment"># rpm -ivh supervisor-3.4.0-1.el7.noarch.rpm</span></span><br><span class="line">warning: supervisor-3.4.0-1.el7.noarch.rpm: Header V3 RSA/SHA256 Signature, key ID 352c64e5: NOKEY</span><br><span class="line">error: Failed dependencies:</span><br><span class="line">python-meld3 &gt;= 0.6.5 is needed by supervisor-3.4.0-1.el7.noarch</span><br><span class="line">python-setuptools is needed by supervisor-3.4.0-1.el7.noarch</span><br></pre></td></tr></table></figure></li></ol><h4 id="问题二：开机自启动-supervisor-失败"><a href="#问题二：开机自启动-supervisor-失败" class="headerlink" title="问题二：开机自启动 supervisor 失败"></a><a href="https://www.cnblogs.com/haima/p/13636812.html">问题二：开机自启动 supervisor 失败</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> supervisor</span><br><span class="line"><span class="comment"># 启动 supervisord 服务</span></span><br><span class="line">systemctl start supervisor</span><br><span class="line">Failed to get D-Bus connection: Operation not permitted</span><br></pre></td></tr></table></figure><p>原因：Docker运行一个容器起来的时候，只是为你提供特定的文件系统层和进程隔离，它给你一个VM的感觉却并不是VM，所以你可能偶尔会想要像在物理机那样使用systemctl start|status|stop来管理服务进程，就会出现上述错误。</p><p><font color=red>需要启动systemd进程， 所以需要特权。</font>解决办法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建容器</span></span><br><span class="line">docker run -d --name centos7 --privileged=<span class="literal">true</span> centos:7 /usr/sbin/init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器中</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos7 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="使用-supervisor-启动其他进程"><a href="#使用-supervisor-启动其他进程" class="headerlink" title="使用 supervisor 启动其他进程"></a>使用 supervisor 启动其他进程</h3><p>下面通过python写了一个简单的demo，通过supervisor来进行自启动以及守护。</p><ol><li><p>编写需要守护的Demo脚本：test.py，对应的目录为: <code>home/demo/test.py</code>，具体内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">def print_demo():</span><br><span class="line">  count = 0</span><br><span class="line">  LOG_FORMAT = <span class="string">&quot;%(asctime)s - %(levelname)s - %(message)s&quot;</span></span><br><span class="line">  logging.basicConfig(filename=<span class="string">&#x27;/home/demo/my.log&#x27;</span>, level=logging.DEBUG, format=LOG_FORMAT)</span><br><span class="line">  <span class="keyword">while</span> True:</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    logging.info(<span class="string">&quot;=================start print num: [%s]&quot;</span> % count)</span><br><span class="line">    count += 1</span><br><span class="line">    logging.debug(<span class="string">&quot;This is a debug log.&quot;</span>)</span><br><span class="line">    logging.critical(<span class="string">&quot;This is a critical log.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  print_demo()</span><br></pre></td></tr></table></figure></li><li><p>配置 <code>supervisord.d</code> 下的启动脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@28c67f46fd89 demo]<span class="comment"># cat /etc/supervisord.d/demo-python.ini</span></span><br><span class="line">[program:demo_python]</span><br><span class="line"><span class="built_in">command</span>=python /home/demo/test.py</span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">user=root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该文件更多的配置信息如下：</span></span><br><span class="line">[program:x]：配置文件必须包括至少一个program，x是program名称，必须写上，不能为空</span><br><span class="line"><span class="built_in">command</span>：包含一个命令，当这个program启动时执行</span><br><span class="line">directory：执行子进程时supervisord暂时切换到该目录</span><br><span class="line">user：账户名</span><br><span class="line">startsecs：进程从STARING状态转换到RUNNING状态program所需要保持运行的时间（单位：秒）</span><br><span class="line">redirect_stderr：如果是<span class="literal">true</span>，则进程的stderr输出被发送回其stdout文件描述符上的supervisord</span><br><span class="line">stdout_logfile：将进程stdout输出到指定文件</span><br><span class="line">stdout_logfile_maxbytes：stdout_logfile指定日志文件最大字节数，默认为50MB，可以加KB、MB或GB等单位</span><br><span class="line">stdout_logfile_backups：要保存的stdout_logfile备份的数量</span><br></pre></td></tr></table></figure></li><li><p>校验是否启动成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@28c67f46fd89 ~]<span class="comment"># supervisorctl status</span></span><br><span class="line">demo_python                      RUNNING   pid 12318, uptime 1 day, 22:49:35</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者通过ps和查看日志的内容的办法确认是否正常</span></span><br><span class="line">[root@28c67f46fd89 ~]<span class="comment"># ps aux|grep test</span></span><br><span class="line">hly        552  0.0  0.3  38460  7028 ?        S    10:21   0:00 python /home/demo/test.py</span><br><span class="line">root       570  0.0  0.0   9104   828 pts/3    S+   10:28   0:00 grep --color=auto <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对应日志内容：</span></span><br><span class="line">[root@28c67f46fd89 ~]<span class="comment"># cat /home/demo/my.log</span></span><br><span class="line">2021-11-22 10:23:20,724 - INFO - =================start <span class="built_in">print</span> num: [22]</span><br><span class="line">2021-11-22 10:23:20,724 - DEBUG - This is a debug <span class="built_in">log</span>.</span><br><span class="line">2021-11-22 10:23:20,724 - CRITICAL - This is a critical <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure></li></ol><h3 id="supervisorctl-常用操作"><a href="#supervisorctl-常用操作" class="headerlink" title="supervisorctl 常用操作"></a>supervisorctl 常用操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> supervisor<span class="comment"># 开机自启动</span></span><br><span class="line">systemctl start supervisor<span class="comment"># 启动 supervisord 服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止所有的项目 【用stop停止掉的进程，用reload或者update都不会自动重启】</span></span><br><span class="line">supervisorctl stop all</span><br><span class="line">supervisorctl start all<span class="comment"># 开始所有的项目</span></span><br><span class="line">supervisorctl start xxxx(program_name)<span class="comment"># 开始单个项目</span></span><br><span class="line">supervisorctl restart xxxx(program_name)<span class="comment"># 重启单个项目</span></span><br><span class="line">supervisorctl stop xxxx(program_name)<span class="comment"># 停止单个项目</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tail &lt;name&gt; stderr     查看制定任务启动失败的日志</span></span><br><span class="line">supervisorctl tail demo_python stderr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看项目运行状态</span></span><br><span class="line">supervisorctl status</span><br><span class="line"></span><br><span class="line"><span class="comment"># reread、update、reload的区别</span></span><br><span class="line"><span class="comment"># update 更新新的配置到supervisord（不会重启原来已运行的程序）</span></span><br><span class="line"><span class="comment"># reload 载入所有配置文件，并按新的配置启动、管理所有进程（会重启原来已运行的程序）</span></span><br><span class="line">supervisorctl reread<span class="comment"># 重新加载配置</span></span><br><span class="line">supervisorctl update<span class="comment"># 更新supervisor配置 (更新后看起来会自动重启所有项目)</span></span><br><span class="line">supervisorctl reload<span class="comment"># 重新启动配置中的所有程序</span></span><br></pre></td></tr></table></figure><hr><p><strong>2021/12/1分割线</strong></p><p>最近又遇到一个新的问题：<strong>部分Python服务需要进行虚拟环境的加载，但启动脚本中又不能直接使用source命令。</strong>具体的解决方案如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决办法</span></span><br><span class="line"><span class="comment"># 1. 编写shell脚本进行启动。具体代码如下：</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> /home/demo/ENV/bin/activate</span><br><span class="line"><span class="built_in">exec</span> python3 /home/demo/test.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 编写 cat /etc/supervisord.d/demo-python.ini</span></span><br><span class="line">[program:demo_python]</span><br><span class="line"><span class="built_in">command</span>=/bin/bash /home/demo/start_test.sh</span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">user=root</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://segmentfault.com/a/1190000040021028">supervisor相关操做</a></li><li><a href="https://segmentfault.com/a/1190000039278573">3分钟学会如何上手supervisor看门狗</a></li><li><a href="https://blog.csdn.net/DongGeGe214/article/details/80264811">centos7安装supervisor详细教程</a></li><li><a href="https://www.cnblogs.com/savorboard/p/dotnetcore-supervisor.html">安装参考链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 守护进程 </tag>
            
            <tag> 环境部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《软件测试的艺术》读后感</title>
      <link href="%E8%AF%BB%E5%90%8E%E6%84%9F-%E3%80%8A%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>%E8%AF%BB%E5%90%8E%E6%84%9F-%E3%80%8A%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    公司开始推荐相关阅读书籍，其中有一本书的要求是：“<strong>针对该行业的入门级必读书籍</strong>”，回头一看自己看过很多相关测试的书籍（<strong>囫囵吞枣模式</strong>┑(￣。。￣)┍ ），但确实没法一下说出来哪本书属于入门级必读书籍（毕竟自己刚进入测试行业的时候，完全是来靠自己摸爬滚打，在整个工作经验中慢慢的阅读相关书籍😂，当时也没有想到要针对性的指导自己去学习测试这门技术）。</p><h3 id="入门级人群的定义"><a href="#入门级人群的定义" class="headerlink" title="入门级人群的定义"></a>入门级人群的定义</h3><p>​    入门级必读书籍面对的人群我个人认为大概画像是：<strong>从未接触过测试或刚进入测试行业的人群</strong>（不一定工作年限为0，可能存在其他领域转到测试行业）。</p><a id="more"></a><h3 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h3><p>​    通过网上找了一些相关比较热门的推荐，其中一个是<a href="https://book.douban.com/subject/1445661/">《软件测试的艺术》</a>（豆瓣评分8.4分）。虽然原来也读过，但没有从入门这个维度去思考整本书籍，借此机会又重新阅读了整本书籍。</p><p>​    阅读完后， 根据我已知的国内测试行业的现状以及书内的内容做了以下的一些总结。</p><ul><li>适合入门阅读的章节；</li><li>不适合入门阅读的章节（也可以理解为适合：1～2年测试工作经验的人群，存在一定的测试基础以及相关经验的人群）；</li><li>其他章节（此章节属于通用能力的提升，不一定仅仅适用在测试行业，如果时间允许还是建议阅读）。</li></ul><h3 id="比较适合阅读的章节"><a href="#比较适合阅读的章节" class="headerlink" title="比较适合阅读的章节"></a>比较适合阅读的章节</h3><ul><li><p><strong>章节1：</strong>简单的通过一个简单的小测试，来说明做好测试这件事并不是一个简单的事，从而也间接的体现了测试这个行业的挑战。</p></li><li><p><strong>章节2：从心理学和经济学的层面解释如何进行测试，并且梳理了一系列的软件测试原则</strong>。<br>以下展示个人觉得比较有同感的原则（有兴趣的可以自行阅读相关章节）。</p><ol><li><strong><font color=green>测试用例中必须部分是对输出和结果的定义（是能量化或者有标准能衡量的）</font></strong> ，应该必须包含的两个部分：对程序的输入数据描述以及相应的正确输出结果描述。</li><li><strong><font color=green>应避免测试用例用后即弃，除非软件本身就是一个一次性的软件。</font></strong></li><li><strong><font color=green>程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比。</font></strong></li><li><strong>软件测试是一项极富创造性、极具智力挑战性的工作。</strong></li><li><strong><font color=green>一次成功的测试用例能够发现未知的错误；</font></strong></li></ol><br></li><li><p><strong>章节4：</strong>分别对白盒/黑盒测试的测试用例设计方法进行介绍，但实际网络上有更多翻译的形式（<strong>建议了解到存在此类型的设计方法后，多查看几个网上的样例，最终形成自己的理解</strong>）。<br><strong>白盒测试用例设计方法</strong></p><ul><li>语句覆盖；</li><li>判定覆盖；</li><li>条件覆盖；</li><li>判定/条件覆盖；</li><li>多重条件覆盖。</li></ul><br><p><strong>黑盒测试用例设计方法</strong>（<font color=green>前三种基本属于最常用的，建议深入</font>）</p><ul><li>等价类划分；</li><li>边界值分析；</li><li>错误猜测；</li><li>因果图分析。</li></ul><br></li><li><p><strong>章节6：</strong>比较全面的介绍了除了平时做的功能测试，实际还存在<strong>各种各样的测试类型（比如：安装测试、存储测试、易用性测试等）</strong>，这些测试类型可以去帮助发现那些不常见但又严重的缺陷。<br>在大部分刚入职做测试的同学，可能刚开始做的都是界面上的点点点（当然也有接口测试或者其他方面的测试）。<strong>此章节比较全面的介绍了除了功能测试，还能进行哪些测试。</strong><br>比如（此处未全部列举，有兴趣的可以深入阅读相关章节）：<strong>强度测试、易用性测试、性能测试、存储测试、配置测试、兼容性测试、安装测试等等</strong>。</p></li><li><p><strong>章节9：</strong>更加细致的去介绍了现在互联网下，测试行业面临的一个困难和挑战。<br>具体的难点可以分为以下三个层面（<strong>大部分行业内测试主要集中在表现层以及业务层，业界也有相应的分层测试概念</strong>，有兴趣的可以深入了解）：</p><ul><li>表现层一一主要目的是发现<strong>应用程序的GUI或前端中的错误</strong>。测试点为：<br><strong>内容测试</strong>：包括整体审美、字体、色彩、拼写、内容准确性和默认值；<br><strong>用户环境</strong>：包括浏览器版本和操作系统配置，移动设备的操作系统以及版本等。</li><li>业务层一一主要目的是发现<strong>应用系统的业务逻辑中的错误</strong>。测试点为：<br><strong>数据有效性</strong>：发现从客户那里采集到的数据中的错误；<br><strong>事务</strong>：发现事务处理过程中的错误，包括：信用卡处理、下单处理、打款处理等；<br><strong>业务性能</strong>。</li><li>数据层一一对<strong>应用系统用于存储和获取信息的数据库管理系统的</strong>测试。测试点为：<br><strong>响应时间</strong>： 量化Sql中的 Insert、Update、Delete、Select以及事务的完成时间；<br><strong>数据完整性</strong>：验证数据存储适当且正确；<br><strong>容错性和可恢复性</strong>： 最大化MTBF，最小化MTTR。</li></ul></li></ul><h3 id="不适合阅读的章节"><a href="#不适合阅读的章节" class="headerlink" title="不适合阅读的章节"></a>不适合阅读的章节<br></h3><ul><li><p><strong>章节3</strong>：<strong>详细的介绍了代码检查以及走查两种方法论</strong>，通过该方法可以更加快速的发现问题并解决。<br><strong><font color=red>不推荐的原因</font>：</strong>从已知的经验中，暂未发现有 <strong><font color=red>哪个测试团队</font></strong> 在这方面做的比较好或者是有公开的最佳实践经验。该环节是一个比较繁琐的一个环节（并且现在也出了部分静态扫描工具），即使存在该环节，大部分也是流于形式。</p><p><strong>该章节比较适合开发人员阅读，或者是测试人员阅读后在开发团队进行推广。</strong></p></li><li><p><strong>章节5</strong>：<strong>详细的介绍了如何去进行单元测试</strong>，从更小的模块更快的去发现问题。<br><strong><font color=red>不推荐的原因</font>：</strong>从已知的经验中，暂未发现有 <strong><font color=red>哪个测试团队</font></strong> 在这方面做的比较好或者是有公开的最佳实践经验。大致归于代码内部严重耦合、函数未满足单一功能以及版本迭代过快等原因，导致该环节可能费时且收益小。对于测试来说，该难度较大。</p><p><strong>该章节比较适合开发/专职测试开发的人员进行阅读。</strong></p></li><li><p><strong>章节8</strong>：章节名叫 “极限测试”。<br>一个高大上的名词，但整体看下来属于敏捷迭代中的一个缩略版，<strong>仅包含测试中的单元测试以及验收测试，主要靠程序员本人进行相关测试（<font color=red>看起来都无需测试人员了</font>）</strong>。其中用了一个比较小的 <code>Java</code> 程序进行说明该方法。</p><p><strong>该章节比较适合开发/专职测试开发人员阅读。</strong></p></li></ul><h3 id="其他章节"><a href="#其他章节" class="headerlink" title="其他章节"></a>其他章节</h3><ul><li>章节7：详细的介绍了定位/发现问题根本原因的方法论。通过掌握这些方法论后，可以更得心应手的去深入挖掘问题，而不是简单是只发现某个缺陷的表象。<br>此章节优先级相对较低，可以理解如果想做的更好可以阅读。（这些章节的内容需要花费较多的精力，但收益也比较客观）</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    以上所有内容根据个人经验判断（ <strong><font color=blue>也可能是本人经验比较少，未发现相关好的实践</font></strong> 😂，如果存在不认同的地方欢迎讨论）。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 入门级书籍 </tag>
            
            <tag> 测试基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux install python3</title>
      <link href="Linux-Linux-install-python3/"/>
      <url>Linux-Linux-install-python3/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近比较频繁的在虚拟机上搭建环境，由于默认虚拟机上都是部署的 <code>Python2</code>，所以涉及到了 <code>Python3.7</code> 的安装，此处进行一个过程的记录，方便后续的查看。</p><h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@41c0abcd92d8 tools]<span class="comment"># cat /etc/centos-release</span></span><br><span class="line">CentOS Linux release 7.9.2009 (Core)</span><br><span class="line"></span><br><span class="line">[root@41c0abcd92d8 tools]<span class="comment"># uname -a</span></span><br><span class="line">Linux 41c0abcd92d8 5.10.47-linuxkit <span class="comment">#1 SMP Sat Jul 3 21:51:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><h4 id="方法一：yum-install"><a href="#方法一：yum-install" class="headerlink" title="方法一：yum install"></a>方法一：yum install</h4><p><strong>优点：操作方便，安装快捷。</strong>如果仅需要Python3，但对具体小版本无要求的情况下， <font color=green><strong>推荐该方法</strong></font>。<br><strong>缺点：可选择的版本比较少</strong>。通过以下命令来看，基本上默认的就只有3.6.8的版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可安装的python版本</span></span><br><span class="line">[root@41c0abcd92d8 ~]<span class="comment"># yum --showduplicates list python3 |expand</span></span><br><span class="line">Installed Packages</span><br><span class="line">python3.x86_64                       3.6.8-18.el7                       @updates</span><br><span class="line">Available Packages</span><br><span class="line">python3.i686                         3.6.8-17.el7                       base</span><br><span class="line">python3.x86_64                       3.6.8-17.el7                       base</span><br><span class="line">python3.i686                         3.6.8-18.el7                       updates</span><br><span class="line">python3.x86_64                       3.6.8-18.el7                       updates</span><br><span class="line"></span><br><span class="line">[root@41c0abcd92d8 ~]<span class="comment"># yum list | grep python3</span></span><br><span class="line">python3.x86_64                            3.6.8-18.el7                   @updates</span><br><span class="line">python3-libs.x86_64                       3.6.8-18.el7                   @updates</span><br><span class="line">python3-pip.noarch                        9.0.3-8.el7                    @base</span><br><span class="line">python3-setuptools.noarch                 39.2.0-10.el7                  @base</span><br><span class="line">libselinux-python3.x86_64                 2.5-15.el7                     base</span><br><span class="line">python3.i686                              3.6.8-18.el7                   updates</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="方法二：通过源码安装"><a href="#方法二：通过源码安装" class="headerlink" title="方法二：通过源码安装"></a>方法二：通过源码安装</h4><p>优点：可安装指定 <code>Python3</code> 的任意版本。<br>缺点：相对操作繁琐，需要先安装部分依赖，然后再进行编译安装。<br>具体操作步骤如下：</p><ol><li><p>下载源码文件，推荐通过<a href="https://www.python.org/downloads/source/">官网</a>下载到本机，然后通过 <code>docker cp</code> 的方式复制到容器内。（直接在容器内下载速度可能较慢）</p></li><li><p>解压相应的源码包，此处使用的是 <code>Python-3.7.7</code> 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@41c0abcd92d8 ~]<span class="comment"># tar -xvf Python-3.7.7.tar.xz &amp;&amp; cd Python-3.7.7/</span></span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@41c0abcd92d8 ~]<span class="comment"># ./configure --prefix=/usr/local/python3</span></span><br><span class="line">[root@41c0abcd92d8 ~]<span class="comment"># make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure></li><li><p>软链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@41c0abcd92d8 ~]<span class="comment"># ln -s /usr/local/python3/bin/python3.7 /usr/bin/python3</span></span><br></pre></td></tr></table></figure></li><li><p>修改pip的下载源，国内源下载更快。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.pip &amp; vi ~/.pip/pip.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入如下内容 （pip使用阿里的镜像源下载依赖更快）</span></span><br><span class="line">[global]</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></li></ol><h5 id="源码安装可能遇到的问题"><a href="#源码安装可能遇到的问题" class="headerlink" title="源码安装可能遇到的问题"></a>源码安装可能遇到的问题</h5><p>问题一：未安装gcc，执行上述的步骤时会报错：<code>error: no acceptable C compiler found in $PATH</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc </span><br></pre></td></tr></table></figure><p>问题二：未安装zlib等依赖，执行上述步骤时会报错：<code>zipimport.ZipImportError: can&#39;t decompress data; zlib not available</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel </span><br></pre></td></tr></table></figure><p>问题三：使用pip时报错，报错信息：<code>broken by &#39;SSLError(&quot;Can&#39;t connect to HTTPS URL because the SSL module is not available.&quot;)&#39;: /simple/flask/</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决办法</span></span><br><span class="line"><span class="comment"># 去python3 的源码目录: /.../Python-3.7.7/Modules/Setup文件里修改部分注解。</span></span><br><span class="line"><span class="comment"># 比如我的目录为：/home/tools/Python-3.7.7/Modules, 将下放代码的内容的注解去掉。</span></span><br><span class="line"><span class="comment"># socket line above, and possibly edit the SSL variable:</span></span><br><span class="line">SSL=/usr/<span class="built_in">local</span>/ssl</span><br><span class="line">_ssl _ssl.c \</span><br><span class="line">        -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \</span><br><span class="line">        -L$(SSL)/lib -lssl -lcrypto</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新编译安装</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python list.pop()深入</title>
      <link href="python-Python-list-pop-%E6%B7%B1%E5%85%A5/"/>
      <url>python-Python-list-pop-%E6%B7%B1%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在一次处理Python中List长度为5W+的特殊场景中，发现函数执行时间很长，大概花费了8秒，明显与平时的执行时间存在较大差距（几乎是毫秒级别）。通过Debug后发现具体耗时较多的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(nums) &gt; <span class="number">0</span>:</span><br><span class="line">first_num = nums.pop(<span class="number">0</span>)<span class="comment"># 最终定位到原因在该行代码</span></span><br><span class="line">  <span class="comment"># 对 first_num 进行一系列的处理</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>通常情况下，调用pop()与pop(-1)的时间复杂度都为1，但pop(N) （0&lt;=N&lt;len(list)-1）的时间复杂度却是 N。所以硬生生的把一个原本时间复杂度只有O(n)的变成了O(n<sup>2</sup>)。</p><a id="more"></a><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>通过下方的实验来确认下pop(0)、pop()与通常的索引取值的性能差距。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># compute_consume_time 是自己自定义的一个函数执行耗时的装饰器</span></span><br><span class="line"><span class="meta">@compute_consume_time()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_pop_head</span>(<span class="params">test_list</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(test_list) &gt; <span class="number">0</span>:</span><br><span class="line">        b = test_list.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">@compute_consume_time()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_index_head</span>(<span class="params">test_list</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(test_list):</span><br><span class="line">        b = test_list[i]</span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>对于上述的两个函数进行不同长度的test_list参数传入后的实验结果如下（未进行多次取平均值，耗时会存在一定的误差）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># len(test_list) = 10</span></span><br><span class="line">==== begin list_pop_head===== </span><br><span class="line">current Func [list_pop_head] run time <span class="keyword">is</span> <span class="number">3.814697265625e-05</span></span><br><span class="line">==== begin list_index_head===== </span><br><span class="line">current Func [list_index_head] run time <span class="keyword">is</span> <span class="number">3.814697265625e-06</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># len(test_list) = 10000</span></span><br><span class="line">==== begin list_pop_head===== </span><br><span class="line">current Func [list_pop_head] run time <span class="keyword">is</span> <span class="number">0.008320093154907227</span></span><br><span class="line">==== begin list_index_head===== </span><br><span class="line">current Func [list_index_head] run time <span class="keyword">is</span> <span class="number">5.245208740234375e-06</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当len(test_list) = 500000</span></span><br><span class="line">==== begin list_pop_head===== </span><br><span class="line">current Func [list_pop_head] run time <span class="keyword">is</span> <span class="number">23.494240045547485</span></span><br><span class="line">==== begin list_index_head===== </span><br><span class="line">current Func [list_index_head] run time <span class="keyword">is</span> <span class="number">4.76837158203125e-06</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当len(test_list) = 500000，将 pop(0) 替换为 pop(-1)或pop()后的耗时</span></span><br><span class="line">current Func [list_pop_last_head] run time <span class="keyword">is</span> <span class="number">0.09693312644958496</span></span><br></pre></td></tr></table></figure><p>通过上述实验可以得出如下结论：</p><ul><li>在处理List长度为50W的场景时，<strong>pop(0)的性能已经比直接通过索引的方式</strong>差了将近<strong>500W倍</strong>（23.49/4.76e-06），</li><li>在处理List长度为50W的场景时，<strong>pop(0)比pop()或者pop(-1)的</strong>性能也差了将近<strong>242倍</strong>（23.49/0.0969）。</li></ul><p>原来也没去研究过pop内部的原理，所以一直误以为pop()的时间复杂度都是1。┑(￣。。￣)┍ </p><h3 id="pop-实现原理"><a href="#pop-实现原理" class="headerlink" title="pop 实现原理"></a>pop 实现原理</h3><p>由于pop是内置函数，通过c实现的，<a href="https://github.com/python/cpython/blob/v3.7.0/Objects/listobject.c#L136">具体的实现代码 cPython3.7</a>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*[clinic input]</span></span><br><span class="line"><span class="comment">list.pop</span></span><br><span class="line"><span class="comment">    index: Py_ssize_t = -1</span></span><br><span class="line"><span class="comment">    /</span></span><br><span class="line"><span class="comment">Remove and return item at index (default last).</span></span><br><span class="line"><span class="comment">Raises IndexError if list is empty or index is out of range.</span></span><br><span class="line"><span class="comment">[clinic start generated code]*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">list_pop_impl(PyListObject *self, Py_ssize_t index)</span><br><span class="line"><span class="comment">/*[clinic end generated code: output=6bd69dcb3f17eca8 input=b83675976f329e6f]*/</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(self) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Special-case most common failure cause */</span></span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;pop from empty list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">        index += Py_SIZE(self);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= Py_SIZE(self)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;pop index out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v = self-&gt;ob_item[index];</span><br><span class="line">    <span class="keyword">if</span> (index == Py_SIZE(self) - <span class="number">1</span>) &#123;</span><br><span class="line">        status = list_resize(self, Py_SIZE(self) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> v; <span class="comment">/* and v now owns the reference the list had */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    status = list_ass_slice(self, index, index+<span class="number">1</span>, (PyObject *)<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以得出以下几个点：</p><ul><li>默认情况下, pop() 的默认值是-1，所以pop() 等同于 pop(-1)；</li><li>调用pop()时传入的参数为i（即是后面条件判断中的index的值），如果满足 <code>index == Py_SIZE(self) - 1</code>，代码就直接走 <code>list_resize()</code> 结束了整个函数；</li><li>否则代码会通过 <code>list_ass_slice()</code> 方法。（emm，<font color=red>尝试了下去看该方法然而碰壁了，有点多没太看懂</font>😂）</li></ul><p>网上查了一些解释（个人猜测：<strong>pop本质上是调用了list_ass_slice才会存在时间复杂度从 1 =&gt; N。</strong>）：</p><blockquote><p>pop(0) is slower than pop():<br>When pop is called on the end of the list it takes O(1) but when pop is called on the first element in the list or anywhere in the middle it is O(n). The reason for this lies in how Python chooses to implement lists. When an item is taken from the front of the list, in Python’s implementation, all the other elements in the list are shifted one position closer to the beginning. This may seem silly to you now, but if you look at Table 2 you will see that this implementation also allows the index operation to be O(1). This is a tradeoff that the Python implementors thought was a good one.</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    在平常使用库函数的时候也要注意去了解下自己常用的库函数的时间复杂度，否则可能由于不恰当的使用方式而导致整个代码存在明显的性能瓶颈。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
            <tag> 内置函数 </tag>
            
            <tag> 列表 </tag>
            
            <tag> 性能问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux paping 工具</title>
      <link href="Linux-Linux-paping-%E5%B7%A5%E5%85%B7/"/>
      <url>Linux-Linux-paping-%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近正在风风火火的弄混沌工程😂，在弄到网络延迟、丢包的故障注入时，需要进行故障验证。如果仅仅是网卡层面的话，直接通过 ping 的方式即可，但现在需要的是知道具体某个 <code>IP + PORT</code> 的延迟。</p><p>​    还好在这百试不厌的GOOGLE下，找到了一个小众工具 一一 <a href="https://code.google.com/archive/p/paping/">paping</a>，比较好的解决了我的问题，下面先配一个效果图。</p><img src="https://i.loli.net/2021/10/15/tlLguZ8bhQSMdBO.jpg" alt="paping_linux.jpg" style="zoom:80%;" /><a id="more"></a><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/paping/paping_1.5.5_x86_linux.tar.gz</span><br><span class="line">tar -zvxf paping_1.5.5_x86_linux.tar.gz</span><br></pre></td></tr></table></figure><h3 id="使用中遇到的问题"><a href="#使用中遇到的问题" class="headerlink" title="使用中遇到的问题"></a>使用中遇到的问题</h3><p>在首次安装完后，执行命令 <code>./paping -p 80 -c 5 www.baidu.com </code> 一般都会报错（至少我在两台虚拟机上安装都遇到过如下问题┑(￣。。￣)┍ ）。</p><h4 id="问题一：-lib-ld-linux-so-2-bad-ELF-interpreter-No-such-file-or-directory"><a href="#问题一：-lib-ld-linux-so-2-bad-ELF-interpreter-No-such-file-or-directory" class="headerlink" title="问题一：/lib/ld-linux.so.2: bad ELF interpreter: No such file or directory"></a>问题一：/lib/ld-linux.so.2: bad ELF interpreter: No such file or directory</h4><p>原因：因为虚拟机操作系统是64位的，但该工具中属于32位程序。<br>解决方法：<code>yum install -y glibc.i686</code></p><h4 id="问题二：libstdc-so-6-cannot-open-shared-object-file-No-such-file-or-directory"><a href="#问题二：libstdc-so-6-cannot-open-shared-object-file-No-such-file-or-directory" class="headerlink" title="问题二：libstdc++.so.6: cannot open shared object file: No such file or directory"></a>问题二：libstdc++.so.6: cannot open shared object file: No such file or directory</h4><p>参考链接：<a href="https://stackoverflow.com/questions/11471722/libstdc-so-6-cannot-open-shared-object-file-no-such-file-or-directory">libstdc++.so.6: cannot open shared object file: No such file or directory</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为我的操作系统都是Red hat，所以执行如下命令</span></span><br><span class="line">sudo yum install libstdc++.i686</span><br><span class="line">sudo yum install libstdc++-devel.i686</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是在执行上述的第一条命令时，会触发问题三</span></span><br></pre></td></tr></table></figure><h4 id="问题三：执行-yum-install-libstdc-i686-报错"><a href="#问题三：执行-yum-install-libstdc-i686-报错" class="headerlink" title="问题三：执行 yum install libstdc++.i686 报错"></a>问题三：执行 yum install libstdc++.i686 报错</h4><p>具体报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Error:  Multilib version problems found. This often means that the root</span><br><span class="line">       cause is something <span class="keyword">else</span> and multilib version checking is just</span><br><span class="line">       pointing out that there is a problem. Eg.:</span><br><span class="line"></span><br><span class="line">         1. You have an upgrade <span class="keyword">for</span> libstdc++ <span class="built_in">which</span> is missing some</span><br><span class="line">            dependency that another package requires. Yum is trying to</span><br><span class="line">            solve this by installing an older version of libstdc++ of the</span><br><span class="line">            different architecture. If you exclude the bad architecture</span><br><span class="line">            yum will tell you what the root cause is (<span class="built_in">which</span> package</span><br><span class="line">            requires what). You can try redoing the upgrade with</span><br><span class="line">            --exclude libstdc++.otherarch ... this should give you an error</span><br><span class="line">            message showing the root cause of the problem.</span><br><span class="line"></span><br><span class="line">         2. You have multiple architectures of libstdc++ installed, but</span><br><span class="line">            yum can only see an upgrade <span class="keyword">for</span> one of those architectures.</span><br><span class="line">            If you don<span class="string">&#x27;t want/need both architectures anymore then you</span></span><br><span class="line"><span class="string">            can remove the one with the missing update and everything</span></span><br><span class="line"><span class="string">            will work.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         3. You have duplicate versions of libstdc++ installed already.</span></span><br><span class="line"><span class="string">            You can use &quot;yum check&quot; to get yum show these errors.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       ...you can also use --setopt=protected_multilib=false to remove</span></span><br><span class="line"><span class="string">       this checking, however this is almost never the correct thing to</span></span><br><span class="line"><span class="string">       do as something else is very likely to go wrong (often causing</span></span><br><span class="line"><span class="string">       much more problems).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Protected multilib versions: libstdc++-4.8.5-44.el7.i686 != libstdc++-4.8.5-36.el7_6.2.x86_64</span></span><br></pre></td></tr></table></figure><p>看起来一大堆报错信息一般挺吓人的(<em>▔＾▔</em>) ，不过莫慌！实际只需要执行如下命令即可解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 说白了就是安装依赖libsdc++版本不匹配</span></span><br><span class="line">yum -y install libstdc++</span><br></pre></td></tr></table></figure><p>执行完上述命令后，再执行问题二中的两条命令即可，至此就可以愉快的使用 <code>paping</code> 工具了。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>在linux上使用 <code>paping</code> 工具方式很简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Syntax: paping [options] destination</span><br><span class="line"> </span><br><span class="line">Options:</span><br><span class="line"> -?, --<span class="built_in">help</span>     display usage</span><br><span class="line"> -p, --port N   <span class="built_in">set</span> TCP port N (required)                       // 指定被测试服务的TCP端口（必须）</span><br><span class="line">     --nocolor  Disable color output                            // 屏蔽彩色输出</span><br><span class="line"> -t, --timeout  timeout <span class="keyword">in</span> milliseconds (default 1000)          // 指定超时时长，单位为毫秒，默认为1000</span><br><span class="line"> -c, --count N  <span class="built_in">set</span> number of checks to N                       // 指定测试次</span><br></pre></td></tr></table></figure><h3 id="配合ChaosBlade工具故障注入验证"><a href="#配合ChaosBlade工具故障注入验证" class="headerlink" title="配合ChaosBlade工具故障注入验证"></a>配合ChaosBlade工具故障注入验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本机访问外部 180.101.49.12 机器（ping www.baidu.com 获取到的 IP）80 端口延迟 200ms </span></span><br><span class="line">blade create network delay --time 200 --interface eth0 --remote-port 80 --destination-ip 180.101.49.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用paping 工具来查看指定端口的延时，可以发现指定外部的机器的延迟真实增加了200ms</span></span><br><span class="line">./paping -p 80 -c 5000 180.101.49.12</span><br></pre></td></tr></table></figure><p>⚠️ 注意：如果是超过3秒，则会一直显示connect time out</p><img src="https://i.loli.net/2021/10/15/GksPgQrOHb2t71m.jpg" alt="paping-linux-2.jpg" style="zoom:80%" /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问本机 8080 端口延迟 200ms，延迟时间上下浮动 200ms</span></span><br><span class="line">blade create network delay --time 200 --offset 200 --interface lo --local-port 8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用paping 工具来查看指定端口的延时 </span></span><br><span class="line">./paping -p 8080 -c 5000 127.0.0.1</span><br></pre></td></tr></table></figure><p>⚠️ 在本机验证本机的延迟， 原因是在本地验证本地不是走eth0的网口，而是走lo网口，通过如下方式可以在本地验证</p><img src="https://i.loli.net/2021/10/15/EKzNxsp7VJifP3R.jpg" alt="paping-linux-3.jpg" style="zoom:80%" />]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> TCP 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《代码整洁之道》读后感</title>
      <link href="%E8%AF%BB%E5%90%8E%E6%84%9F-%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>%E8%AF%BB%E5%90%8E%E6%84%9F-%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    公司的测试工具平台开发也快一年了，积累的功能也越来越多，最近刚好需要对测试用例平台模块的相关功能进行修改。 修改的过程真的是痛苦。。。虽然原来已经看过一遍clean code了，但时间久了又回到了老样子。。。</p><blockquote><p>我们趟过代码的水域。我们穿过灌木密布、瀑布暗藏的沼泽地。我们拼命想找到出路，期望有点什么线索能启发我们到底发生了什么事；<strong>但目光所及，只是越来越多死气沉沉的代码。</strong> 一一 代码整洁之道</p></blockquote><p>​    整本书看完后，并不觉得所有的东西都一定要按照书中的来做，但有以下的一些经验还是可以参考和采纳的。</p><a id="more"></a><h3 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h3><h4 id="名副其实"><a href="#名副其实" class="headerlink" title="名副其实"></a>名副其实</h4><p>选个好名字要花时间，但省下来的时间比花掉的多。注意命名，而且一旦发现有更好的名称，就换掉旧的。如果<strong>名称需要注释来补充，那就不算是名副其实</strong>。</p><p>❌ <strong>错误实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d; <span class="comment">// 消逝的时间，以日计</span></span><br></pre></td></tr></table></figure><p>✅ <strong>正确实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> elapsedTimeInDays; </span><br><span class="line"><span class="keyword">int</span> daysSinceCreation; </span><br><span class="line"><span class="keyword">int</span> daysSinceModification; </span><br></pre></td></tr></table></figure><h4 id="避免误导"><a href="#避免误导" class="headerlink" title="避免误导"></a>避免误导</h4><p>别用accountList来指称一组账号，除非它真的是List类型。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。 <strong><font color=red>特别是用小写字母l和大写字母O作为变量名。</font></strong></p><p>❌ <strong>错误实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = l;</span><br><span class="line"><span class="keyword">if</span> (O == l) </span><br><span class="line">  a = O1; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  l = <span class="number">01</span>;</span><br></pre></td></tr></table></figure><h4 id="做有意义的区分"><a href="#做有意义的区分" class="headerlink" title="做有意义的区分"></a>做有意义的区分</h4><p>以数字系列命名（a1、a2，……aN）是依义命名的对立面。这样的名称纯属误导——<strong>完全没有提供正确信息</strong>；</p><p>❌ <strong>错误实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyChars</span><span class="params">(<span class="keyword">char</span> a1[], <span class="keyword">char</span> a2[])</span> </span>&#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a1.length; i++) &#123; </span><br><span class="line">    a2[i] = a1[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <strong><font color=blue>参数名改为source和destination，这个函数就会像样许多。</font></strong> </p><h4 id="使用能读出来的名称"><a href="#使用能读出来的名称" class="headerlink" title="使用能读出来的名称"></a>使用能读出来的名称</h4><p>尽量避免使用缩写。。。大部分情况，没人知道你这个缩写是怎么缩的。</p><p>❌ <strong>错误实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DtaRcrd102</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> Date genymdhms; </span><br><span class="line">  <span class="keyword">private</span> Date modymdhms; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String pszqint = <span class="string">&quot;102&quot;</span>; <span class="comment">/* ... */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>✅ <strong>正确实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Date generationTimestamp; </span><br><span class="line">  <span class="keyword">private</span> Date modificationTimestamp;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String recordId = <span class="string">&quot;102&quot;</span>; <span class="comment">/* ... */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a>使用可搜索的名称</h4><p>很多时候不一定记得方法或者变量名在哪个地方，可能需要通过搜索关键词来进行搜索。此时<strong>找STUDENT_ID很容易，但想找数字7就麻烦了。</strong></p><p>❌ <strong>错误实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">34</span>; j++) &#123; s += (t[j]*<span class="number">4</span>)/<span class="number">5</span>; &#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>正确实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> realDaysPerIdealDay = <span class="number">4</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> WORK_DAYS_PER_WEEK = <span class="number">5</span>; </span><br></pre></td></tr></table></figure><h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><p>类名和对象名应该是名词或名词短语。</p><p>✅ <strong>正确实例</strong>：如 <code>Customer、WikiPage、 Account和AddressParser</code></p><p>❌ <strong>错误实例</strong>：如 <code>Manager、Processor</code></p><h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>方法名应当是动词或动词短语。</p><p>✅ <strong>正确实例</strong>：如 <code>如postPayment、deletePage或 save。</code></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="短小"><a href="#短小" class="headerlink" title="短小"></a>短小</h4><p>函数不应该大到足以容纳嵌套结构。建议：<font color=green><strong>函数的缩进层级不该多于一层或两层</strong></font>。这样的函数易于阅读和理解。</p><p>PS：<strong>根据个人经验，只要这个函数超过了30行。。。过一两个月，基本就没办法一眼就能看明白该函数里面做了什么。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_service_instance</span>(<span class="params">namespace, service_name, new_instance_name, deploy_func</span>):</span></span><br><span class="line">    url = build_url(namespace, service_name, delete_template_url, instance_name=new_instance_name)</span><br><span class="line"></span><br><span class="line">    payload = &#123;&#125;</span><br><span class="line">    response = deploy_func(url, headers=common_headers, data=payload)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h4 id="只做一件事"><a href="#只做一件事" class="headerlink" title="只做一件事"></a>只做一件事</h4><p>尽量把逻辑相关的操作都抽象到一个函数内，这也比较容易满足只做一件事。（但事情又可大可小，所以这个看自己去把控了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求给定数中的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_even_by_num</span>(<span class="params">num</span>):</span></span><br><span class="line">  <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述代码优化， 比如还需要对num进行参数校验，那么就应该抽象出一个通用的数值类型的参数校验。</span></span><br><span class="line"><span class="comment"># 实现某个业务中的指定功能。。。（大部分就是这种场景，容易把函数写的很大）</span></span><br></pre></td></tr></table></figure><h4 id="每个函数一个抽象层级"><a href="#每个函数一个抽象层级" class="headerlink" title="每个函数一个抽象层级"></a>每个函数一个抽象层级</h4><p><strong>可以简单理解 ：实现的细节以及步骤。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部是步骤</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">includeSetupAndTeardownPages</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">  includeSetupPages(); </span><br><span class="line">  includePageContent(); </span><br><span class="line">  includeTeardownPages(); </span><br><span class="line">  updatePageContent(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 细节</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SetupTeardownIncluder</span><span class="params">(PageData pageData)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.pageData = pageData; </span><br><span class="line">  testPage = pageData.getWikiPage(); </span><br><span class="line">  pageCrawler = testPage.getPageCrawler(); </span><br><span class="line">  newPageContent = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别重复自己"><a href="#别重复自己" class="headerlink" title="别重复自己"></a>别重复自己</h4><h4 id="抽离出Try-Catch代码"><a href="#抽离出Try-Catch代码" class="headerlink" title="抽离出Try/Catch代码"></a>抽离出Try/Catch代码</h4><p>✅ <strong>正确实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Page page)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    deletePageAndAllReferences(page); </span><br><span class="line">  &#125;<span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">    logError(e); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释不能美化糟糕的代码， <strong><font color=red>写注释的常见动机之一是糟糕的代码的存在。</font></strong></p><p>我们编写一个模块，发现<strong>它令人困扰、乱七八糟。</strong>我们知道，它烂透了。<strong>我们告诉自己：“喔，最好写点注释！”</strong>。。不然过段时间都不知道这函数是在干嘛。。。😂</p><h4 id="好注释"><a href="#好注释" class="headerlink" title="好注释"></a>好注释</h4><ul><li>提供信息的注释，返回某个方法具体的返回值类型以及大致数据格式；</li><li>对意图的解释；</li><li>警示；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don&#x27;t run unless you </span></span><br><span class="line"><span class="comment">// have some time to kill.</span></span><br></pre></td></tr></table></figure></li><li>TODO注释；</li><li>公共API或者方法中的Javadoc；</li></ul><h4 id="坏的注释"><a href="#坏的注释" class="headerlink" title="坏的注释"></a>坏的注释</h4><ul><li><p>多余的注释，把方法实现的逻辑解释了一遍；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utility method that returns when this.closed is true. Throws an exception </span></span><br><span class="line"><span class="comment">// if the timeout is reached. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitForClose</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(!closed) &#123;</span><br><span class="line">    wait(timeoutMillis);</span><br><span class="line">    <span class="keyword">if</span>(!closed) </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;MockResponseSender could not be closed&quot;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>误导性注释</strong>，很多时候表达的意思可能不是代码中真正实现的意思，或者由于很久未维护导致注释与真实内容不一致；</p></li><li><p>日志式注释；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* Changes (from <span class="number">11</span>-Oct-<span class="number">2001</span>) </span><br><span class="line">* -------------------------- </span><br><span class="line">* <span class="number">11</span>-Oct-<span class="number">2001</span> : Re-organised the <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">moved</span> <span class="title">it</span> <span class="title">to</span> <span class="title">new</span> <span class="title">package</span> * <span class="title">com</span>.<span class="title">jrefinery</span>.<span class="title">date</span> (<span class="title">DG</span>)</span>; </span><br><span class="line">* <span class="number">05</span>-Nov-<span class="number">2001</span> : <span class="function">Added a <span class="title">getDescription</span><span class="params">()</span> method, and eliminated NotableDate * <span class="title">class</span> <span class="params">(DG)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><strong>废话注释</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The day of the month. */</span> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> dayOfMonth;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * Returns the day of the month. </span></span><br><span class="line"><span class="comment">** <span class="doctag">@return</span> the day of the month. */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDayOfMonth</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> dayOfMonth; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>长期注释掉的代码</strong>；</p></li><li><p><strong>信息过多 or 不明显的联系</strong>；<br>过滤器字节是什么？与那个+1 有关系吗？或与*3 有关？还是与两 者皆有关？为什么用200？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * start with an array that is big enough to hold all the pixels </span></span><br><span class="line"><span class="comment">* (plus filter bytes), and an extra 200 bytes for header info */</span> </span><br><span class="line"><span class="keyword">this</span>.pngBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[((<span class="keyword">this</span>.width + <span class="number">1</span>) * <span class="keyword">this</span>.height * <span class="number">3</span>) + <span class="number">200</span>];</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>避免测试不足；</li><li>采用覆盖率工具；</li><li>别掠过小测试；</li><li>被忽略的测试就是对不确定事物的疑问；</li><li>测试边界条件；</li><li>全面测试相近的缺陷 ；</li><li>测试失败的模式有启发性；</li><li>测试应该快速 。</li></ul><h3 id="如何写出上面所述的代码呢？"><a href="#如何写出上面所述的代码呢？" class="headerlink" title="如何写出上面所述的代码呢？"></a>如何写出上面所述的代码呢？</h3><p>​    写代码和写别的东西很像。在写论文或文章时，你先想什么就写什么，然后再打磨它。初稿也许粗陋无序，你就斟酌推敲，直至达到你心目中的样子。 </p><p>​    写函数时，<strong>一开始都冗长而复杂。有太多缩进和嵌套循环。有过长的参数列表。名称是随意取的，也会有重复的代码。</strong></p><p>​    然后还需要做的：</p><ul><li><strong>配上一套单元测试，覆盖每行丑陋的代码</strong>；</li><li><strong>然后打磨这些代码，分解函数、修改名称、消除重复</strong>，同时保持测试通过；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 快速编写单测实践</title>
      <link href="python-Python-%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99%E5%8D%95%E6%B5%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>python-Python-%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99%E5%8D%95%E6%B5%8B%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    作为一名测试，对自己写的代码就更加需要保障质量了😂。。。但又不可能每次和业务一样，每次改动后都通过手工测试去覆盖，此时便想到了单测/接口来保障测试自己开发的功能。</p><p>​    但现在互联网公司，不管是开发还是测试的代码的单测覆盖率普遍不高，或者说编写单测不是一个普遍的现象。    具体原因可以先来查看一段代码，实现的功能是：<strong>在指定的 Jenkins server 上根据用户自定义的参数来构建指定的Job任务</strong>，代码的格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_job</span>(<span class="params">cls, job_name, server=<span class="literal">None</span>, params=<span class="literal">None</span></span>):</span></span><br><span class="line">  server = server <span class="keyword">or</span> cls.server</span><br><span class="line">  params = params <span class="keyword">or</span> <span class="built_in">dict</span>()</span><br><span class="line">  status = cls.get_job_status(job_name, server)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> status <span class="keyword">and</span> cls.check_task_status(job_name, server):</span><br><span class="line">    server.build_job(job_name, parameters=params)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;开始执行&quot;</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;已存在正在执行中的任务, 请勿重复执行&quot;</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>大致一看这块代码也没什么问题（<em>忽略参数校验</em>），但实际需要<font color=red><strong>进行调试或者单测的时候就存在两个比较明显的问题</strong></font>：</p><ul><li>else 后面执行的代码，场景不好构建，需要Mock部分外部依赖，如：<code>cls.get_job_status(job_name, server)</code>、<code>cls.check_task_status(job_name, server)</code>；</li><li>为了避免真实的去执行指定的Job，需要Mock <code>server.build_job(job_name, parameters=params)</code>；</li></ul><p><strong>这还仅仅是一个10行不到的代码，就需要写这么多Mock。想想那些真实的业务场景，这得多痛苦╮(╯Д╰)╭ 。。。</strong>（猜测这也是大部分公司不写单测的原因吧。）</p><p>那如何在不通过编写过多的Mock的情况下，来<strong>快速有效的对自己的代码进行调试以及编写单测</strong>呢？个人通过<font color=blue><strong>函数式编程</strong></font>找到了看似有效的一种思路。先简单的介绍下一一函数式编程（可参考：<a href="https://docs.python.org/zh-cn/3/howto/functional.html#">Python 函数式编程</a>）。</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>通常编程语言支持通过以下几种方式来解构具体问题：</p><ul><li><p><strong>面向过程</strong><br>比如要实现面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用分别的函数来实现，问题就解决了。</p></li><li><p><strong>面向对象</strong><br>在日常生活或编程中，简单的问题可以用面向过程的思路来解决，直接有效，但是当问题的规模变得更大时，用面向过程的思想是远远不够的。此时就需要通过面相对象来进行抽象和封装。</p><p>面向对象可以简单的理解：<strong>万物皆对象</strong>😂。。。把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙<strong>某个对象在整个解决问题的步骤中的属性和行为。</strong></p></li><li><p><strong>面向切面</strong> （JAVA中的AOP和Python中的装饰器）等等。</p></li><li><p><font color=blue><strong>函数式</strong></font> 编程则将一个问题分解成一系列函数，可以理解<strong>属于面向过程编程</strong>。 理想情况下，<font color=blue><strong>函数只接受输入并输出结果，对一个给定的输入也不会有影响输出的内部状态。</strong></font> </p></li></ul><p>在大型程序中（普遍方式是：面相对象），然而在程序内部，不同的部分可能会采用不同的方式编写；比如 <strong><font color=blue>处理逻辑则是面向过程、日志打印以及权限控制等则是面向切面等。</font></strong></p><p>⚠️ 注意：上述内容写的比较简略，未看懂也没关系，只是简单的引入了相关的概念，有兴趣的可自行阅读。</p><h3 id="理想情况"><a href="#理想情况" class="headerlink" title="理想情况"></a>理想情况</h3><p>​    <strong>最容易理解最容易编写的单测，莫过于独立函数的单测。</strong>所谓独立函数，就是<strong>只依赖于传入的参数，不修改任何外部状态的函数。指定输入，就能确定地输出相应的结果。运行任意次，都是一样的。</strong>在函数式编程中，有一个特别的术语：“引用透明性”，也就是说，可以使用函数的返回值彻底地替代函数调用本身。独立函数常见于工具类及工具方法。</p><p>函数式编程的核心在于：<font color=red><strong>每个函数的输出必须只依赖于输入，输入如果是固定的那么输出一定是固定的。</strong></font></p><p>函数式风格有其理论和实践上的优点：</p><ul><li><p><a href="https://docs.python.org/zh-cn/3.7/howto/functional.html#formal-provability">形式证明</a></p></li><li><p><strong>模块化。</strong><br>它强制你把问题分解成小的方面。因此程序会更加模块化。相对于一个进行了复杂变换的大型函数，一个小的函数更明确，更易于编写, 也更易于阅读和检查错误。</p></li><li><p><strong>组合性。</strong></p></li><li><p><strong>易于调试和测试。</strong><br><strong>调试很简单是因为函数通常都很小而且清晰明确。</strong>当程序无法工作的时候，每个函数都是一个可以检查数据是否正确的接入点。你可以通过查看中间输入和输出迅速找到出错的函数。</p><p>测试更容易是因为每个函数都是单元测试的潜在目标。在执行测试前，函数并不依赖于需要重现的系统状态；相反，你<strong>只需要给出正确的输入，然后检查输出是否和期望的结果一致。</strong></p></li></ul><p>函数式编程就是一种抽象程度很高的编程范式，<font color=red><strong>纯粹的函数式编程语言编写的函数没有变量（没有使用不固定的局部变量或者修改全局变量）</strong></font>，因此，<strong>任意一个函数，只要输入是确定的，输出就是确定的</strong>，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 理想情况下的独立代码如下：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_nums</span>(<span class="params">a, b</span>):</span></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 现实代码如下（由于存在随机的变量c, 此时没办法控制输入固定的a、b, 返回值结果一定是某个值）：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_nums</span>(<span class="params">a, b</span>):</span></span><br><span class="line">  <span class="keyword">import</span> random</span><br><span class="line">  c = random.randint(<span class="number">1</span>, <span class="number">19</span>)</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br></pre></td></tr></table></figure><h3 id="现实"><a href="#现实" class="headerlink" title="现实"></a>现实</h3><p>​    现实常常没有这么美好。应用<strong>要读取外部配置</strong>，<strong>要依赖外部服务获取数据进行处理等</strong>（就如同上述代码中的 <code>c = random.randint(1, 19)</code> ，c是不可控的），导致应用似乎无法单纯地 “<strong>通过固定输入得到固定输出</strong>“。</p><p>导致这个现象的原因：</p><ul><li><strong>轻率地引用外部实例变量或状态或函数</strong>，使得本来纯粹的函数或方法变得不那么”<strong>纯粹</strong>“了；</li><li><strong>函数的功能不够单一（比如一个求和的方法，里面还有各种其他与求和不太相关的代码存在）</strong>；</li><li>其他因素等。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>通过吸取函数式编程中的概念，提取出如下两个点来优化函数的实现：</p><ol><li><font color=blue><strong>函数内引用外部依赖的函数的返回值时， 将外部函数转化为函数参数； 函数内引用外部依赖的函数，将外部函数转化为函数参数。</strong></font></li><li><font color=blue><strong>尽可能的拆分每个函数为一个比较单独的函数。</strong></font></li></ol><p>比如文章最初的Demo代码，可以进行如下的改造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_job</span>(<span class="params">cls, job_name, server=<span class="literal">None</span>, params=<span class="literal">None</span></span>):</span></span><br><span class="line">  server = server <span class="keyword">or</span> cls.server</span><br><span class="line">  params = params <span class="keyword">or</span> <span class="built_in">dict</span>()</span><br><span class="line">  status = cls.get_job_status(job_name, server)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> status <span class="keyword">and</span> cls.check_task_status(job_name, server):</span><br><span class="line">    server.build_job(job_name, parameters=params)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;开始执行&quot;</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;已存在正在执行中的任务, 请勿重复执行&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 改造后的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_job</span>(<span class="params">cls, job_name, start_job_func, params=<span class="literal">None</span>, status=<span class="literal">False</span>, task_queue_status=<span class="literal">False</span></span>):</span></span><br><span class="line">  params = params <span class="keyword">or</span> <span class="built_in">dict</span>()</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> status <span class="keyword">and</span> task_queue_status:</span><br><span class="line">    start_job_func(job_name, parameters=params)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;开始执行&quot;</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;已存在正在执行中的任务, 请勿重复执行&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>具体的改动点如下：</strong></p><ol><li><p><code>cls.get_job_status(job_name, server)</code> 和 <code>cls.check_task_status(job_name, server)</code> 优化成函数变量。<br>该函数是去获取指定Job的执行状态，只会返回True/False，完全可以通过将外部变量转化为函数参数来解决。这样就可以通过函数参数直接控制 True/False 的状态，避免去构造一个真实的Job执行或未执行的场景。</p><p>同理 <code>cls.check_task_status(job_name, server)</code> 需要构建Job在Jenkins的队列中，这样实际场景中更加难以构建。通过优化成函数变量后极大的降低了构建的难度。</p></li><li><p><code>server.build_job(job_name, parameters=params)</code> 优化为函数变量。<br>该函数一定会去进行真实的触发Job，所以在跑单测的时候，需要mock处理。该接口存在如下场景：</p><ul><li>函数执行成功，代码继续往下执行；（对被测函数 <code>start_job</code> 无影响）</li><li>函数执行失败，内部抛出异常或者错误信息；（被测函数 <code>start_job</code> 只需继续往上抛异常即可，也无影响）</li></ul><p>所以也可以将该函数直接作为一个参数传给被测函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_job</span>(<span class="params">cls, job_name, start_job_func, params=<span class="literal">None</span>, status=<span class="literal">False</span>, task_queue_status=<span class="literal">False</span></span>):</span></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> status <span class="keyword">and</span> task_queue_status:</span><br><span class="line">    start_job_func(job_name, parameters=params)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>通过如上的改动，在单测代码中就可以直接定义一个假的 <code>start_job_func</code> 不做任何操作/抛出异常， 然后进行断言后面的代码或者抛出异常的场景即可。</p></li></ol><p>由于Demo代码的行数比较少，并且逻辑相对单一，此处就未进行函数拆分。但对于大部分的业务代码，实际都可以进行更小的拆分，去保障每个函数的功能单一。</p><p><strong>最终的改造代码的效果：</strong></p><ul><li><strong>利一一单测以及其他方法组合和调试都很方便，仅需要通过变量直接来控制逻辑条件的执行。</strong></li><li><strong>弊一一其他方法来调用的时候需要传递很多的变量（当然可以通过再次拆分，将该方法更加的细化）。</strong></li></ul><p>​    当然这块在 “纯粹” 的函数式编程以及平常的过程式/面向对象编程等其他方式中是可以进行一定的取舍的。比如已经有一个更小的函数A符合输入固定，并且输出固定， 那么<strong>在代码量没有明显增加以及不破坏函数的单一性的情况下，函数B去引用A的时候则无需将其进行参数化</strong>。</p><h3 id="Pytest-cov-代码覆盖率工具"><a href="#Pytest-cov-代码覆盖率工具" class="headerlink" title="Pytest-cov 代码覆盖率工具"></a>Pytest-cov 代码覆盖率工具</h3><p>​    通过上述的方法去优化了部分核心代码后，在编写单测用例的时候也简单很多。 此处使用的覆盖率统计工具是 <a href="https://github.com/pytest-dev/pytest-cov/">Pytest-cov</a>。常用的参数如下（通过创建一个python脚本来执行对应的覆盖代码）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&quot;--cov=src/common_utils&quot;</span>, <span class="string">&quot;--cov=src/services/test_case_online&quot;</span>, <span class="string">&quot;--cov-config=.coveragerc&quot;</span>, <span class="string">&quot;--cov-report=html:cov_html&quot;</span>, <span class="string">&quot;--cov-branch&quot;</span>])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如下内容为 .coveragerc 文件中的内容</span></span><br><span class="line"><span class="comment"># 忽略omit变量中文件的覆盖率，如：tests/ 以及所有目录下的 __init__.py 文件</span></span><br><span class="line">[run]</span><br><span class="line">omit =</span><br><span class="line">    tests/*</span><br><span class="line">    */__init__.py</span><br></pre></td></tr></table></figure><ul><li>--cov：需要统计覆盖率的文件目录（可指定多个）；</li><li>--cov-config：用户自定义的配置文件；</li><li>--cov-report：覆盖率报告生成的格式，此处选择html格式，并且存储在名为cov_html的文件夹下；</li><li>--cov-branch：开启分支覆盖率统计（默认关闭）；</li></ul><p>更多内容可参考：<a href="https://pytest-cov.readthedocs.io/en/latest/config.html">Pytest-cov 官网文档</a>，实际使用后的效果如下：</p><img src="https://i.loli.net/2021/07/20/xVNd3cYJFp5onRs.jpg" alt="pytest-cov-2.jpg" style="" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    该方法并不能永久的解决编写单测的难度，但是从个人实践下来的最终效果，几乎满足了80%的场景的单测覆盖度（唯一的缺点就是：需要像上面代码中去描述较多的参数）。如有其他更好的办法欢迎。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.python.org/zh-cn/3/howto/functional.html#">Python 函数式编程</a></p><p><a href="https://pytest-cov.readthedocs.io/en/latest/config.html">Pytest-cov 官网文档</a></p><p><a href="https://www.cnblogs.com/lovesqcc/p/6917448.html">使用Java函数接口及lambda表达式隔离和模拟外部依赖更容易滴单测</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 单元测试 </tag>
            
            <tag> 函数式编程 </tag>
            
            <tag> Pytest-cov </tag>
            
            <tag> 代码覆盖率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《谈话的力量》读后感</title>
      <link href="%E8%AF%BB%E5%90%8E%E6%84%9F-%E3%80%8A%E8%B0%88%E8%AF%9D%E7%9A%84%E5%8A%9B%E9%87%8F%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>%E8%AF%BB%E5%90%8E%E6%84%9F-%E3%80%8A%E8%B0%88%E8%AF%9D%E7%9A%84%E5%8A%9B%E9%87%8F%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    <strong>多数人认为，一些人天生就有说话的天赋，而一些人则没有。事实上，并不存在说话的天赋这一说。善于交谈的人只不过是懂得一些简单的技艺而已，而这些技艺是可以通过反复练习而学会的。</strong></p><p>​    通过阅读完《谈话的力量》后，<strong>部分方法确实可以帮助缓解一些沟通中遇到的问题</strong>😂，比如：</p><ul><li>无法开始一段与陌生人的谈话；</li><li>无法恰当的表达自己的想法；</li><li>与别人交谈时，很容易产生矛盾和争吵。</li></ul><p>在此进行一个读后感记录，方便后续回顾（虽然学到的技巧并没有立竿见影，但至少从某个程度上影响了自己的思维）。</p><a id="more"></a><h3 id="章节简介"><a href="#章节简介" class="headerlink" title="章节简介"></a>章节简介</h3><p>本书一共13章，个人看完后，从个人见解上划分为如下几个模块：<br>（PS：此处模块划分为个人理解的层面去划分，如有不当欢迎吐槽=￣ω￣=。。。）</p><ul><li><strong>如何开始一段谈话</strong><ul><li>第一章：通过提问题促进交流；</li><li>第四章：利用自由信息；</li><li>第五章：让别人知道你；</li><li>第六章：开始一段谈话。</li></ul></li><li><strong>如何有效的表达对于他人的认可</strong><ul><li>第二章：表达诚实的称赞；</li></ul></li><li><strong>如何处理交谈中可能的矛盾</strong><ul><li>第三章：倾听别人的话语；</li><li>第七章：发出可能被接受的邀请；</li><li>第八章：积极地接受批评；</li><li>第九章：拒绝别人的操纵； （<em>个人感觉一般，该章节未总结</em>）</li><li>第十章：要求改变。</li></ul></li><li><strong>交谈过程中的一些细节</strong><ul><li>第十一章：通过动作表情达意；</li><li>第十二章：减少社交场合中的紧张；</li></ul></li><li><strong>有计划地去努力。</strong> </li></ul><h3 id="模块详解"><a href="#模块详解" class="headerlink" title="模块详解"></a>模块详解</h3><h4 id="（一）、如何开始一段谈话"><a href="#（一）、如何开始一段谈话" class="headerlink" title="（一）、如何开始一段谈话"></a>（一）、如何开始一段谈话</h4><p>​    俗话说：养兵千日，用兵一时。<strong>如果光是去学习各种理论，但是从来没有去实践过也意义不大。因为你学的理论都是别人的经验，不一定适用于你身上。</strong> </p><p>重新调整了书中章节的内容，可以理解为要开始一段谈话，大致的流程应该如下：</p><p><font color=blue><strong>开始一段谈话 ==&gt; 让别人知道你 ==&gt; 通过提问题促进交流 ==&gt; 利用自由信息持续谈话</strong></font></p><p>对于整个流程中，可以理解 “开始一段谈话” 和 “让别人知道你” 都属于开始，有了一个好的开始后，必须有精彩的后续才能维持这个谈话。所以<strong>核心点</strong>就在于：<font color=red><strong>“通过提开放式问题促进交流”</strong></font> 以及 <font color=red><strong>“利用自由信息来重复提开放式问题促进交流”</strong></font>。</p><img src="https://i.loli.net/2021/07/19/9CwMJcRzfh5bQko.jpg" alt="谈话的力量-1-new.jpg" style="zoom:40%;" /><h4 id="（二）、如何有效的表达对于他人的认可"><a href="#（二）、如何有效的表达对于他人的认可" class="headerlink" title="（二）、如何有效的表达对于他人的认可"></a>（二）、如何有效的表达对于他人的认可</h4><p>​    很多时候，<strong>当周围的人让我们高兴的时候，多数人会不以为然，认为本该如此。</strong>只有<font color=red><strong>当别人做的事情不合我们的意愿时，我们才会注意到他们——而且是非常迅速地！然后我们进行批评，并细致地解释为什么他们的行为是“不好”或“错误”的。</strong></font></p><p>忽视你喜欢的做法却对你不喜欢的做法进行惩罚，这样做会让自己的生活变得越来越压抑（因为每天可能发生的都不合自己的意愿）。<br><strong>解决办法</strong>：有效的鼓励对方继续按照你喜欢的方式做事，能够让他们对你产生好感。 再通过循环这个过程让大家都更加愉快。<br>⚠️ PS：但这个理论不是百分之百的，<font color=red>不一定行为被鼓励了就一定会按照你喜欢的方式做事，</font> 只能理解成这样的事发生概率更大而已。</p><img src="https://i.loli.net/2021/07/21/8QjZ6RcHy5rXMFN.jpg" alt="谈话的力量-2.jpg" style="zoom:50%;" /><h4 id="（三）、如何处理交谈中可能的矛盾"><a href="#（三）、如何处理交谈中可能的矛盾" class="headerlink" title="（三）、如何处理交谈中可能的矛盾"></a>（三）、如何处理交谈中可能的矛盾</h4><p>根据谈话的力量书中的内容，总结了下在大部分的交谈中产生的矛盾，主要原因是产生在：</p><ul><li>未了解对方的真实意图；</li><li>极力反驳别人给自己的批评或者建议；</li><li>提出了超出别人能接受的请求；</li><li>不恰当的表达自己的不满或者建议。</li></ul><p>主要的问题以及解决方法如下（顺序分别与上述的原因一一对应）：</p><p><img src="https://i.loli.net/2021/07/21/rjyekNMx4L1SFRa.jpg" alt="谈话的力量-3-new.jpg"></p><h4 id="（四）、交谈中的一些细节"><a href="#（四）、交谈中的一些细节" class="headerlink" title="（四）、交谈中的一些细节"></a>（四）、交谈中的一些细节</h4><p>​    除了上述的一些方法之外， 在交谈中还有很多细节需要注意。比如交谈中的各种动作：<br>​    <strong>握手</strong> 、<strong>体态</strong> 、<strong>表情</strong> 、<strong>外表</strong> 、<strong>语调</strong> 、<strong>发型</strong> 、<strong>衣着</strong> 、<strong>眼神</strong> 、<strong>微笑</strong> 、<strong>身体距离</strong> 、<strong>倾听方式</strong> 、<strong>你的自信</strong> 、<strong>你的呼吸</strong>、… 等</p><p>​    <strong>大多数人经常无意识地做一些与自己说的话相互矛盾的动作，妨碍了交流的顺利进行</strong>。因为<font color=red><strong>非语言的行为被作为意识之外的举动．所以当它与你的话语矛盾时，人们几乎总是倾向于相信你的非语言信息。</strong></font><br>​    除了交谈中的动作，还有个人的心理，比如交谈 过程中一直处于（<strong>紧张、焦虑、恐惧或者逃避的心理</strong>），此次谈话也不会好到哪里去。</p><p><img src="https://i.loli.net/2021/07/21/9V6DmhUEgqtZjC3.jpg" alt="谈话的力量-4.jpg"></p><h4 id="（五）、有计划地去努力"><a href="#（五）、有计划地去努力" class="headerlink" title="（五）、有计划地去努力"></a>（五）、有计划地去努力</h4><p>​    <font color=red><strong>也许在追求理想的目标的过程中，最痛苦的一点就是永远也得不到一个目标实现后的成就感。</strong> </font>可以理解这个所谓的目标实际并不是你的目标。</p><img src="https://i.loli.net/2021/07/21/AsHzD6cVTpm5jKb.jpg" alt="谈话的力量-5.jpg" style="zoom:53%;" /><h3 id="语录收集"><a href="#语录收集" class="headerlink" title="语录收集"></a>语录收集</h3><ul><li><strong>每个人都能提问题，但并不等于人人都会提问题。</strong></li><li><strong>当周围的人让我们高兴的时候，多数人会不以为然，认为本该如此</strong>；只有当<strong>别人做的事情不合我们的意愿时，我们才会注意到他们——而且是非常迅速地</strong>！然后我们进行批评，并细致地解释为什么他们的行为是“不好”或“错误”的，为什么他们要照我们说的去做。</li><li><strong>人性中最深刻的本能就是被欣赏的渴望。</strong></li><li><strong>我们说出来的只是我们所想的一半，而我们听到的又只有一半，能够记下来的还要再减一半。</strong></li><li><strong>消极的开始不会鼓励对方继续交谈下去，而且还会为这份新建立的关系增加低沉的基调。</strong></li><li><strong>批评你的人通常最想得到的是你倾听他的意见和想法，并且认真地对待。如果你不愿听对方的批评，问题就会积累起来无法解决，反而会让矛盾越来越激化。</strong></li><li><strong>有时候，当你询问具体内容时．你会发现本来认定的批评其实并不是批评，可能是别人对于你才华的认可或者惋惜。</strong></li><li><strong>谁需要没有得到满足．谁就有烦恼。</strong></li><li><strong>一切行为都是有意义的。不管他是否正确，所有的行为都会被别人赋予一定的意义。</strong></li><li><strong>人不是为外物所动，而是被自己对外物的认识所左右。</strong></li><li><strong>事物没有善恶之分，都是人的思想的结果。</strong></li><li><strong>给自己贴“标签”是不理性的</strong>，不仅因为这样做让你相信过去的行为能够决定将来的行为，过去的失败注定了将来的失败，还因为<strong>这样做会把你整个人包裹在某一个词里面，让局部偶然的事情成了全部的必然的结果</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 谈话的力量 </tag>
            
            <tag> 沟通能力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次爬虫实践遇到的问题</title>
      <link href="python-%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>python-%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    平时编写Blog的时候，使用了 <a href="https://sm.ms/">sm.ms</a> 的免费图床（┑(￣。。￣)┍ 咳咳咳，这个名字不要误解，是一个正经的图片管理工具😂，如果访问流量比较少的，免费版本就可以满足需求）， <strong><font color=red>后来想在本地也定时备份下所有的图片，以便后续更换图床做不时之需。</font></strong> 于是想到了爬虫去爬取已有的图片并下载到本地。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>最终通过调研，发现存在以下两种方式（<strong>欢迎提出其他解决方案</strong>）：</p><h4 id="方案一：BeautifulSoup-爬虫"><a href="#方案一：BeautifulSoup-爬虫" class="headerlink" title="方案一：BeautifulSoup 爬虫"></a>方案一：BeautifulSoup 爬虫</h4><p><strong>优点：</strong>可指定获取特定页面的 HTML 内容，然后通过解析 HTML 内容来获取所有图片的信息。</p><p><strong>缺点：</strong>每次需要去更新请求中的 Cookie 信息来爬取对应的页面内容。</p><a id="more"></a><h4 id="方案二：-sm-ms-API"><a href="#方案二：-sm-ms-API" class="headerlink" title="方案二： sm.ms API"></a>方案二： <a href="https://doc.sm.ms/">sm.ms API</a></h4><p><strong>优点：</strong>对外API接口中，<code>/upload_history</code> 接口返回了历史的上传记录，可以获取到所有的已上传的图片链接以及相关信息。</p><p><strong>缺点</strong>：每次返回的是全量数据，这对于历史数据很多的用户，体验比较差。</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>上面两种方案都试验过后实际都可以满足背景中的需求，但发现经过调试代码成功后，实际开始进行内容爬取的时候，直接请求报错。具体报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RemoteDisconnected(<span class="string">&#x27;Remote end closed connection without response&#x27;</span>)</span><br></pre></td></tr></table></figure><p>┑(￣。。￣)┍ oh，比较坏的情况发生了，可能由于请求过快被服务端给拉黑了。。。通过后面的实验发现应该是<font color=red><strong>被服务端封了IP</strong></font>。</p><p>网上解决方案：<a href="https://blog.csdn.net/c406495762/article/details/60137956">使用User Agent和代理IP隐藏身份</a></p><p>但再使用网上的解决方案之前，存在一个比较怪异的现象，那就是<font color=red><strong>同样的接口，使用本地的Postman却可以一直调用成功，使用本地的Pycharm脚本调用却一直失败。</strong></font>（都是通过API方式去调用的 /upload_history接口）</p><p>通过一系列的骚操作对比后，发现核心区别在于（postman自动使用了本地的代理端口去发送请求，也就是代理IP隐藏身份）：<br><img src="https://i.loli.net/2021/07/02/3yBbxZYSz9nPVsg.png" alt="postman_proxy_1_new.png" style="zoom:67%;" /></p><p>Python requests 解决该问题的核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># 主要是添加 proxy 来隐藏实际自己的IP。</span></span><br><span class="line">proxy = &#123;<span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://127.0.0.1:1235/&quot;</span>, <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://127.0.0.1:1235/&quot;</span>&#125;</span><br><span class="line">res = requests.get(img_url,  headers=headers, proxies=proxy, stream=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(res.content)</span><br></pre></td></tr></table></figure><p>PS: <strong>如何判断自己的代理生效了</strong>可参考如下代码（<a href="https://zhuanlan.zhihu.com/p/79466893">参考链接</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">proxies=<span class="literal">None</span></span>):</span></span><br><span class="line">    https_url = <span class="string">&#x27;https://ip.cn/api/index?ip=&amp;type=0&#x27;</span></span><br><span class="line">    http_url = <span class="string">&#x27;http://ip111.cn/&#x27;</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;curl/7.29.0&#x27;</span>&#125;</span><br><span class="line">    https_r = requests.get(https_url, headers=headers, proxies=proxies, timeout=<span class="number">10</span>)</span><br><span class="line">    http_r = requests.get(http_url, headers=headers, proxies=proxies, timeout=<span class="number">10</span>)</span><br><span class="line">    soup = BeautifulSoup(http_r.content, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    result = soup.find(class_=<span class="string">&#x27;card-body&#x27;</span>).get_text().strip().split(<span class="string">&#x27;&#x27;&#x27;\n&#x27;&#x27;&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    https_r_json = https_r.json()</span><br><span class="line">    https_r_address, https_r_ip = https_r_json.get(<span class="string">&quot;address&quot;</span>), https_r_json.get(<span class="string">&quot;ip&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;local_proxy.log&quot;</span>, <span class="string">&quot;a+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;=========================\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;访问https网站使用代理：%s %s\n&quot;</span> % (https_r_ip, https_r_address))</span><br><span class="line">        f.write(<span class="string">&quot;访问http网站使用代理：%s\n&quot;</span> % result)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未开启代理时</span></span><br><span class="line">validate()</span><br><span class="line">&gt;&gt; 访问https网站使用代理：172.69.34.243 美国 加利福尼亚  <span class="comment"># 这个看起来有点问题</span></span><br><span class="line">&gt;&gt; 访问http网站使用代理：xxx.xxx.xx.xxx 中国 xx市</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启代理后 =========================</span></span><br><span class="line">&gt;&gt; 访问https网站使用代理：153.122.116.100 日本  东京都 东京 </span><br><span class="line">&gt;&gt; 访问http网站使用代理：153.122.116.100 日本 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> requests </tag>
            
            <tag> BeautifulSoup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《学会提问》读后感</title>
      <link href="%E8%AF%BB%E5%90%8E%E6%84%9F-%E3%80%8A%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>%E8%AF%BB%E5%90%8E%E6%84%9F-%E3%80%8A%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    <strong>为什么要看这本书？？</strong>一一 在工作中，会存在以下的场景：</p><ul><li>公司高层或者领导在分享一些信息的时候，可能会有专门的提问环节。在这种时候，一个领导认为 “好” 的提问是一个表现自己的机会；</li><li>领导在分配任务后，如果不做任何提问，按照自己的想法去完成工作，最后可能与上级的意图背道而驰，相当于白忙活一场。</li></ul><p>基于以上的两个场景，可以发现有些时候 <strong>问一些恰到好处的问题</strong> 是一件比较重要软技能，于是开始看《学会提问》，但这个过程不像《小强升职记》那么顺畅，主要在于两个原因：</p><ol><li>因为有部分章节实在是比较枯燥而且冗长（比如：第3、4章内容偏理论）┑(￣。。￣)┍ 。。。</li><li>实际内容并不完全像我想象的是主要<strong>培养各种提问的技能</strong>，而较多的是培养批判性思维。</li></ol><p>最终在坚持了2个月后终于完成了阅读以及总结，总的来说：<font color=blue>还是有一些意外的收获</font>。</p><a id="more"></a><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>​    《学会提问》本书既定的目标一一传授批判性思维和提问的技能， 书中分享了如何培养批判性思维的提问技能以及真实的案例。会发现我们工作与生活中遇到的思想太简单、思考太片面，写作没深度，逻辑很混乱，目标不一致，方向不确定等问题，每个人都会遇到，只是有些人成功的解决了，有些人还被困扰着。</p><p>​    下面对部分章节进行了简单的整理以及一些个人的理解。（标题以及内容有一定改动）</p><h4 id="一、-为什么要学习批判性思维？"><a href="#一、-为什么要学习批判性思维？" class="headerlink" title="一、 为什么要学习批判性思维？"></a>一、 为什么要学习批判性思维？</h4><h5 id="（1）什么是批评性思维"><a href="#（1）什么是批评性思维" class="headerlink" title="（1）什么是批评性思维"></a>（1）什么是<a href="https://baike.baidu.com/item/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4">批评性思维</a></h5><p>网上的解释太多了，有兴趣可以自行查看，大部分也比较抽象😂。</p><p>个人理解：批判性思维就是<font color=blue><strong>不要快速接受别人的观点或者结论，需要通过自己独有的思考以及验证</strong></font>。也就是书中强调的 “慢思考”。</p><p>在本书的第一章节中就明确了为什么要学习批判性思维，个人觉得主要原因就是：</p><blockquote><p>我们最容易获取的就是别人想让你知道的。</p><p>更糟糕的是，那些想说服我们的人，在努力塑造我们的行为习惯时并未做到光明磊落。他们所说的话至多不过是真假参半。</p></blockquote><p>所以，我们需要批判性思维来帮我们进行信息的筛选，辅助我们去<font color=blue><strong>判别信息的可信度</strong>。</font></p><h5 id="（2）坚持使用批判性思维的好处"><a href="#（2）坚持使用批判性思维的好处" class="headerlink" title="（2）坚持使用批判性思维的好处"></a>（2）坚持使用批判性思维的好处</h5><blockquote><p>坚持用这些批判性思维提问也可以巩固我们不断增长的知识，帮助我们更快地发现世界运行的规律， 更好地理解这个世界，以及怎样做才能让世界变得更美好。 </p></blockquote><p><strong>我个人比较赞同书上所说的这一点</strong>，因为实际把批判性思维带到工作或者生活中的问题时，每当我发现一个问题的原因时候，我可能会下意识的再去思考下一一<font color=blue><strong>这个原因真的是问题的唯一原因还是仅仅是问题的原因之一？</strong></font>这间接让我更加主动的学习更多的知识。</p><img src="https://i.loli.net/2021/06/15/en7hwLaV8lPdg5y.png" alt="学会提问-批判性思维.png" style="zoom:43%;" /><p>​    第一章节中还介绍了部分名词概念，有兴趣的可自行阅读，比如：</p><ul><li>海绵式思维 VS 淘金式思维</li><li>弱势批判性思维 VS 强势批判性思维</li></ul><p>⚠️ 注意点：与他人沟通的时候，<strong>使用批判性思维的<font color=red>最根本前提是一一让对话进行下去</font>。</strong></p><h4 id="二、-批判性思维的阻碍"><a href="#二、-批判性思维的阻碍" class="headerlink" title="二、 批判性思维的阻碍"></a>二、 批判性思维的阻碍</h4><p>​    如果批判性思维真的这么好，为什么我们在周围的邻居、朋友的谈话里不太容易见到它呢？尝试想象一下：当你频繁的使用批判性思维去提问某个人的时候，很可能得到的结果就是：<font color=red><strong>“你怎么单单就盯上我了呢？”</strong></font>、<font color=red><strong>“你是个杠精吧？”</strong></font>等一系列不和谐的答复，到此基本追问的环境基本就戛然而止。</p><p><strong>第二章中比较全面的介绍了各种阻碍它的原因</strong>，具体的批判性思维的阻碍如下：</p><img src="https://s3.jpg.cm/2021/06/15/IPJXeH.png" alt="学会提问-批判性思维的阻碍.png" style="zoom:43%;" /><p>我把上面的阻碍在我个人身上套用了一遍，确实这些原因大部分我也都遇到过，并且我相信大部分人也遇到过。在知道了这些阻碍后，我们就可以开始来慢慢克服它们，最终养成强势批评性思维。</p><p>比如一些养成批判性思维的方法， （<strong>PS：个人理解比较有效的方法</strong>）：</p><ul><li><strong>慢思考</strong>：我们要培养的习惯，就是问一问自己：我为什么要像现在这样想？</li><li><strong>避免个人偏见</strong>：当某个人提出某个结论的时候，不要过快的根据原来对于此人的看法而快速否定或者赞同该人。</li><li><strong>避免弱势批判思维</strong></li><li><strong>同理心（以自我为中心）</strong>：多想想你面对的人是什么样的人，可以想象下面的场景：<strong>如果你抛开自己已经知道的知识，你可能根本听不懂自己说的那些专业术语。</strong></li></ul><h4 id="三、-批判性思维的实际运用场景"><a href="#三、-批判性思维的实际运用场景" class="headerlink" title="三、 批判性思维的实际运用场景"></a>三、 批判性思维的实际运用场景</h4><p>⚠️ <em>PS：此处跳过了本书中的第三、四章节（主要介绍的是论题、结论、理由等抽象理论）。。。实际是因为有点枯燥 ， 放弃整理了。</em>┑(￣。。￣)┍，以及第七章 论证中有没有谬论等。</p><h5 id="（一）词语意思不明确（存在多种含义）"><a href="#（一）词语意思不明确（存在多种含义）" class="headerlink" title="（一）词语意思不明确（存在多种含义）"></a>（一）词语意思不明确（存在多种含义）</h5><p>​    看完这一章节后，想到一个段子一一<font color=red><strong>你以为你以为就是你以为的么？</strong></font>😂😂很多时候，你其实对于某个关键词语的意思和表达者想表达的意思相差甚远，所以<font color=blue><strong>对齐关键词语的理解至关重要。</strong></font></p><p>一个词或短语越是<strong>抽象</strong>（抽象的定义：<font color=red>一个词所指代的对象离特定的、具体的事例越是遥远，它也就会变得越抽象</font>），人们就越有可能对其做出多重解读。</p><p> <strong>找出不明确的词语的方法</strong>：</p><ul><li><strong>避免和表达者心心相印的想法，比如：”我就知道你是这个意思”，恰当的问：“你这样说是这个意思么？”；</strong></li><li><strong>避免认为抽象的术语只存在一个明显的定义，越是抽象的，人们就越有可能对其做出多重解读。</strong></li></ul><p>解释一个抽象的词语或者短语的方法：（比如： 焦虑 这个词）</p><ul><li><strong>同义替换</strong>：焦虑（anxiety）就是感到紧张不安；</li><li><strong>举例说明</strong>：焦虑就是候选人打开电视观看选举结果公布时的心情；</li><li><strong>具体标准定义</strong>：焦虑是种主观上的不适感，同时伴随着自主神经系统越来越强烈的感受（<strong>个人感觉，这种标准定义都比较抽象</strong>┑(￣。。￣)┍）；</li></ul><p><img src="https://i.loli.net/2021/06/18/tTGyMP9gxzdebqC.png" alt="学会提问-词语不明确.png"></p><h5 id="（二）价值观假设"><a href="#（二）价值观假设" class="headerlink" title="（二）价值观假设"></a>（二）价值观假设</h5><p>​    本章节中，个人理解：<font color=red><strong>矛盾的产生大部分还是由于价值观不同，最终双方产生价值观冲突而引发了争吵</strong></font>。很简单的就是现在所谓的婆媳关系，很多时候可能并没有对错，仅仅是双方的价值观不同。</p><p>比如：<strong>时间和金钱哪个更重要？个人感觉：如果不带入到确定的场景中，这个问题实际是无解的</strong>，因为拜金主义的人肯定觉得金钱高于一切，而世界首富们肯定觉得时间高于一切。双方基于不同的价值观，对于这个问题答案肯定就不会一致。</p><p>由于涉及到了价值观，内容比较抽象，有兴趣的可自行阅读去了解更多的细节。</p><p><img src="https://i.loli.net/2021/06/24/mHxDUFAS5db6yIB.png" alt="学会提问-价值观假设.png"></p><h5 id="（三）证据的效力（有效性）"><a href="#（三）证据的效力（有效性）" class="headerlink" title="（三）证据的效力（有效性）"></a>（三）证据的效力（有效性）</h5><p>本书的第八、九章节都是介绍的证据的效力（有效性），个人感觉阅读过后还是收益匪浅。在生活中的任何结论，实际上我们都只能说<strong>多多少少有可能是真的， 支持它的合理论据越多，那它的可信度也就越高。</strong></p><p><strong>总结出来的方法</strong>，在大多数场景，我们都可以通过以下三点来思考，避免过快的相信对方的结论：</p><ol><li>这个结论是否是无可置疑的常识？</li><li>这个结论是否从无懈可击的论证中得出的结论？ </li><li>这个结论是否有足够多合理的证据加以支撑？</li></ol><p>本书中，介绍了不同的类型证据（<font color=blue>个人觉得每个类型讲解的通俗易懂，建议通读</font>），通过这样能够更快的帮助我们去判断结论的可信度，具体的类型如下图中标红部分。</p><p>比如：一个人跟你说他的结论是<strong>基于他的直觉</strong>（<strong>由于直觉的私密性，别人根本没办法判断它是否可靠</strong>）， 那你可能就需要多想想他的直觉是否靠谱了😂😂。。</p><p>再比如：典型案例作为证据（常常很有说服力），<strong>但又有多少个孩子因为朗朗这一个成功的案例而丧失了自己的童年。</strong></p><p><img src="https://i.loli.net/2021/06/24/2AYlKHcdsqrVJnB.png" alt="学会提问-论据的效力.png"></p><h5 id="（四）寻找替代原因"><a href="#（四）寻找替代原因" class="headerlink" title="（四）寻找替代原因"></a>（四）寻找替代原因</h5><p>看完本章节后，我个人<font color=red><strong>一个最深刻的体验</strong></font>就是：</p><blockquote><p>现实生活中的，大部分导致产生某个现象都是由多个原因导致的，很少存在唯一的原因（只能说某个原因对结果产生的影响占比更大）。</p></blockquote><p>所以更多的去问一问：<strong>这个原因是唯一的原因还是原因之一</strong>？</p><p>在本章节中介绍了丰富的场景（比如：换位思考、组间差异性、相关性）帮助去寻找事情的替代原因。</p><p><img src="https://i.loli.net/2021/06/28/FnIbsJhl5N2gDyG.png" alt="学会提问-替代原因.png"></p><h5 id="（五）数据的欺骗性"><a href="#（五）数据的欺骗性" class="headerlink" title="（五）数据的欺骗性"></a>（五）数据的欺骗性</h5><p>在当前社会中，生活中无处不在的数字信息冲击着我们的大脑，所以对于数据的真实性需要更加谨慎。主要体现在以下几个方面：</p><ol><li>统计数据的来源来历不明（很可能是表达者<strong>为了达成某个效果而虚假构造的</strong>）；</li><li>通过省略信息来欺骗用户（如：<strong>隐藏调研的目标，仅展示最终的投票结果</strong>）。</li></ol><p>比如：<strong>40%的大学生饱受抑郁症的折磨！</strong> （如果文章内容中，<font color=red>没有表明这些数据是怎么来的以及调研的具体对象是哪些大学生和调研的总人数等关键信息</font>，那这个标题明显就有点标题党。）</p><p><img src="https://i.loli.net/2021/06/28/BDqlnVeGOMZL264.png" alt="学会提问-数据的欺骗性.png"></p><h4 id="书中语录"><a href="#书中语录" class="headerlink" title="书中语录"></a>书中语录</h4><ul><li><strong>当我们改变自己的想法，接受一个更好的观点，我们应为此感到自豪</strong>，我们抵制住了诱惑，没有死心塌地去维护自己长期以来的信念。这样一种思想转变应当被视为一种罕见力量的反映。</li><li>谁想说服你，谁就要负责解释清楚。</li><li><strong>本书所谓的价值观（values），是指人们认为较有价值的那些观念。你会发现，正是人们对抽象观念所赋予的重要性对其选择和行为产生了重大影响。</strong></li><li><strong>我们最容易获取的就是别人想让你知道的，并且那些人对于这些信息进行了相应的特殊处理；</strong></li><li><strong>如果抛开自己已经知道的知识，你可能根本听不懂自己说的那么专业术语。</strong></li><li><strong>一个词或短语越是抽象（一个词所指代的对象离特定的、具体的事例越是遥远，它也就会变得越抽象），人们就越有可能对其做出多重解读。</strong></li><li><strong>一个信念，支撑它的证据越多，它的“事实程度”也变得越高。对于事实的本质，我们也可以换一种说法，那就是它们多多少少有可能是真的。</strong> </li><li><strong>单一的个人经历，甚至是个人经历的总和，根本不足以构成一个有代表性的经历样本，所以个人经历常会导致我们犯下 “以偏概全谬误”（hasty generalization fallacy）。</strong></li><li><strong>人们常犯的一个 错误就是想找出一件事的简单唯一的原因，而事实上这个原因是由许多共同起作用的原因结合在一起导致的结果，即这些原因共同起作用，创造了事件发生所需要的整体环境。</strong></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    由于本书内容较多，感觉总结起来不是太到位😂。。。仅仅只能把个人感触比较大的点记录下，方便后续回顾。通过实际运用该书的内容后，还是明显发现最大的阻碍就是 <font color=red><strong>“给他人带来不快”</strong></font>。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 批判性思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql注入一一Sqlmap实践</title>
      <link href="%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3-Sqlmap%E6%B3%A8%E5%85%A5%E5%AE%9E%E8%B7%B5/"/>
      <url>%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3-Sqlmap%E6%B3%A8%E5%85%A5%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    时隔了好好好几个月。。。继上次文章 <a href="https://beanskingdom.top/%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3-%E5%88%9D%E6%8E%A2Sqlmap%EF%BC%88%E4%B8%80%EF%BC%89/">初探Sqlmap（一）</a>中立下的Flag：下一篇出sqlmap原理相关的介绍😂😂，由于各种原因。。。今天才终于完成了┑(￣。。￣)┍ 。。不多说了。。。</p><h3 id="什么是SQL注入？"><a href="#什么是SQL注入？" class="headerlink" title="什么是SQL注入？"></a>什么是SQL注入？</h3><p>​    指在程序的输入数据中添加<strong>额外的SQL语句</strong>。就好比有一个登录输入框，在输入帐号的的输入框中，输入了 <code>&#39;arvin&#39; or 1=1</code> ，对应到数据库层面，sql语句可能就如下实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 正常的<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> user_name <span class="operator">=</span> &quot;arvin&quot;;</span><br><span class="line"></span><br><span class="line"># 如果上述的输入框输入没有拦截，语句就变成了如下形式，多了额外的&quot;or 1=1&quot; 到查询的语句中就是<span class="keyword">sql</span>注入了。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> name<span class="operator">=</span>&quot;arvin&quot; <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="为什么会存在SQL注入？"><a href="#为什么会存在SQL注入？" class="headerlink" title="为什么会存在SQL注入？"></a>为什么会存在SQL注入？</h3><p>​    由于程序对 <strong>用户输入数据的合法性没有判断或过滤不严</strong>，攻击者可以在程序中事先定义好的 <strong>查询语句的结尾上添加额外的SQL语句</strong>。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python中一种存在SQL注入的sql写法， 由于没有对传入的参数 name 进行任何的校验，并且是简单的动态拼接查询语句，导致可以进行SQL注入。</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/print_bad_sql&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_info</span>():</span></span><br><span class="line">  name = request.args.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">  sql = <span class="string">&quot;select * from table_name where name=%s&quot;</span> % name</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过如下代码， 则可以构造出一条布尔类型的SQL注入语句</span></span><br><span class="line"><span class="comment"># http://127.0.0.1:5000/print_bad_sql?name=%22arvin%22%20or%201=1</span></span><br></pre></td></tr></table></figure><h3 id="存在SQL注入的影响"><a href="#存在SQL注入的影响" class="headerlink" title="存在SQL注入的影响"></a>存在SQL注入的影响</h3><p>​    可以在管理员不知情的情况下，实现欺骗 <strong>数据库服务器</strong> 执行<strong>非授权的任意查询</strong>，从而进一步<strong>得到相应的数据信息</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http://127.0.0.1:5000/bad_sql?id=1</span></span><br><span class="line"><span class="comment"># 由于不存在id为1的数据，所以正常情况下是没有任何数据返回的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># http://127.0.0.1:5000/bad_sql?id=1%20or%201=1</span></span><br><span class="line"><span class="comment"># 但使用存在SQL注入语句的请求，返回了当前表下面的所有数据信息。</span></span><br></pre></td></tr></table></figure><h3 id="Sql注入的主要流程"><a href="#Sql注入的主要流程" class="headerlink" title="Sql注入的主要流程"></a>Sql注入的主要流程</h3><ol><li><p><strong>SQL注入点探测</strong>。</p><p>探测SQL注入点是关键的一步，通过适当的分析应用程序，可以判断什么地方存在SQL注入点。通常只要 <strong>带有输入提交的动态网页</strong>，并且 <strong>动态网页访问数据库</strong>，就可能存在SQL注入漏洞。如果程序员信息安全意识不强，<font color=red><strong>采用动态构造SQL语句访问数据库，并且对用户的输入未进行有效性验证，则存在SQL注入漏洞的可能性很大。</strong></font>一般通过页面的报错信息来确定是否存在SQL注入漏洞。</p><ul><li><font color=blue>疑问1: 什么样的报错信息表示可能存在SQL注入？</font></li><li><font color=blue>疑问2: 怎么样去判断是否存在SQL注入点？</font></li></ul></li><li><p><strong>收集后台数据库信息。</strong></p><p>不同数据库的注入方法、函数都不尽相同，因此在注入之前，我们先要判断一下数据库的类型。判断数据库类型的方法很多，可以输入特殊字符，如单引号，让程序返回错误信息，我们根据错误信息提示进行判断；还可以使用特定函数来判断，比如输入“1 and version（）&gt;0”，程序返回正常，说明 <code>version()</code> 函数被数据库识别并执行，而 <code>version()</code> 函数是 <code>MySQL</code> 特有的函数，因此可以推断后台数据库为MySQL。</p></li><li><p><strong>猜解用户名和密码。</strong></p><p>数据库中的表和字段命名一般都是有规律的。通过构造特殊SQL语句在数据库中依次猜解出表名、字段名、字段数、用户名和密码。(<font color=blue>疑问3: 如何构造的特殊SQL语句，猜解出来表名、字段名以及密码等</font>)</p></li><li><p><strong>查找Web后台管理入口。</strong></p></li><li><p><strong>入侵和破坏。</strong></p><p>一般后台管理具有较高权限和较多的功能，使用前面已破译的用户名、密码成功登录后台管理平台后，就可以任意进行破坏，比如上传木马、篡改网页、修改和窃取信息等，还可以进一步提权，入侵Web服务器和数据库服务器。</p></li></ol><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>在介绍工具之前，可以本地搭建一个简单的web服务，需要依赖 <code>Flask</code>、<code>mysql</code>、<code>python</code>等，请自行百度安装。</p><ul><li><a href="http://docs.jinkan.org/docs/flask/quickstart.html#a-minimal-application">Flask：一个最小的应用</a></li><li><a href="https://www.runoob.com/python3/python3-mysql.html">Python 操作 Pymysql</a></li></ul><h3 id="Sqlmap工具的介绍"><a href="#Sqlmap工具的介绍" class="headerlink" title="Sqlmap工具的介绍"></a><a href="https://sqlmap.org/">Sqlmap工具的介绍</a></h3><h4 id="Sqlmap-实例演练"><a href="#Sqlmap-实例演练" class="headerlink" title="Sqlmap 实例演练"></a>Sqlmap 实例演练</h4><p>​    用命令行实际例子来演示一遍， 通过命令行来注入，并且获取对应的用户名和密码。（下面实例中的参数可以参考：<a href="http://www.vuln.cn/1992">参考链接</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找注入点</span></span><br><span class="line">python3.7 sqlmap.py -u <span class="string">&#x27;http://127.0.0.1:5000/bad_sql?id=111&#x27;</span> --dbms=<span class="string">&#x27;MySQL&#x27;</span> --batch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询有哪些数据库</span></span><br><span class="line">python3.7 sqlmap.py -u <span class="string">&#x27;http://127.0.0.1:5000/bad_sql?id=111&#x27;</span> --dbms=<span class="string">&#x27;MySQL&#x27;</span>  --batch –level 3 –dbs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询qa_tools_db/mysql数据库中有哪些表</span></span><br><span class="line">python3.7 sqlmap.py -u <span class="string">&#x27;http://127.0.0.1:5000/bad_sql?id=111&#x27;</span> --dbms=<span class="string">&#x27;MySQL&#x27;</span> –level 3 -D qa_tools_db –tables</span><br><span class="line">python3.7 sqlmap.py -u <span class="string">&#x27;http://127.0.0.1:5000/bad_sql?id=111&#x27;</span> --dbms=<span class="string">&#x27;MySQL&#x27;</span> –level 3 -D mysql –tables</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询qa_tools_db数据库中jira_infos表有哪些字段</span></span><br><span class="line">python3.7 sqlmap.py -u <span class="string">&#x27;http://127.0.0.1:5000/bad_sql?id=111&#x27;</span> --dbms=<span class="string">&#x27;MySQL&#x27;</span> –level 3 -D qa_tools_db -T jira_infos –columns</span><br><span class="line">python3.7 sqlmap.py -u <span class="string">&#x27;http://127.0.0.1:5000/bad_sql?id=111&#x27;</span> --dbms=<span class="string">&#x27;MySQL&#x27;</span> –level 3 -D mysql -T user –columns</span><br><span class="line"></span><br><span class="line"><span class="comment"># dump出mysql中user表的账号密码</span></span><br><span class="line">python3.7 sqlmap.py -u <span class="string">&quot;http://127.0.0.1:5000/bad_sql?id=111&quot;</span> --dbms=<span class="string">&quot;MySQL&quot;</span> –level 3 -D mysql -T user –passwords -U root -v 2 --batch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果密码很简单的情况下, 直接使用sqlmap本身的命令即可破解。稍微复杂点的密码暂无法直接破解，有兴趣的可以深入研究</span></span><br></pre></td></tr></table></figure><p>PS： 更详细的一些SQL注入基础原理可参考：<a href="https://www.jianshu.com/p/078df7a35671">SQL注入基础</a>，里面举了较多的注入实例。<strong>关于Sqlmap 的命令行模式与 API模式的区别以及优缺点，在 <a href="https://beanskingdom.top/%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3-%E5%88%9D%E6%8E%A2Sqlmap%EF%BC%88%E4%B8%80%EF%BC%89/">初探Sqlmap（一）</a> 中已经描述过，此处不再重复。</strong></p><h4 id="SqlmapAPI-介绍"><a href="#SqlmapAPI-介绍" class="headerlink" title="SqlmapAPI 介绍"></a>SqlmapAPI 介绍</h4><ul><li><p>SqlmapAPI 的启动方式： <code>python sqlmapapi.py -s -H &quot;0.0.0.0&quot; -p 8775</code></p></li><li><p>SqlmapAPI 的脚本主要核心流程如下图：</p><p>   <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017801751919456">Sqlite3 数据库</a>：<strong>SQLite是一种嵌入式数据库，它的数据库是一个文件。</strong></p><p>  <a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3">WSGI application</a>：<strong>Web服务器网关接口</strong>（<strong>Python Web Server Gateway Interface</strong>）</p>  <img src="https://i.loli.net/2021/02/16/WJVaUkBYhstGRHv.png" width="800px" align="left"><p>使用API模式进行sql注入测试时候，主要使用如下几个API接口（具体如何调用以及为什么要使用该方式可参考：<a href="https://paper.seebug.org/940/">细说Sqlmap</a>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get(<span class="params"><span class="string">&quot;/task/new&quot;</span></span>)</span><span class="comment"># 创建一个新的扫描任务</span></span><br><span class="line"><span class="meta">@post(<span class="params"><span class="string">&quot;/scan/&lt;taskid&gt;/start&quot;</span></span>)</span><span class="comment"># 指定任务进行扫描</span></span><br><span class="line"><span class="meta">@get(<span class="params"><span class="string">&quot;/scan/&lt;taskid&gt;/status&quot;</span></span>)</span><span class="comment"># 查看指定任务的状态</span></span><br><span class="line"><span class="meta">@get(<span class="params"><span class="string">&quot;/scan/&lt;taskid&gt;/data&quot;</span></span>)</span><span class="comment"># 查看指定任务的执行结果</span></span><br><span class="line"><span class="meta">@get(<span class="params"><span class="string">&quot;/scan/&lt;taskid&gt;/log&quot;</span></span>)</span><span class="comment"># 查看指定任务的扫描执行日志</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="SqlmapAPI-Task执行原理"><a href="#SqlmapAPI-Task执行原理" class="headerlink" title="SqlmapAPI Task执行原理"></a>SqlmapAPI Task执行原理</h4><p>此处仅介绍 <code>/scan/&lt;taskid&gt;/start</code>，主要通过 <code>DataStore.tasks[taskid].engine_start()</code> 执行指定任务执行扫描。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">engine_start</span>(<span class="params">self</span>):</span></span><br><span class="line">handle, configFile = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.CONFIG, text=<span class="literal">True</span>)</span><br><span class="line">  os.close(handle)</span><br><span class="line">saveConfig(self.options, configFile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&quot;sqlmap.py&quot;</span>):</span><br><span class="line">    self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line"><span class="keyword">elif</span> os.path.exists(os.path.join(os.getcwd(), <span class="string">&quot;sqlmap.py&quot;</span>)):</span><br><span class="line">      self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, cwd=os.getcwd(), close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">elif</span> os.path.exists(os.path.join(os.path.abspath(os.path.dirname(sys.argv[<span class="number">0</span>])), <span class="string">&quot;sqlmap.py&quot;</span>)):</span><br><span class="line">      self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, cwd=os.path.join(os.path.abspath(os.path.dirname(sys.argv[<span class="number">0</span>]))), close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">      self.process = Popen([<span class="string">&quot;sqlmap&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, close_fds=<span class="keyword">not</span> IS_WIN)</span><br></pre></td></tr></table></figure><p>  从上面的代码来看，最终默认还是使用的 <code>sqlmap.py</code> 脚本来进行的任务扫描。（可以通过打印出源代码中 <code>configFile</code> 的路径，来查看每次任务的配置参数是什么。）</p><h3 id="Sqlmap核心流程梳理"><a href="#Sqlmap核心流程梳理" class="headerlink" title="Sqlmap核心流程梳理"></a>Sqlmap核心流程梳理</h3><h4 id="（一）先是进行一系列的系统环境准备（sqlmap运行的系统版本）"><a href="#（一）先是进行一系列的系统环境准备（sqlmap运行的系统版本）" class="headerlink" title="（一）先是进行一系列的系统环境准备（sqlmap运行的系统版本）"></a>（一）先是进行一系列的系统环境准备（sqlmap运行的系统版本）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dirtyPatches()</span><br><span class="line">resolveCrossReferences()</span><br><span class="line">checkEnvironment()</span><br><span class="line">setPaths(modulePath())</span><br><span class="line">banner()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如下输出</span></span><br><span class="line">        ___</span><br><span class="line">       __H__</span><br><span class="line"> ___ ___[(]_____ ___ ___  &#123;<span class="number">1.5</span><span class="number">.1</span><span class="number">.28</span><span class="comment">#dev&#125;</span></span><br><span class="line">|_ -| . [<span class="string">&quot;]     | .&#x27;| . |</span></span><br><span class="line"><span class="string">|___|_  [)]_|_|_|__,|  _|</span></span><br><span class="line"><span class="string">      |_|V...       |_|   http://sqlmap.org</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user&#x27;s responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] starting @ 16:23:26 /2021-06-03/</span></span><br></pre></td></tr></table></figure><h4 id="（二）对用户传入的参数进行解析以及构建对应的测试Sql注入语句"><a href="#（二）对用户传入的参数进行解析以及构建对应的测试Sql注入语句" class="headerlink" title="（二）对用户传入的参数进行解析以及构建对应的测试Sql注入语句"></a>（二）对用户传入的参数进行解析以及构建对应的测试Sql注入语句</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">args = cmdLineParser()</span><br><span class="line">cmdLineOptions.update(args.__dict__ <span class="keyword">if</span> <span class="built_in">hasattr</span>(args, <span class="string">&quot;__dict__&quot;</span>) <span class="keyword">else</span> args)</span><br><span class="line">initOptions(cmdLineOptions)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 在👇这个方法中进行了需要执行的注入Sql构建。</span></span><br><span class="line">init()</span><br><span class="line"> -&gt; loadBoundaries()</span><br><span class="line"> -&gt; loadPayloads()</span><br><span class="line">  <span class="comment"># 构建sql注入的测试语句主要文件在data/xml/payloads下，</span></span><br><span class="line">  <span class="comment"># 如：sqlmap/data/xml/payloads/boolean_blind.xml</span></span><br><span class="line">  -&gt; parseXmlNode()</span><br></pre></td></tr></table></figure><p>具体执行的Sql注入测试语句样式如下：</p><img src="https://i.loli.net/2021/06/03/xBf93UE17JYDGhu.png" alt="sqlmap_share_5.png" style="zoom:67%;" /><h4 id="（三）进行注入测试，找出注入点"><a href="#（三）进行注入测试，找出注入点" class="headerlink" title="（三）进行注入测试，找出注入点"></a>（三）进行注入测试，找出注入点</h4><ul><li><p><strong>测试的Sql语句类型是哪些？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">Valid values:</span></span><br><span class="line"><span class="string">1: Boolean-based blind SQL injection基于布尔的盲注，即可以根据返回页面判断条件真假的注入；</span></span><br><span class="line"><span class="string">2: Error-based queries SQL injection基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中；</span></span><br><span class="line"><span class="string">3: Inline queries SQL injection基于内联视图注入, 内联视图能够创建临时表，在处理某些查询情况时十分有用。</span></span><br><span class="line"><span class="string">4: Stacked queries SQL injection堆查询注入，可以同时执行多条语句的执行时的注入。</span></span><br><span class="line"><span class="string">5: Time-based blind SQL injection基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断；</span></span><br><span class="line"><span class="string">6: UNION query SQL injection联合查询注入，可以使用union的情况下的注入；</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 根据具体的用户传入的 level 和risk 来过滤哪些sql注入测试语句需要执行。</span></span><br><span class="line"><span class="comment"># 具体执行代码在 check.py 中进行执行 checkSqlInjection() 方法，部分代码如下：</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> test.risk &gt; conf.risk:</span><br><span class="line">debugMsg = <span class="string">&quot;skipping test &#x27;%s&#x27; because the risk (%d) &quot;</span> % (title, test.risk)</span><br><span class="line">  debugMsg += <span class="string">&quot;is higher than the provided (%d)&quot;</span> % conf.risk</span><br><span class="line">  logger.debug(debugMsg)</span><br><span class="line">  <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Skip test if the level is higher than the provided (or default) value</span></span><br><span class="line"><span class="keyword">if</span> test.level &gt; conf.level:</span><br><span class="line">  debugMsg = <span class="string">&quot;skipping test &#x27;%s&#x27; because the level (%d) &quot;</span> % (title, test.level)</span><br><span class="line">  debugMsg += <span class="string">&quot;is higher than the provided (%d)&quot;</span> % conf.level</span><br><span class="line">  logger.debug(debugMsg)</span><br></pre></td></tr></table></figure></li><li><p><font color=blue><strong>答疑1: 注入过程中，什么样的报错信息表示可能存在SQL注入？</strong></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 heuristicCheckSqlInjection() 方法去判读是否存在Sql注入。 </span></span><br><span class="line">check = heuristicCheckSqlInjection(place, parameter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果结果返回如下内容则表示可能存在SQL注入, 因为参数已经走到了数据库层面。</span></span><br><span class="line">pymysql.err.ProgrammingError: (<span class="number">1064</span>, <span class="string">&#x27;You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \&#x27;&quot;)()..\&#x27;,.\&#x27; at line 1&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><font color=blue><strong>答疑2: 注入过程中，怎么样去判断是否存在SQL注入点？</strong></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Store here the details about boundaries and payload used to successfully inject</span></span><br><span class="line"><span class="comment"># 确认哪些test语句可以进行注入</span></span><br><span class="line">injection = checkSqlInjection(place, parameter, value)</span><br></pre></td></tr></table></figure></li></ul><h4 id="（四）sqlmap-找到注入点后的后置操作"><a href="#（四）sqlmap-找到注入点后的后置操作" class="headerlink" title="（四）sqlmap 找到注入点后的后置操作"></a>（四）sqlmap 找到注入点后的后置操作</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sqlmap 找到注入后， 会进行如下操作将该URL的结果存储下来，避免反复的去扫描 </span></span><br><span class="line"><span class="comment"># 进入到如下代码后，就基本存在注入了。</span></span><br><span class="line">_saveToResultsFile()</span><br><span class="line">_saveToHashDB()</span><br><span class="line">_showInjections()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[16:12:19] [INFO] testing connection to the target URL</span><br><span class="line">sqlmap resumed the following injection point(s) from stored session:</span><br><span class="line">---</span><br><span class="line">Parameter: id (GET)</span><br><span class="line">    Type: boolean-based blind</span><br><span class="line">    Title: Boolean-based blind - Parameter replace (original value)</span><br><span class="line">    Payload: id=(SELECT (CASE WHEN (4166=4166) THEN 111 ELSE (SELECT 6089 UNION SELECT 4520) END))</span><br><span class="line"></span><br><span class="line">    Type: error-based</span><br><span class="line">    Title: MySQL &gt;= 5.6 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (GTID_SUBSET)</span><br><span class="line">    Payload: id=111 AND GTID_SUBSET(CONCAT(0x71786a7871,(SELECT (ELT(7147=7147,1))),0x7170706b71),7147)</span><br><span class="line"></span><br><span class="line">    Type: time-based blind</span><br><span class="line">    Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP)</span><br><span class="line">    Payload: id=111 AND (SELECT 4332 FROM (SELECT(SLEEP(5)))smze)</span><br><span class="line"></span><br><span class="line">    Type: UNION query</span><br><span class="line">    Title: Generic UNION query (NULL) - 11 columns</span><br><span class="line">    Payload: id=111 UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,CONCAT(0x71786a7871,0x4f684663786f6472517771666249797478634379674964624f74656672796b42776e5172456c4573,0x7170706b71),NULL-- -</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="（五）sqlmap-找到注入点后，-如何去获取更多的数据呢？"><a href="#（五）sqlmap-找到注入点后，-如何去获取更多的数据呢？" class="headerlink" title="（五）sqlmap 找到注入点后， 如何去获取更多的数据呢？"></a>（五）sqlmap 找到注入点后， 如何去获取更多的数据呢？</h4><p>​    <strong><font color=blue>答疑3: 如何构造的特殊SQL语句，猜解出来库名、表名、字段名以及密码等？</font></strong></p><ul><li><p>获取所有的库名，具体方法的调用栈如下：（有兴趣的可自行进行 DEBUG 分析）</p><img src="https://i.loli.net/2021/06/03/ozCNZOuBW3kwDFV.png" alt="sqlmap_share_1.png" style="zoom: 56%; margin:0px;"/><p>通过构建出 <code>select schema_name from information_schema.schemata</code> 语句，来获取所有的库信息。</p><img src="https://i.loli.net/2021/05/31/uWltIYjXfeOvNM1.png" alt="sqlmap-dbs-name.png" /><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plugins/generic/databases.py getDbs() 其中部分核心代码如下：</span></span><br><span class="line"></span><br><span class="line">conf.dumper.dbs(conf.dbmsHandler.getDbs())</span><br><span class="line"><span class="comment"># 构建的获取库名信息的sql语句</span></span><br><span class="line">query = <span class="string">&#x27;SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA&#x27;</span></span><br><span class="line"><span class="comment"># 获取到了具体的db信息</span></span><br><span class="line">values = inject.getValue(query, blind=<span class="literal">False</span>, time=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># values 返回的结果大致如下</span></span><br><span class="line">res:&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;version_end_time&quot;</span>: null, </span><br><span class="line">  <span class="string">&quot;version_start_time&quot;</span>: <span class="string">&quot;qqkbqinformation_schemaqvjpq&quot;</span></span><br><span class="line">&#125;, </span><br><span class="line">  </span><br><span class="line">value = parseUnionPage(output) <span class="comment"># 将上面的结果解析出正确的db名称</span></span><br><span class="line"><span class="comment"># res: [&#x27;mysql&#x27;, &#x27;information_schema&#x27;, &#x27;performance_schema&#x27;, &#x27;sys&#x27;]</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 如果已经获取出来了的情况下， 会直接存储在本地的sqlit3的表中。避免后续继续扫描。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hashDBWrite</span>(<span class="params">key, value, serialize=<span class="literal">False</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 如果未获取过， <span class="title">action</span>中进行实际的注入来获取对应的数据， 比如：<span class="title">_oneShotUnionUse</span> 中最终拼凑出的 <span class="title">query</span>，直接可以查出对应的库信息。拼凑出来的<span class="title">sql</span>注入语句如下：</span></span><br><span class="line">&#x27;id=111 UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,CONCAT(0x7176627671,IFNULL(CAST(schema_name AS CHAR),0x20),0x716b717a71),NULL,NULL,NULL,NULL FROM INFORMATION_SCHEMA.SCHEMATA-- -__PAYLOAD_DELIMITER__&#x27;</span><br></pre></td></tr></table></figure></li><li><p>获取表名以及表内具体的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原理同库名的获取， 但是在db步骤后，这些数据都被写入到了本地的sqlit3中了, 所以基本都是直接通过如下方法获取到结果了。</span></span><br><span class="line">retVal = hashDBRetrieve(<span class="string">&quot;%s%s&quot;</span> % (conf.hexConvert <span class="keyword">or</span> <span class="literal">False</span>, expression), checkConf=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="（六）破解mysql的登录账号密码"><a href="#（六）破解mysql的登录账号密码" class="headerlink" title="（六）破解mysql的登录账号密码"></a>（六）破解mysql的登录账号密码</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果在密码很简单的情况下， 会通过撞hash猜出来，比如：为了演示，root的密码是123456， 则直接破解出来了， 但是其他的用户密码较复杂， 尝试了下稍微复杂点的都无法破解，如：abc123456。</span></span><br><span class="line"><span class="comment"># 主要破解的函数入口在 users.py 中</span></span><br><span class="line">attackCachedUsersPasswords() </span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;sqlmap/data/txt/wordlist.tx_&#x27;</span></span><br><span class="line">dictionaryAttack(kb.data.cachedUsersPasswords)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过多进程进行密码的破解（看起来默认是通过自带的wordlist.tx_文件中的key一个个去猜每个字符。有兴趣的可自行研究，核心代码在hash.py中）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(_multiprocessing.cpu_count()):</span><br><span class="line">  process = _multiprocessing.Process(target=_bruteProcessVariantA, args=(attack_info, hash_regex, suffix, retVal, i, count, kb.wordlists, custom_wordlist, conf.api))</span><br><span class="line">  processes.append(process)</span><br></pre></td></tr></table></figure><p>wordlist.tx_ 文件中的内容部分截取如下图：</p><img src="https://i.loli.net/2021/06/18/9sNUr3o18K4kMqm.png" alt="sqlmap_dict_word.png" style="zoom:73%; margin:0px;" /><p>如果存在破解成明文的密码, 则如下图中的 <code>clear-text password</code> 打印出来，否则打印出来的是加密的值。</p><p><img src="https://i.loli.net/2021/06/03/mN9qwDRkylWzKXV.png" alt="sqlmap_share_3.png"></p><h3 id="团队内部实践"><a href="#团队内部实践" class="headerlink" title="团队内部实践"></a>团队内部实践</h3><ul><li>通过界面快速新增任务；</li></ul><img src="https://i.loli.net/2021/06/18/TFEzc8GdBQZnrWL.png" alt="sqlmap_new_task_new.png" style="zoom:43%;margin:0px;" /><ul><li>查询已有SQL注入任务（可界面执行单个任务以及查看该任务最近一次的结果）；</li></ul><p><img src="https://i.loli.net/2021/06/09/nYpJaSzmNf2xGEv.png" alt="sqlmap_share_7.png"></p><ul><li>通过拉取YAPI相关接口信息，来跟进已经接入的接口进度；</li><li>通过Jenkins定时任务触发，构建定制化的参数任务（定制化参数任务中，提高了扫描的risk以及level值）。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    通过此次总结，也算是把整个Sqlmap工具与公司业务结合在一起， 虽然通过扫描后还未发现任何问题（如果真的扫描出问题，那就是比较好的实践结果了～(￣▽￣～)(～￣▽￣)～ ），整个过程也算是真正的把技术与工作的业务相结合， 过程中也是收获较多。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/qiudabai/p/8955903.html">SQLMAP用法大全</a><br><a href="http://www.vuln.cn/1992">Sqlmap使用教程【个人笔记精华整理】</a><br><a href="https://www.jianshu.com/p/078df7a35671">SQL注入基础</a><br><a href="https://paper.seebug.org/940/">细说Sqlmap</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全测试 </tag>
            
            <tag> Sql注入 </tag>
            
            <tag> Sqlmap </tag>
            
            <tag> 工具实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 + Jenkins API实践</title>
      <link href="python-Python3-Jenkins-API%E5%AE%9E%E8%B7%B5/"/>
      <url>python-Python3-Jenkins-API%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在使用接口自动化实践过程中，需要通过 <code>Python3 + Jenkins</code> 自动触发接口自动化脚本的JOB，过程中还涉及到通过 <code>Parameter</code> 参数去动态构建 JOB，在此总结下使用过程中遇到的问题以及方法。</p><h3 id="使用方法-（官网）"><a href="#使用方法-（官网）" class="headerlink" title="使用方法 （官网）"></a>使用方法 （<a href="https://python-jenkins.readthedocs.io/en/latest/examples.html">官网</a>）</h3><h4 id="一、初始化-Jenkins-实例"><a href="#一、初始化-Jenkins-实例" class="headerlink" title="一、初始化 Jenkins 实例"></a>一、初始化 Jenkins 实例</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处的 password 可以通过使用 API Token 来替代, 避免密码泄漏。</span></span><br><span class="line">server = jenkins.Jenkins(url, username=username, password=password)</span><br></pre></td></tr></table></figure><a id="more"></a><p>  在Jenkins上生成Token具体的操作步骤，按照下图中的数字标记进行相应的操作。</p>  <img src="https://i.loli.net/2021/06/11/aVNsWJGyFUqcXhr.png" alt="jenkins_add_token.png" style="zoom:33%;" /><h4 id="二、获取最后一次JOB的构建号-amp-结果-amp-状态"><a href="#二、获取最后一次JOB的构建号-amp-结果-amp-状态" class="headerlink" title="二、获取最后一次JOB的构建号&amp;结果&amp;状态"></a>二、获取最后一次JOB的<strong>构建号&amp;结果&amp;状态</strong></h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_job_status</span>(<span class="params">cls, job_name, server</span>):</span></span><br><span class="line">  <span class="comment"># 最近一次JOB的 构建号</span></span><br><span class="line">  build_num = server.get_job_info(job_name)[<span class="string">&#x27;lastBuild&#x27;</span>][<span class="string">&#x27;number&#x27;</span>]</span><br><span class="line">  print(<span class="string">&quot;build num %s&quot;</span> % build_num)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 最近一次JOB的 结果 SUCCESS/FAILURE等 （JOB执行成功还是失败）</span></span><br><span class="line">  special_build_id_info = server.get_build_info(job_name, build_num)</span><br><span class="line">  print(<span class="string">&quot;指定Job result: %s&quot;</span> % special_build_id_info[<span class="string">&#x27;result&#x27;</span>])</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 最后一次JOB的 状态 True/False （是否执行完成）</span></span><br><span class="line">  status = server.get_build_info(job_name, build_num)[<span class="string">&#x27;building&#x27;</span>]</span><br><span class="line">  print(<span class="string">&quot;指定Job status: %s&quot;</span> % status)</span><br><span class="line">  <span class="keyword">return</span> status, build_num</span><br></pre></td></tr></table></figure><h4 id="三、构建执行JOB"><a href="#三、构建执行JOB" class="headerlink" title="三、构建执行JOB"></a>三、构建执行JOB</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_job</span>(<span class="params">cls, job_name, server=<span class="literal">None</span>, params=<span class="literal">None</span></span>):</span></span><br><span class="line">  server = server <span class="keyword">or</span> cls.server</span><br><span class="line">  params = params <span class="keyword">or</span> <span class="built_in">dict</span>()</span><br><span class="line">  status, build_num = cls.get_job_status(job_name, server)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> status:</span><br><span class="line">    server.build_job(job_name, parameters=params)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;开始执行&quot;</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;已存在正在执行中的任务, 请勿重复执行&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="问题一：-一秒内，同一个人快速调用多次-start-job-预期应该是仅仅第一次调用时返回-“开始执行”-实际结果是：多次调用仍然会返回-“开始执行”。"><a href="#问题一：-一秒内，同一个人快速调用多次-start-job-预期应该是仅仅第一次调用时返回-“开始执行”-实际结果是：多次调用仍然会返回-“开始执行”。" class="headerlink" title="问题一： 一秒内，同一个人快速调用多次 start_job() , 预期应该是仅仅第一次调用时返回 “开始执行”,  实际结果是：多次调用仍然会返回 “开始执行”。"></a>问题一： 一秒内，同一个人快速调用多次 <code>start_job()</code> , 预期应该是仅仅第一次调用时返回 “开始执行”,  实际结果是：多次调用仍然会返回 “开始执行”。</h4><p>原因：在调用 <code>cls.get_job_status(job_name, server)</code> 的时候，从第一次调用成功后（假设获取到的最后一次构建号为4），Jenkins平台上就开始准备构建该JOB，此时任务会放到 <code>Build Queue</code> 中进行一系列的准备，如果此时再去调用 <code>cls.get_job_status()</code> 时候，JOB还在 <code>Build Queue</code> 中等待的话，则获取到的构建号仍然为4, 并且 status 为 False（如下结果的输出），所以还是返回了 “开始执行”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅当 build num 变成5后，才触发了异常。</span></span><br><span class="line">==========================</span><br><span class="line">build num 4</span><br><span class="line">指定Job result: SUCCESS</span><br><span class="line">指定Job status: False</span><br><span class="line">==========================</span><br><span class="line">build num 4</span><br><span class="line">指定Job result: SUCCESS</span><br><span class="line">指定Job status: False</span><br><span class="line">==========================</span><br><span class="line">build num 5</span><br><span class="line">指定Job result: None</span><br><span class="line">指定Job status: True</span><br></pre></td></tr></table></figure><p><strong>解决方案一：通过将执行记录存储到数据库中</strong>，每次执行之前，先去查询下是否存在下个构建号的记录。（ 如果有需要还可以通过行锁来控制此次的插入操作， 这样保证高并发下也能符合预期。）</p><p><strong>解决方案二（<font color=blue>推荐</font>）：通过 Jenkins 提供的接口 get_queue_info() 方法获取当前队列中的JOB列表</strong>，如果JOB已经在队列中，则直接返回异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体实现代码如下：job_name 是需要判断是否处于构建中的JOB名称， 再配合JOB的 status 来实现判断JOB任务是否已经开始构建。</span></span><br><span class="line">queue_info = server.get_queue_info()</span><br><span class="line"><span class="keyword">for</span> single_queue_info <span class="keyword">in</span> queue_info:</span><br><span class="line">  <span class="keyword">if</span> single_queue_info.get(<span class="string">&quot;task&quot;</span>, <span class="built_in">dict</span>()).get(<span class="string">&quot;name&quot;</span>) == job_name:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="问题二：-Jenkins-构建JOB时候，需要动态传入参数到-JOB中。"><a href="#问题二：-Jenkins-构建JOB时候，需要动态传入参数到-JOB中。" class="headerlink" title="问题二： Jenkins 构建JOB时候，需要动态传入参数到 JOB中。"></a>问题二： <a href="https://www.tqwba.com/x_d/jishu/207431.html">Jenkins 构建JOB时候，需要动态传入参数到 JOB中</a>。</h4><p><strong>解决方案：</strong>先通过Jenkins安装对应的插件：</p><ul><li><p><strong>Build With Parameters 输入框式的参数</strong></p></li><li><p><strong>Persistent Parameter 下拉框式的参数</strong></p></li></ul><p>Jenkins中的使用方法如下截图，通过点击 <code>Add Parameter</code> 新增变量来构建JOB。</p><img src="https://i.loli.net/2021/06/11/SIEcmVF59Xj4HRK.png" alt="jenkins-1.png" style="zoom:33%;" /><p>通过Python代码触发构建代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以字典形式传递参数进去即可，如上图的配置，代码中的参数格式：</span></span><br><span class="line"><span class="comment">#    params: &#123;</span></span><br><span class="line"><span class="comment">#        &quot;operator&quot;: &quot;auto_job&quot;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"></span><br><span class="line">server.build_job(job_name, parameters=params)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    很多时候，在解决问题的时候（特别是对于问题的相关知识不是太了解的情况下），如果只是紧急修复问题的话，思考出来的方案可能都不是一个比较合适的方案。所以在空闲时候可以再回过来看看问题，说不定能够想到更多的解决方案。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/anliven/p/13642675.html">JENKINS-API 详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
            <tag> JENKINS API </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-table + dialog出现卡顿</title>
      <link href="vue-element-table-dialog%E5%87%BA%E7%8E%B0%E5%8D%A1%E9%A1%BF/"/>
      <url>vue-element-table-dialog%E5%87%BA%E7%8E%B0%E5%8D%A1%E9%A1%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在编写前端功能时候，最近比较频繁的使用了Element中的<strong>Table</strong>以及<strong>Dialog</strong>结合，这样可以方便对某一行的数据进行展示或者操作，具体效果如下（点击某行的查看，弹出对于该行的一个内容展示或者操作）：</p><img src="https://i.loli.net/2021/04/28/nRXPuSK4dyYrvWb.png" alt="element-table-dialog卡顿-1.png" style="zoom:30%;" /><p>​    但是<strong>随着表格的行数增加，会出现明显的卡顿现象</strong>，具体样式如下（<strong>并且能明显发现Dialog的边特别粗</strong>）：</p><img src="https://i.loli.net/2021/04/28/SP4LRKY3DJ5n8F1.png" alt="element-table-dialog卡顿-2.png" style="zoom:40%;" /><a id="more"></a><hr><p>我是华丽的分割线～ （<strong>更新于 2021-9-18</strong>）</p><p>基于评论的建议，发现整个事件在处理上有点问题，<font color=red>属于头疼医头，脚疼医脚。没有去找到根本原因，而仅仅是去找了解决方案</font>😂。在出现了这个问题后，就马上去找解决方案， 但<font color=blue>为什么存在上述的原因，却没有仔细去思考（后续一定要注意）</font>，实际原因是：因为将Dialog放在了Table的scope范围内，所以导致有多少行就会存在多少个Dialog。 </p><p><strong>最简单的解决办法： 将Dialog代码从Table的scope范围内移出即可。</strong></p><p>❌ <strong>原来的错误使用场景</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-table :data&#x3D;&quot;tableData&quot; border style&#x3D;&quot;width: 100%&quot;&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;操作&quot; width&#x3D;&quot;100&quot;&gt;</span><br><span class="line">      &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;dialogVisible &#x3D; true&quot; type&#x3D;&quot;text&quot; size&#x3D;&quot;small&quot;&gt;查看&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;!-- Dialog位置不应该放在此处，导致处于Table的行所在的层级 --&gt;</span><br><span class="line">        &lt;el-dialog title&#x3D;&quot;提示&quot; :visible.sync&#x3D;&quot;dialogVisible&quot; width&#x3D;&quot;30%&quot; :before-close&#x3D;&quot;handleClose&quot; :append-to-body&#x3D;&#39;true&#39;&gt;</span><br><span class="line">          &lt;span&gt;这是一段信息&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">            &lt;el-button @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">          &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;el-dialog&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;el-table-column&gt;</span><br><span class="line">  &lt;&#x2F;el-table&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      dialogVisible: false,</span><br><span class="line">      tableData: [&#123;date: &quot;2016-05-02&quot;&#125;, &#123;date: &quot;2016-05-02&quot;&#125;, &#123;date: &quot;2016-05-02&quot;&#125;, &#123;date: &quot;2016-05-02&quot;&#125;, &#123;date: &quot;2016-05-02&quot;&#125;],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>✅ <strong>正确使用方式</strong> （唯一的区别在于上面代码dialog在scope内，下面代码不在）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-table :data&#x3D;&quot;tableData&quot; border style&#x3D;&quot;width: 100%&quot;&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;操作&quot; width&#x3D;&quot;100&quot;&gt;</span><br><span class="line">      &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;dialogVisible &#x3D; true&quot; type&#x3D;&quot;text&quot; size&#x3D;&quot;small&quot;&gt;查看&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;el-dialog title&#x3D;&quot;提示&quot; :visible.sync&#x3D;&quot;dialogVisible&quot; width&#x3D;&quot;30%&quot; :before-close&#x3D;&quot;handleClose&quot; :append-to-body&#x3D;&#39;true&#39;&gt;</span><br><span class="line">      &lt;span&gt;这是一段信息&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br><span class="line">    &lt;&#x2F;el-table-column&gt;</span><br><span class="line">  &lt;&#x2F;el-table&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      dialogVisible: false,</span><br><span class="line">      tableData: [&#123;date: &quot;2016-05-02&quot;&#125;, &#123;date: &quot;2016-05-02&quot;&#125;, &#123;date: &quot;2016-05-02&quot;&#125;, &#123;date: &quot;2016-05-02&quot;&#125;, &#123;date: &quot;2016-05-02&quot;&#125;],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>至此，问题解决的又快速，代码写的又简单。但原来却花了那么老大的功夫去折腾下面那一堆代码</strong>╮(╯Д╰)╭ 。</p><hr><p>我是华丽的分割线～ （更新于 2021-5-19）</p><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><p>​    查看Demo代码发现， Dialog显示框是通过属性 <code>:visible.sync=&quot;centerDialogVisible&quot;</code> 来控制的（关于<a href="https://www.jianshu.com/p/8180cd256d55">visible.sync</a>可参考<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6">官网</a>），但由于该变量仅有一个，绑定在了所有的行上面，猜想：<font color=red><strong>点击任意一行，都会导致触发多次Dialog的打开。</strong></font>通过如下代码来进行验证下：（主动触发Dialog open事件<a href="https://blog.csdn.net/Luckyzhoufangbing/article/details/93719623">参考链接</a>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通过添加触发Dialog中的Open event打印出共打开多少次Dialog，来验证猜想 --&gt;</span><br><span class="line">&lt;el-dialog</span><br><span class="line">...</span><br><span class="line">  :visible.sync&#x3D;&quot;centerDialogVisible&quot;</span><br><span class="line">  @open&#x3D;&#39;open&#39;</span><br><span class="line">  ...&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">open</span>(<span class="params"></span>)</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;test dialog open&quot;</span>);&#125;</span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 最终控制台输出：40 test dialog open test-demo.vue:75</span></span><br><span class="line"><span class="comment">// tableData的长度为20</span></span><br></pre></td></tr></table></figure><p>问题的根本原因：由于仅仅是绑定了单个变量 centerDialogVisible， 所以<font color=red><strong>随着表格数据的增加，对应打开的Dailog个数等于表格数据的长度 X 2。</strong></font></p><p><em><font color=red>新增疑问：为什么触发Dialog自带的Open事件数量刚好是长度的2倍？</font></em></p><p>解答：通过<code>Visual Studio Code</code>工具调试后发现，代码在点击了查看按钮打开Dialog后，会触发 <code>flushSchedulerQueue</code> 方法，在这个过程中， 虽然从代码层面仅仅对 visible 进行了一次修改，但由于Element内部的 <code>el-table</code> 和 <code>el-dialog</code>自带的Watcher监听，最终将 visible 的变化在队列中存放了两次，所以内部的open方法也被触发了两次。（有兴趣的可深入了解 element-ui.common.js）</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="方案一：Dialog-通过每一行的特有属性控制"><a href="#方案一：Dialog-通过每一行的特有属性控制" class="headerlink" title="方案一：Dialog 通过每一行的特有属性控制"></a>方案一：Dialog 通过每一行的特有属性控制</h4><p>既然是由于绑定了同一个变量<code>centerDialogVisible</code>，那么可以通过对tableData的每一行添加一个centerDialogVisible属性，具体实行的效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog title&#x3D;&quot;提示&quot; :visible.sync&#x3D;&quot;scope.row.dialogFlag&quot; width&#x3D;&quot;30%&quot; @open&#x3D;&#39;open&#39; center&gt;</span><br><span class="line">...</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;closeDialog(scope.row)&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;closeDialog(scope.row)&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br></pre></td></tr></table></figure><p>该方案能够解决卡顿以及黑边的问题，但存在如下问题：</p><ul><li><p><strong>问题一：</strong>close-on-click-modal（是否可以通过点击 modal 关闭 Dialog）和close-on-press-escape（是否可以通过按下 ESC 关闭 Dialog）无法触发Dialog关闭；</p><p>对Demo中的代码深入研究下源码会发现分别触发如下的代码，最终都是通过 hide()方法将Dialog关闭。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">handleWrapperClick: <span class="function"><span class="keyword">function</span> <span class="title">handleWrapperClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.closeOnClickModal) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">this</span>.handleClose();</span><br><span class="line">&#125;,</span><br><span class="line">handleClose: <span class="function"><span class="keyword">function</span> <span class="title">handleClose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.beforeClose === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.beforeClose(<span class="built_in">this</span>.hide);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.hide();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">hide: <span class="function"><span class="keyword">function</span> <span class="title">hide</span>(<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cancel !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.$emit(<span class="string">&#x27;update:visible&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">this</span>.$emit(<span class="string">&#x27;close&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.closed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>通过Dialog自带的close事件查看对应绑定的Table值，可以发现Table中对应的 <code>dialogFlag</code> 已经更新了，但至于无法触发Dialog关闭的原因同<strong>问题2</strong>，因为绑定的变量不是<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1">响应式</a>。解决方案如下（新增自定义的close方法）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog title&#x3D;&quot;提示&quot; :visible.sync&#x3D;&quot;scope.row.dialogFlag&quot; width&#x3D;&quot;30%&quot; @close&#x3D;&#39;close&#39; center&gt;</span><br><span class="line">...</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> closeRow = <span class="built_in">this</span>.tableData[<span class="built_in">this</span>.showDialogRowIndex]</span><br><span class="line">  <span class="built_in">this</span>.$set(<span class="built_in">this</span>.tableData, <span class="built_in">this</span>.showDialogRowIndex, closeRow)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>问题二：</strong>需要变量使用<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1">响应式</a>解决tableData数据更新后页面无响应的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleDialog</span>(<span class="params">row</span>)</span> &#123;</span><br><span class="line">  row.dialogFlag = <span class="literal">true</span></span><br><span class="line">  <span class="built_in">this</span>.$set(<span class="built_in">this</span>.tableData, row.count, row);<span class="comment">// 不添加响应式修改table数据的话，则Dialog无法正常打开</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="方案二：通过-v-if-与-visible-sync-共同控制"><a href="#方案二：通过-v-if-与-visible-sync-共同控制" class="headerlink" title="方案二：通过 v-if 与 :visible.sync 共同控制"></a>方案二：通过 v-if 与 :visible.sync 共同控制</h4><p>直接通过定义一个变量 <strong>dialogStatus</strong>，响应式的去控制Dialog的展示，具体核心代码如下：</p><p>这样就不需要通过 <code>this.$set(this.tableData, this.showDialogRowIndex, closeRow)</code> 强制刷新Table信息。</p><p><font color=gray><em>PS：为什么使用 v-if 可以参考：<a href="https://cn.vuejs.org/v2/guide/conditional.html">v-if 与 v-show的区别</a></em></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog </span><br><span class="line">  ...</span><br><span class="line">  :visible.sync&#x3D;&quot;scope.row.dialogFlag&quot; </span><br><span class="line">  v-if&#x3D;&quot;dialogStatus.rowIndex &#x3D;&#x3D;&#x3D; scope.row.count &amp;&amp; dialogStatus.dialogStatus&quot;</span><br><span class="line">  &gt;</span><br><span class="line">...</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dialogStatus: &#123;</span><br><span class="line">      rowIndex: -<span class="number">1</span>,</span><br><span class="line">      dialogStatus: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">handleDialog</span>(<span class="params">row</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.showDialogRowIndex = row.count<span class="comment">// count 属性可以用 row自带的index属性替换，等同于行号, 从0开始</span></span><br><span class="line">    <span class="built_in">this</span>.centerDialogVisible = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.dialogStatus.rowIndex = row.count</span><br><span class="line">    <span class="built_in">this</span>.dialogStatus.dialogStatus = <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">closeDialog</span>(<span class="params">row</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.centerDialogVisible = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.showDialogRowIndex = -<span class="number">1</span></span><br><span class="line">    <span class="built_in">this</span>.dialogStatus.rowIndex = -<span class="number">1</span></span><br><span class="line">    <span class="built_in">this</span>.dialogStatus.dialogStatus = <span class="literal">false</span>   </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>.dialogStatus.rowIndex = -<span class="number">1</span>      </span><br><span class="line">    <span class="built_in">this</span>.dialogStatus.dialogStatus = <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案比较完美并且简单的解决了卡顿和Dialog黑边的场景，但会存在黑屏效果。可以使用 Dialog的属性 <code>:append-to-body=&#39;true&#39;</code> 解决该问题。</p><img src="https://i.loli.net/2021/04/29/1DK2ZRr3FBE6fpN.png" alt="element-table-dialog卡顿-3.png" style="zoom:40%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog :append-to-body&#x3D;&#39;true&#39;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br></pre></td></tr></table></figure><p><em><font color=gray>PS：暂时仅思考了上述两种解决方案，如果有其他前端大佬有更好的解决方案可在评论区留言。</font></em></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    虽然该问题不是一个太复杂的问题，但是通过这样一次整个问题的排查以及多种方案的思考，还是获益匪浅。其中包括了解了怎么去debug <code>node_modules</code> 中第三方源码的方法，如果一直秉持着这种态度去工作，时间久了肯定是会有质的变化。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Element UI </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次Pytest库升级遇到的问题</title>
      <link href="python-%E4%B8%80%E6%AC%A1Pytest%E5%BA%93%E5%8D%87%E7%BA%A7%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>python-%E4%B8%80%E6%AC%A1Pytest%E5%BA%93%E5%8D%87%E7%BA%A7%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>​    公司内部的接口自动化框架在一次pytest升级后，用例中的logging模块无法正常打印日志（原来logging.info可以正常打印日志到日志文件中，现在是不会输出到对应的日志文件中）。</p><p>​    <strong>存在的变更：原来使用 pytest==5.4.3 版本（后续称之为低版本）的时候，升级pytest后是6.2.3版本（后续称之为高版本）。</strong></p><a id="more"></a><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><h4 id="问题1-为什么使用高版本的Pytest库后，日志无法打印出来呢？"><a href="#问题1-为什么使用高版本的Pytest库后，日志无法打印出来呢？" class="headerlink" title="问题1: 为什么使用高版本的Pytest库后，日志无法打印出来呢？"></a>问题1: 为什么使用高版本的Pytest库后，日志无法打印出来呢？</h4><p>​    先统一测试代码，发现<font color=blue><strong>根本原因在于</strong></font>：<strong>高版本Pytest场景中，logging对象的root.handlers默认存在两个Handler，直接跳过了部分处理代码，最终使用两个Handler中默认的 _FileHandler 将日志写入到了/dev/null 中了。</strong> </p><blockquote><p>/dev/null  ： 在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。<br>在程序员行话，尤其是Unix行话中，/dev/null 被称为位桶(bit bucket)或者黑洞(black hole)。空设备通常被用于丢弃不需要的输出流，或作为用于输入流的空文件。这些操作通常由重定向完成。</p></blockquote><p>​    而低版本Pytest场景中，logging对象的root.handlers为空，进行处理后使用的是自定义的文件目录写入日志。(可对比两者的 <code>FileHandler</code> 对象区别，如下两图（上图为高版本的handlers，下图为低版本），<font color=gray><em>由于涉及到个人电脑目录，对低版本的日志文件路径进行了打码</em></font>)</p><img src="https://i.loli.net/2021/05/17/Yhq2xblTWJ9AE7n.png" alt="pytest-高版本打印日志问题.png" style="zoom:33%;" /><img src="https://i.loli.net/2021/05/17/EGOeSAfT5xJcbgQ.png" alt="低版本pytest-logging-handler.png" style="zoom:33%;" /><p>上述所述的部分处理代码如下（<code>logging库的__init__.py文件</code>， 低版本中通过 <code>len(root.handlers) == 0</code> 生成了用户自定义的 FileHandler对象）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicConfig</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    force = kwargs.pop(<span class="string">&#x27;force&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">    encoding = kwargs.pop(<span class="string">&#x27;encoding&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    errors = kwargs.pop(<span class="string">&#x27;errors&#x27;</span>, <span class="string">&#x27;backslashreplace&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> force:</span><br><span class="line">      <span class="keyword">for</span> h <span class="keyword">in</span> root.handlers[:]:</span><br><span class="line">        root.removeHandler(h)</span><br><span class="line">        h.close()</span><br><span class="line">    <span class="comment"># 高版本的Pytest在此处logging库中直接跳到最后，最终使用的是默认的 FileHandler，将内容打印到了/dev/null</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(root.handlers) == <span class="number">0</span>:</span><br><span class="line">      handlers = kwargs.pop(<span class="string">&quot;handlers&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">      <span class="keyword">if</span> handlers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>再深入一点继续往下探索！</p><h4 id="问题2-为什么高版本Pytest场景中，logging对象的root-handlers默认存在两个Handler？？"><a href="#问题2-为什么高版本Pytest场景中，logging对象的root-handlers默认存在两个Handler？？" class="headerlink" title="问题2: 为什么高版本Pytest场景中，logging对象的root.handlers默认存在两个Handler？？"></a>问题2: 为什么高版本Pytest场景中，logging对象的root.handlers默认存在两个Handler？？</h4><p>根本原因：高版本的Pytest对 <code>class LoggingPlugin</code> 类进行了修改，相关修改后导致出现该问题的代码如下（<strong>见注释部分</strong>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingPlugin</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Attaches to the logging module and captures log messages for each test.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, config: Config</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">...</span><br><span class="line">      <span class="comment"># 由于配置中未传入log_file配置，导致log_file默认为/dev/null</span></span><br><span class="line">      log_file = get_option_ini(config, <span class="string">&quot;log_file&quot;</span>) <span class="keyword">or</span> os.devnull</span><br><span class="line">      <span class="keyword">if</span> log_file != os.devnull:</span><br><span class="line">        directory = os.path.dirname(os.path.abspath(log_file))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(directory):</span><br><span class="line">          os.makedirs(directory)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 根据默认的log_file 生成一个_FileHandler对象，最终日志被写入到了/dev/null中</span></span><br><span class="line">      self.log_file_handler = _FileHandler(log_file, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 生成另外一个 _LiveLoggingNullHandler</span></span><br><span class="line">      self.log_cli_handler = _LiveLoggingNullHandler()</span><br></pre></td></tr></table></figure><p>上述代码中就生成了root.handlers中的默认的两个Handler，相对于低版本中的处理逻辑如下，由于未传入log_file配置，最终生成的 <code>log_file_handler</code> 和 <code>log_cli_handler</code> 都为None，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingPlugin</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Attaches to the logging module and captures log messages for each test.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, config: Config</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">...</span><br><span class="line">        log_file = get_option_ini(config, <span class="string">&quot;log_file&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> log_file:</span><br><span class="line">            self.log_file_handler = logging.FileHandler(</span><br><span class="line">                log_file, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">            )  <span class="comment"># type: Optional[logging.FileHandler]</span></span><br><span class="line">            self.log_file_handler.setFormatter(self.log_file_formatter)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.log_file_handler = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        self.log_cli_handler = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>​    至此大概的解决方案思路也清晰了，通过配置对应的 <code>log_file</code> 配置来解决，此处有两种方式。</p><ul><li><p>一种是直接写到根目录下的 <code>pytest.ini</code> 文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_file = data_factory_210517.log<span class="comment"># 该方式比较死板，如果想修改日志文件名称需要修改pytest.ini文件</span></span><br></pre></td></tr></table></figure></li><li><p>另外一种是直接通过 py.test 命令行执行的时候添加 <code>--log-file=xxx.log</code>（<font color=blue><strong>推荐</strong></font>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py.test --log-file=xxx.log <span class="comment"># 可在脚本中，根据用户自定义动态生成日志文件名称</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    大部分场景下，建议还是不要随意升级使用的组件库😭😭。。否则突然的改版可能会引起莫名其妙的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pytest </tag>
            
            <tag> Logging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask 序列化与反序列化</title>
      <link href="python-Flask-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>python-Flask-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    为什么写这篇话题呢，印象中是有次面试中，面试官问我是否了解 <code>Flask</code> 中的序列化与反序列化。由于自身的客观原因，当时对于该问题只能硬着头皮回答：不太了解乀(ˉεˉ乀) 乀(ˉεˉ乀) 。。。（个人觉得还是：基础知识不扎实）</p><p>​    后来这个问题也一直没去关注。。。此次突然想起来后进行一下记录（同样的地方不要翻车两次┑(￣。。￣)┍ ）。</p><a id="more"></a><h3 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h3><p>​    大概先了解了下相关定义：<code>Serialization</code> 和 <code>Deserialization</code> 即序列化和反序列化。Flask中是<strong>将对象类型数据转为json即为序列化</strong>，<strong>将json转为对象类型数据即为反序列化</strong>。</p><p>​    <strong>Flask</strong>中的序列化和反序列化还是比较简单，下面分别进行下理解。</p><h4 id="序列化-jsonify"><a href="#序列化-jsonify" class="headerlink" title="序列化 jsonify()"></a>序列化 jsonify()</h4><p>​    Flask jsonify()的代码还是很简单， 可以理解在默认情况下，Flask的序列化就是直接使用了 <code>json.dumps()</code>，再通过 <code>Response</code> 对象直接返回了 ╮(╯Д╰)╭ ，核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 唯一就是在用法上有点区别， Flask的jsonify会对传入的参数进行取舍，具体逻辑如下</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:  <span class="comment"># single args are passed directly to dumps()</span></span><br><span class="line">  data = args[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  data = args <span class="keyword">or</span> kwargs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终将 data 通过 json.dumps() 进行序列化</span></span><br><span class="line"><span class="keyword">return</span> current_app.response_class(</span><br><span class="line">  dumps(data, indent=indent, separators=separators) + <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  mimetype=current_app.config[<span class="string">&quot;JSONIFY_MIMETYPE&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>看到网上其他人说了一些更深层次的内容， <a href="https://m.yisu.com/zixun/227014.html">参考链接</a>，<a href="https://www.kancloud.cn/schip/klause/1021392">参考链接2</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下用的都是 app.json_encoder， 如果有特殊需求，可以对该encoder进行自定义</span></span><br><span class="line"><span class="keyword">if</span> app:</span><br><span class="line">  ...</span><br><span class="line">  kwargs.setdefault(</span><br><span class="line">    <span class="string">&quot;cls&quot;</span>, bp.json_encoder <span class="keyword">if</span> bp <span class="keyword">and</span> bp.json_encoder <span class="keyword">else</span> app.json_encoder</span><br><span class="line">  )</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  ...</span><br><span class="line">  kwargs.setdefault(<span class="string">&quot;cls&quot;</span>, JSONEncoder)</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 用户也可以通过对 app.json_encoder 进行二次封装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONEncoder</span>(<span class="params">_json.JSONEncoder</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;The default Flask JSON encoder. This one extends the default</span></span><br><span class="line"><span class="string">    encoder by also supporting ``datetime``, ``UUID``, ``dataclasses``,</span></span><br><span class="line"><span class="string">    and ``Markup`` objects.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    # 通过该对象可以定制化，比如我们要返回给前端的是一个从数据库查询的模型对象。那么就可以通过重写该方法进行定制化。</span></span><br></pre></td></tr></table></figure><h4 id="反序列化-request-get-json"><a href="#反序列化-request-get-json" class="headerlink" title="反序列化 request.get_json()"></a>反序列化 request.get_json()</h4><p>​    同样的。。。 Flask的反序列化也挺简单，可以理解在默认情况下， Flask的反序列化就是直接使用了 <code>json.loads()</code>，核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data = self._get_data_for_json(cache=cache)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  rv = self.json_module.loads(data)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># self.json_module.loads()</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(s, <span class="built_in">bytes</span>):</span><br><span class="line">  <span class="comment"># Needed for Python &lt; 3.6</span></span><br><span class="line">  encoding = detect_utf_encoding(s)</span><br><span class="line">  s = s.decode(encoding)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _json.loads(s, **kw)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    额。。。本来以为是什么，实际查了下对应的资料后，从比较浅的层次来说， Flask中的序列化以及反序列化实际就是使用的 json库中自带的 <code>dumps</code> 和  <code>loads</code> 。（也可能是才疏学浅，没有太了解深层次的使用场景😂， 比如： <a href="https://m.yisu.com/zixun/227014.html">Flask序列化</a>），所以，不要被一些 “名词” 高大上的样子忽悠了，可能实际内容并不复杂，<strong>困难的是做出去解决这个问题的决心</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Python </tag>
            
            <tag> 序列化与反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断Excel文件中是否存在合并单元格</title>
      <link href="python-%E5%88%A4%E6%96%ADExcel%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC/"/>
      <url>python-%E5%88%A4%E6%96%ADExcel%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在用例管理平台上可以编辑Excel用例文件，但如果上传了合并单元格的Excel用例文件，编辑时候处理起来会无法判断如何去拆解单元格，最终解决方式是：禁止上传存在合并单元格的Excel文件。（那么就<strong>需要在上传的时候校验文件中是否存在合并单元格。</strong>）</p><p>​    通过网上的资料查询了下，实现方案就是通过 <code>sheet.merged_cells</code> 来解决该问题，核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">workbook = xlrd.open_workbook(<span class="string">r&#x27;py.xlsx&#x27;</span>)</span><br><span class="line">sheet = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 如果该值返回的列表长度非0则存在合并单元格，否则不存在。</span></span><br><span class="line"><span class="keyword">return</span> sheet.merged_cells</span><br></pre></td></tr></table></figure><a id="more"></a><p>​    <font color=gray><em>PS: 本文主要是记录下过程中遇到的问题以及一些扩展。</em></font></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="问题1-后端报错：expected-str-bytes-or-os-PathLike-object-not-FileStorage"><a href="#问题1-后端报错：expected-str-bytes-or-os-PathLike-object-not-FileStorage" class="headerlink" title="问题1: 后端报错：expected str, bytes or os.PathLike object, not FileStorage"></a>问题1: 后端报错：expected str, bytes or os.PathLike object, not FileStorage</h4><p>​    由于文件是直接通过前端上传的，所以传到后端是一个 <code>FileStorage</code> 对象，通过上述方式实现会直接报错。如果仅仅是简单的通过 <code>file_storage.read()</code> 转换成 bytes 后，仍然会有其他新的报错（<code>embedded null byte</code>）。</p><p>​    最终使用如下方案来进行解决（因为后端原本都是使用 <code>Pandas</code> 库去处理Excel文件的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">book = openpyxl.load_workbook(case_file)</span><br><span class="line">writer = pd.ExcelWriter(case_file, engine=<span class="string">&#x27;openpyxl&#x27;</span>)</span><br><span class="line">writer.book = book</span><br><span class="line"></span><br><span class="line">writer.sheets = <span class="built_in">dict</span>((ws.title, ws) <span class="keyword">for</span> ws <span class="keyword">in</span> book.worksheets)</span><br><span class="line"><span class="keyword">for</span> sheet <span class="keyword">in</span> writer.sheets.values():</span><br><span class="line">  merged_list = sheet.merged_cells</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(merged_list.ranges) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;【%s】文件内容错误, 暂不支持文件中存在合并的单元格。&quot;</span> % case_file.filename)</span><br></pre></td></tr></table></figure><p>验证了下，在上传带有单元格的文件时，会触发异常，正准备高高兴兴码完代码休息下～(￣▽￣～)(～￣▽￣)～ 。然而出于基本的开发素质，我又验证了不带单元格的文件。然而打脸总是来的这么突然。。。😭。</p><p>​    上传失败，后端返回错误 <code>OSError: [Errno 22] Invalid argument</code>。（<strong>事实再次证明：不要以为功能简单就不验证</strong>(￣ε ￣) 。。。老铁，来吧！继续撸袖子修BUG。）</p><h4 id="问题2-OSError-Errno-22-Invalid-argument"><a href="#问题2-OSError-Errno-22-Invalid-argument" class="headerlink" title="问题2:  OSError: [Errno 22] Invalid argument"></a>问题2:  OSError: [Errno 22] Invalid argument</h4><p>​    通过本地调试，发现触发异常的位置在文件被上传保存后，再次去读取该文件内容的时候。抛错的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = pd.ExcelFile(file_abs_path)</span><br></pre></td></tr></table></figure><p>看了下文件的剧对路径，确定文件是存在的，然后去下载下来打开时，提示文件打开遇到错误。。。（并且此时的文件大小小于实际文件的大小，原文件17KB，上传后的文件12KB）。</p><img src="https://i.loli.net/2021/04/14/F69Xw2OopIKJg4G.png" alt="file-storage-4.png" style="zoom:50%;" /><p>​    通过一步步的调试，发现罪魁祸首在于 <code>openpyxl.load_workbook(case_file)</code>，该操作会直接对传入的 <strong>FileStorage</strong> 对象进行操作，导致文件内容变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原数据 case_file.read() 大小为16804，处理后case_file.read() 大小为11528</span></span><br><span class="line">openpyxl.load_workbook(case_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于为什么文件大小会变小，是因为操作中会将缓存内的文件内容读取，导致实际在缓存内的内容变少，有兴趣的可以深入研究，核心代码如下：</span></span><br><span class="line">reader = ExcelReader(filename, read_only, keep_vba, data_only, keep_links)</span><br><span class="line">reader.read()</span><br></pre></td></tr></table></figure><p><strong>最终解决方案则是</strong>：在问题1的代码块后， 新增代码：<code>case_file.stream.seek(0)</code>  即可，通过将原 <code>FileStorage</code> 对象缓存里面的内容指向最初的位置即可。</p><h4 id="问题3-xlrd-biffh-XLRDError-File-size-is-0-bytes"><a href="#问题3-xlrd-biffh-XLRDError-File-size-is-0-bytes" class="headerlink" title="问题3: xlrd.biffh.XLRDError: File size is 0 bytes"></a>问题3: xlrd.biffh.XLRDError: File size is 0 bytes</h4><p>在获得最终解决方案的过程之前，还遇到了问题3，因为 <strong>FileStorage</strong> 对象在内存中的内容已经被拿出来操作了，实际缓存中的数据大小变成了0，导致了上述的报错。（<a href="https://www.pythonheidong.com/blog/article/754328/9439a5fd9830ea11dd92/">参考链接</a>），如下是对于 <strong>FileStorage</strong> 对象的一个注解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.datastructures <span class="keyword">import</span> FileStorage</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStorage</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;The :class:`FileStorage` class is a thin wrapper over incoming files.</span></span><br><span class="line"><span class="string">    It is used by the request object to represent uploaded files.  All the</span></span><br><span class="line"><span class="string">    attributes of the wrapper stream are proxied by the file storage so</span></span><br><span class="line"><span class="string">    it&#x27;s possible to do ``storage.read()`` instead of the long form</span></span><br><span class="line"><span class="string">    ``storage.stream.read()``.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    通过上述一系列的骚操作（瞎折腾）后，终于完成了最初的需求。。。╮(╯Д╰)╭ ，因为过程中很多奇奇怪怪得报错导致整个过程还是挺艰辛的。</p><p>​    <strong>⚠️ 心得</strong>：大多数时候都是网上直接搜了解决方案，但是由于基础不扎实，在进行实施的时候，各种坑就埋在你脚下了。。。有些时候需要<strong>更多的去思考或者了解为什么使用这个方案，以及询问自己更多次为什么会出现这个问题，而不仅仅是解决。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
            <tag> Excel文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小强升职记读后感</title>
      <link href="%E8%AF%BB%E5%90%8E%E6%84%9F-%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>%E8%AF%BB%E5%90%8E%E6%84%9F-%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    时光飞逝。。。转眼就工作了6年了（已经转变成了一个老油条）┑(￣Д ￣)┍ ，有时候会感觉这时间都去哪里了？</p><p>​    在工作中平时有时候挺忙的，总感觉时间不太够用；有时候想起来要锻炼身体，但又觉得时间不太够，所以一拖再拖。缺乏人际关系的维护以及缺乏生活中的其他乐趣，感觉生活越发的枯燥无味。<strong>如果读者和我有同样的感受，那么强烈推荐继续阅读下去。</strong></p><p>​    有幸的是我察觉了这个问题的严重性，主动去找时间管理的书籍开始阅读，首先接触的是<a href="https://book.douban.com/subject/25852981/">《小强升职记》</a>，在通读全书后收益颇丰。（PS：如果已经是时间管理的大佬了就可以直接跳过该文章了。）</p><a id="more"></a><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>​    本书中以 “小强” 的故事向你娓娓道来，把时间管理的精华融入鲜活的情景。对于我这种工作年限的职场打工人来说，内容浅显易懂并且符合现实场景。</p><p>​    下面对每个章节进行了简单的整理以及一些个人的理解。</p><h4 id="1-时间去哪里了"><a href="#1-时间去哪里了" class="headerlink" title="1. 时间去哪里了"></a>1. 时间去哪里了</h4><p>​    在6年的工作中，有些时候总感觉自己很忙，但实际回想起来，都不知道是在忙什么。</p><p>​    本章的第一个问题就深深的触动了我一一<font color=red><strong>自己真的很忙么？</strong></font>通过事实先确认自己是否很忙，然后再去分析时间的真实去向。我按照书中的方法后，明显发现<strong>自己至少浪费了一半的时间</strong>在无意义的事情上（如果算每天仅工作8小时，也就是有4～5个小时是浪费的）。</p><p>​    本章节的重点在于：<code>发现自己的时间黑洞以及找到自己的高效时段。</code></p><img src="https://i.loli.net/2021/03/30/YJCM5HIQruhOe8t.png" alt="小强升职记-1.png" style="zoom:40%" /><h4 id="2-无压工作术"><a href="#2-无压工作术" class="headerlink" title="2. 无压工作术"></a>2. 无压工作术</h4><p>​    既然发现浪费了这么多时间，怎么快速的缓解以及改善这个问题呢？</p><p>​    第二章中先对所有的事情进行了一个分类一一四象限分类（使用矩阵法从重要、紧急两个维度进行划分），一个比较完美的状态应该是大多数时候在处理 <code>重要不紧急</code> 的事情（第二象限的事情）。但实际工作中并不如意，就我个人而言，大多数每天的工作可能都处于 <code>重要紧急</code>、<code>不重要紧急</code>、<code>不重要不紧急</code> ╮(╯Д╰)╭ 。</p><p>​    比如：早上原计划要完成功能A的开发或者测试，但是突然被通知早上要开会，任务被拖延到了下午，到了下午正准备开始或者开始了一半，突然又被通知去完成事件B、C、D等，在这种反复中断的情况下，最终原定的计划”顺利”的拖延到了第二天╮(╯Д╰)╭ 。这种情况对于职场新人可能屡见不鲜。</p><p>​    然后介绍了一些初级的时间管理方法，如：第二象限工作法、猴子法则、<code>衣柜整理法</code>。（PS：通过衣柜整理法，我初步的感觉到自己掌控了时间，而不是时间掌控我）</p><p>​    本章节的重点在于：<code>掌握衣柜整理法。</code></p><img src="https://i.loli.net/2021/03/30/3LnoKFDR9ksCcmB.png" alt="小强升职记-2.png" style="zoom:40%;" /><h4 id="3-遇到问题怎么办"><a href="#3-遇到问题怎么办" class="headerlink" title="3. 遇到问题怎么办"></a>3. 遇到问题怎么办</h4><p>​    在第二章中介绍了初级的时间管理方法，但肯定会遇到各种各样的问题（没有哪个方法是可以试用所有场景的）。第三章中紧接着就介绍了相对的应对措施。比如：</p><ul><li><p><strong>臣服精力、臣服环境、臣服天性；</strong></p><p>其中对于臣服天性让我印象比较深刻，书中通过引用了<a href="https://book.douban.com/subject/10828002/">《游戏改变世界》</a>这本书的理念，让我更加深刻理解如何去对待工作。</p><p><strong>为什么大家喜欢玩游戏</strong>，如英雄联盟、魔兽世界等？我个人理解最重要的一点就是：<strong>及时反馈</strong>。比如：英雄联盟里面的排位到了最强王者，那么平时和伙伴聊天的时候看着别人羡慕的表情，又或者魔兽世界里面工会成为第一个开荒成功的团队所带来的自豪感等等。</p><p>反过来就很容易得出<strong>为什么大家不喜欢工作</strong>，工作中常常是琐碎的杂事、大部分时候的工作又是没有任何的反馈等等，那么久而久之大家就厌烦了工作。（有兴趣的可自行阅读）</p></li><li><p><strong>做事靠系统，不是靠感觉。</strong></p><p>这个就需要我们多对平时的工作进行复盘（每日回顾、每周回顾等），总结出自己的经验，这样才不至于每次遇到问题都和无头苍蝇一样到处乱撞。</p></li></ul><p>​    本章节的重点在于：<code>学会臣服。</code></p><img src="https://i.loli.net/2021/03/30/jflcPNLtbX7OQ1M.png" alt="小强升职记-3.png" style="zoom:40%;" /><h4 id="4-如何养成一个好习惯"><a href="#4-如何养成一个好习惯" class="headerlink" title="4. 如何养成一个好习惯"></a>4. 如何养成一个好习惯</h4><p>​    很多时候，<font color=red><strong>道理大家都懂，但就是不那样去做</strong> </font>😂😂。。。就好像上述的几章已经很详细的介绍了时间管理该如何做，但是你要是不能按照上述的方法来做，那也等于白看。恰巧本章介绍了如何去养成一个好的习惯。</p><p>​    这个过程还是比较艰难的，每个人可能又不太一样，我是在实践2～3个月后，才算勉强初步养成了 <code>衣柜整理法</code> 的习惯。可能有人问：为什么要学时间管理？用一句话就是：自律即自由。（因为是你在主动掌控时间了，大多数时候可以选择什么时候干什么，而不是在什么时候被动的去干什么，比如：计划周末去公园踏春，但由于周内没按时完成工作任务，时间都用去玩游戏、逛街等等，那就只能周末被迫的加班完成。）</p><p>​    本章节重点在于：<code>通过借鉴书中方法，形成自己的养成好习惯的方法。</code></p><img src="https://i.loli.net/2021/03/30/1hepGAWuFvbkrjJ.png" alt="小强升职记-4.png" style="zoom:40%;" /><h4 id="5-如何让想法落地"><a href="#5-如何让想法落地" class="headerlink" title="5. 如何让想法落地"></a>5. 如何让想法落地</h4><p>​    随着工作的时间越来越久，有时候我会有些其他想法，比如：<strong>非工作方向</strong>就是全国旅游、学习潜水、滑雪等，<strong>工作方向</strong>就是开发一个内部平台、全方面的学习Docker、sonar扫描等…但这些想法大部分时间都<strong>仅仅是在自己脑海里面自嗨</strong>。。。</p><p>​    本章通过小强的一个想法，很接地气的描述了如何让这个想法落地，个人觉得该方法十分实用（有兴趣的可以仔细去阅读一遍）。该方法主要涉及的有： <code>SMART原则</code>、<code>思维脑图</code>、<code>甘特图</code>，这些在工作后就有所接触，所以该方法接纳起来还是比较容易。</p><p>​    还有一个比较新颖的观点是：<code>九宫格平衡人生</code>，这个再一次打开了我的思维，由于原来的时间大部分花费在工作上，所以很容易出现生活枯燥无味的想法。在接触了这个观点后，瞬间又觉得生活可以绚丽多彩。</p><p>​    本章节重点在于：<code>通过熟练掌握SMART原则、思维脑图、甘特图等工具，最终让想法真实落地。</code></p><img src="https://i.loli.net/2021/03/30/tPRj2b5TQimGZsg.png" alt="小强升职记-5.png" style="zoom:40%;" /><h3 id="书中语录"><a href="#书中语录" class="headerlink" title="书中语录"></a>书中语录</h3><ul><li><strong>时间管理，管理的是承诺；</strong></li><li><strong>做事靠系统，而不是靠感觉；</strong></li><li><strong>不要问自己 “该往哪儿走”，只要回答自己 “想往哪儿走”；</strong></li><li><strong>优秀的人有优秀的系统， 普通的人有普通的系统，失败的人没有系统；</strong></li><li><strong>力量来自于你的内心；</strong></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    整体而言，这本书对于一个未接触过时间管理的小白来说，还是很经典的一本书！个人认为在看完本书后，收益颇丰。</p><p>​    在实践了2～3个月后，也有了一些自己的见解，虽然书中的实例很接地气，但是真正在实践的过程中，不一定那么顺利。所以最主要的还是通过不断的实践，<code>将这一套 &quot;小强&quot;的时间管理方法变成自己的 &quot;时间管理方法&quot;！</code></p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 时间管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构化思维读后感</title>
      <link href="%E8%AF%BB%E5%90%8E%E6%84%9F-%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>%E8%AF%BB%E5%90%8E%E6%84%9F-%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在几次工作总结或者是处理事情上觉得自己的思维比较混乱，比如：在周会上想和组员进行一些内容分享，但由于开始没准备充分，在实际讲的过程中比较混乱，自己讲完后都觉得难以吸收；还有就是在表达自己想法的时候，思路比较天马行空，往往是讲着讲着就没什么逻辑关联，导致听起来云里雾里的。</p><p>​    于是网上搜索了下相关书籍，推荐了 <a href="http://byteliu.com/PDF/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86.pdf">《金字塔原理》</a>，但看了几章后感觉不太好时间，又找了这本 <a href="https://read678.com/JdBook/index/16756">《结构化思维》</a>，个人感觉还是很符合<strong>入门级别的结构化思维书籍</strong>（后续可以再进行金字塔原理的阅读），借此在看完整本后再进行一个整体回顾。（<em>PS：个人觉得这本书阅读完后收益还是挺多的。</em>）</p><a id="more"></a><h3 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h3><p>​    本书总共五章，下面分别对每一篇进行一个总结。前3章基本上是对于思维相关的介绍（如思维的意义、思维的过程等），第4章是详细的介绍了金字塔结构，第5章是介绍了常用的几种思维模型。</p><h4 id="第一章-初识思维"><a href="#第一章-初识思维" class="headerlink" title="第一章 初识思维"></a>第一章 初识思维</h4><p>​    本章节的内容还是比较简单，个人理解 <code>最主要的就是理解思维的意义</code>，如果对于看文章没什么太大兴趣的，推荐去看<strong>刘德华的《拆弹专家2》</strong>这部电影（刚好是我在看这本书的过程中看到的一部电影，很形象的描述了主角在影片中思维对他的影响），这也是书籍中介绍的故事思维可以更容易让人理解一个道理😂😂。（<font color=blue><em>脑图中有颜色标记的是我个人认为更加需要注意的点</em>，后面不再重复阐述</font>）</p><img src="https://i.loli.net/2021/03/23/xbE8FB4tQUAzih6.png" alt="结构化思维-1-初识思维.png" style="zoom:40%;" /><h4 id="第二章-深入思维"><a href="#第二章-深入思维" class="headerlink" title="第二章 深入思维"></a>第二章 深入思维</h4><p>​    本章节介绍的概念较多，其中我个人认为比较重要的有两个点。（⚠️ 注意：<strong>思维是一直在变化的</strong>，每个人在不同年龄或者不同场景下，都可能对同一件事情有不同的看法、态度。）</p><ul><li><p><strong>信息的获取</strong></p><p>在现实生活中可能常常看到墙壁上贴着宽带一年只要599、2室1厅一年仅要2000等等，当你真正打电话过去咨询的时候别人会告诉你这些都没了，大多数时候<font color=red><strong>你很容易获得的信息都是别人故意让你看到的信息</strong></font>，所以不要因为看到某些信息后就马上给出定论。</p></li><li><p><strong>信息的加工</strong></p><p>对于平时<strong>工作经历应该多进行归纳</strong>，这样才能形成属于自己特定的经验。再对自己<strong>总结的经验（结论）多进行演绎</strong>，这样才能验证这些经验（结论）的正确性，通过这样的良性循环，最终形成自己的方法论才能更好的成长。</p></li></ul><img src="https://i.loli.net/2021/03/23/fKapOt59MdQh8rC.png" alt="结构化思维-2-深入思维.png" style="zoom:40%;" /><h4 id="第三章-归纳与演绎"><a href="#第三章-归纳与演绎" class="headerlink" title="第三章 归纳与演绎"></a>第三章 归纳与演绎</h4><p>​        本章节比较细致介绍了归纳与演绎。这里就不做详细的阐述，有兴趣可以自行翻阅本书进行了解。</p><img src="https://i.loli.net/2021/03/23/M71tPoJSgCGxp5n.png" alt="结构化思维-3-归纳和演绎.png" style="zoom:40%;" /><h4 id="第四章-结构化思维"><a href="#第四章-结构化思维" class="headerlink" title="第四章 结构化思维"></a>第四章 结构化思维</h4><p>​    本章节是对于金字塔结构的一个专辑讲解，这也是我看完后对金字塔结构更深入的理解，方便后面对《金字塔原理》进行阅读。</p><p>​    个人理解 <code>最重要的为金字塔结构四个原则：结论先行、以上统下、归类分组、逻辑递进。</code>，然后在这四个中比较难的主要在于归类分组以及逻辑递进（这个也正好是我觉得自己最需要加强的能力），其中讲解的几个方法在看了后深有感触。比如：</p><ul><li><strong>归类分组</strong>：<strong>二分法、矩阵法、公式法、流程法</strong>这些在平时工作中常常遇见，所以运用起来更加容易上手。</li><li><strong>逻辑递进</strong>：<strong>时间顺序、重要性顺序</strong>等。</li></ul><img src="https://i.loli.net/2021/03/23/YRgfOQbKqvHAChk.png" alt="结构化思维-4.png" style="zoom:40%;" /><h4 id="第五章-常用的思维模型"><a href="#第五章-常用的思维模型" class="headerlink" title="第五章 常用的思维模型"></a>第五章 常用的思维模型</h4><p>​    本章最终是介绍了常用的思维模型（<font color=gray><em>部分思维模型可能觉得有点重复就未进行梳理</em></font>），个人再根据我自己的理解进行了一个排序：<strong>5W2H、流程思维、故事思维、客户思维</strong>。并且在我个人的工作经验中，发现 <code>流程思维</code> 和 <code>客户思维</code> 更是自己的短板，比如在客户思维中的实例中：加班较多并且也没有给自己加工资，此时仅仅是抱怨老板或者领导么？自己是否恰当的去反馈了这些问题呢？（如：你是否工作安排合理？ 你是否缺乏时间管理意识等等）。</p><img src="https://i.loli.net/2021/03/23/ATfn8eIqb3zvmVu.png" alt="结构化思维-5-思维模型.png" style="zoom:45%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    不管是生活中还是工作中，思维都起到一个重要的作用，乐观而又积极的思维会让你的生活丰富多彩，悲观而又消极的思维会让你的生活黯然失色，引用书中的一句话： <code>如果过往事实不能改变，我们就只能改变思维，改变面对事实的态度和行为，让未来过得更好，避免发生悲剧。改变思维才是改变一切的源头。</code> </p><p>​    看书的最重要的点就是能够把<font color=red><strong>看到的知识运用到实际场景中</strong></font>，这样也算对得起自己用来看书花费的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之Pandas库躺坑记</title>
      <link href="python-Python%E4%B9%8BPandas%E5%BA%93%E8%BA%BA%E5%9D%91%E8%AE%B0/"/>
      <url>python-Python%E4%B9%8BPandas%E5%BA%93%E8%BA%BA%E5%9D%91%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​        最近在开发一个线上用例管理平台，需要使用 <code>Python语言</code> 对 <code>Excel文件</code> 进行一系列的操作，网上大致搜索了下常用的库，最后决定使用 <code>Pandas</code> 库（原因就不具体阐述了）。在使用的过程中，大部分的需求都能满足，但是还是有部分需求通过不断躺坑最终解决了。</p><p>Pandas 库常用的方法就不一一阐述了，可以参考如下链接。</p><ul><li><p><a href="http://www.fixbbs.com/p/0844377.html">Python Pandas读取修改excel操作攻略</a> </p></li><li><p><a href="https://blog.csdn.net/zhangchuang601/article/details/79583551">Pandas DataFrame数据的增、删、改、查</a></p></li></ul><p>在此将整个过程中遇到的一些特定的问题进行记录┑(￣。。￣)┍ ┑(￣。。￣)┍ 。</p><a id="more"></a><h3 id="特殊问题"><a href="#特殊问题" class="headerlink" title="特殊问题"></a>特殊问题</h3><h4 id="问题1-部分Excel文件单元格进行了合并或者单元格内容为空"><a href="#问题1-部分Excel文件单元格进行了合并或者单元格内容为空" class="headerlink" title="问题1. 部分Excel文件单元格进行了合并或者单元格内容为空"></a>问题1. 部分Excel文件单元格进行了合并或者单元格内容为空</h4><p>需要对合并了的单元格或者单元格内容为空的进行内容，通过Debug发现此时值为 <code>Nan</code>。</p><p><strong>解决办法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将单元格的值赋值给data</span></span><br><span class="line">data = df.iloc[iRow, iCol]</span><br><span class="line"><span class="comment"># 通过如下方法判断 data 是否为 Nan， 是则返回 True。</span></span><br><span class="line"><span class="built_in">isinstance</span>(data, <span class="built_in">float</span>) <span class="keyword">and</span> math.isnan(df.iloc[iRow, iCol])</span><br></pre></td></tr></table></figure><h4 id="问题2-使用Panads的to-excel方法会覆盖其他所有的sheet"><a href="#问题2-使用Panads的to-excel方法会覆盖其他所有的sheet" class="headerlink" title="问题2. 使用Panads的to_excel方法会覆盖其他所有的sheet"></a>问题2. 使用Panads的to_excel方法会覆盖其他所有的sheet</h4><p>具体问题：在使用pandas的 <code>df.to_excel(file_path)</code> 想要对一个有多张sheet的workbook操作时一定会尴尬的发现：永远只存在最后一次写进去的表，其他的sheet表都被清空了，并且最后一次写进去的表的样式也未保存。</p><p><strong>解决办法：</strong> <a href="https://zhuanlan.zhihu.com/p/85918022">参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># file_abs_path excel文件的绝对路径</span></span><br><span class="line">excel_sheet_handle = pd.read_excel(file_abs_path, sheet_name=<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="comment"># ... 中间对 sheet1 进行一系列值的改动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过下方的代码将其他 sheet 的内容与最新的 sheet1 表进行合并。</span></span><br><span class="line">book = openpyxl.load_workbook(file_abs_path)</span><br><span class="line">writer = pd.ExcelWriter(file_abs_path, engine=<span class="string">&#x27;openpyxl&#x27;</span>)</span><br><span class="line">writer.book = book</span><br><span class="line"></span><br><span class="line">writer.sheets = <span class="built_in">dict</span>((ws.title, ws) <span class="keyword">for</span> ws <span class="keyword">in</span> book.worksheets)</span><br><span class="line"><span class="comment"># index 为序号, header 为原来的表头</span></span><br><span class="line">excel_sheet_handle.to_excel(writer, sheet_name=<span class="string">&quot;sheet1&quot;</span>, index=<span class="literal">False</span>, header=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>通过如上的办法就可以将所有表都保存下来，并且保存了原有的样式， sheet1表的内容也修改正确。</p><h4 id="问题3-使用了问题2的办法后，使用Panads-drop-方法在最后出现重复行。"><a href="#问题3-使用了问题2的办法后，使用Panads-drop-方法在最后出现重复行。" class="headerlink" title="问题3. 使用了问题2的办法后，使用Panads.drop()方法在最后出现重复行。"></a>问题3. 使用了问题2的办法后，使用Panads.drop()方法在最后出现重复行。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file_abs_path excel文件的绝对路径</span></span><br><span class="line">excel_sheet_handle = pd.read_excel(file_abs_path, sheet_name=<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="comment"># 将文件的第2、3行删除掉</span></span><br><span class="line">excel_sheet_handle.drop([<span class="number">1</span>, <span class="number">2</span>], inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>具体问题现象</strong>如下：存在文件A，里面的sheet1表中有4行数据（如下），通过上述代码的drop删除后， 再调用问题2中的办法进行保存，发现sheet1表中仍然有4行， 内容为原来的第1、4、3、4 行内容，实际预期应该只是第1、4行的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># excel_sheet_handle.drop([1, 2], inplace=True)</span></span><br><span class="line"><span class="comment"># 原数据</span></span><br><span class="line">   A   B   C   D</span><br><span class="line">0  0   1   2   3</span><br><span class="line">1  4   5   6   7</span><br><span class="line">2  8   9  10  11</span><br><span class="line">3  3   2   6   7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预期应该为：</span></span><br><span class="line">   A   B   C   D</span><br><span class="line">0  0   1   2   3</span><br><span class="line">3  3   2   6   7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际结果为：</span></span><br><span class="line">   A   B   C   D</span><br><span class="line">0  0   1   2   3</span><br><span class="line">3  3   2   6   7</span><br><span class="line">2  8   9  10  11</span><br><span class="line">3  3   2   6   7</span><br></pre></td></tr></table></figure><p><strong>具体原因：</strong> 由于问题2中进行了原来的sheet内容读取，所以在writer中也记录了原来的 sheet1 的内容，导致 writer 在写入的时候又重新将原来的第3、4行与实际的 第1、4行进行了合并。</p><p><strong>最终解决办法</strong>（根据上述的实例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">max_row = <span class="number">4</span></span><br><span class="line"><span class="comment"># 共删除了2、3两行，所以删除的行数为2</span></span><br><span class="line">delete_row_count = <span class="number">2</span></span><br><span class="line">change_sheet = writer.sheets[<span class="string">&quot;sheet1&quot;</span>]</span><br><span class="line"><span class="comment"># 删除原来重复合并的第 3、4行。</span></span><br><span class="line">change_sheet.delete_rows(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">writer.save()</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h4 id="问题4-在指定行插入一行数据"><a href="#问题4-在指定行插入一行数据" class="headerlink" title="问题4. 在指定行插入一行数据"></a>问题4. 在指定行插入一行数据</h4><p><strong>具体需求</strong>：可能需要通过在不同的行插入指定的数据，比如，sheet表中共10行，需要在第5行插入一条数据。</p><p><strong>解决办法</strong>：<a href="https://blog.csdn.net/weixin_30797027/article/details/97422624">参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以先将表格分开，添加行后再合并，原数据如下， 在第1行（猫之前）插入 羊，数量9， </span></span><br><span class="line"><span class="comment">#   动物  数量</span></span><br><span class="line"><span class="comment"># 0  狗   3</span></span><br><span class="line"><span class="comment"># 1  猫   4</span></span><br><span class="line"><span class="comment"># 2  兔   6</span></span><br><span class="line"></span><br><span class="line">具体实现代码如下</span><br><span class="line">df1 = df.loc[:<span class="number">0</span>]</span><br><span class="line">df2 = df.loc[<span class="number">1</span>:]</span><br><span class="line">print(<span class="string">&#x27;df1 is:\n&#x27;</span>, df1)</span><br><span class="line">print(<span class="string">&#x27;df2 is:\n&#x27;</span>, df2)</span><br><span class="line">df3 = pd.DataFrame(&#123;<span class="string">&#x27;动物&#x27;</span> : [<span class="string">&#x27;羊&#x27;</span>], <span class="string">&#x27;数量&#x27;</span> : [ <span class="number">9</span> ]&#125;)</span><br><span class="line">df = df1.append(df3, ignore_index = <span class="literal">True</span>).append(df2, ignore_index = <span class="literal">True</span>)</span><br><span class="line">print(df)</span><br><span class="line"><span class="comment"># df1 is:</span></span><br><span class="line"><span class="comment">#    动物  数量</span></span><br><span class="line"><span class="comment"># 0  狗   3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># df2 is:</span></span><br><span class="line"><span class="comment">#    动物  数量</span></span><br><span class="line"><span class="comment"># 1  猫   4</span></span><br><span class="line"><span class="comment"># 2  兔   6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   动物  数量</span></span><br><span class="line"><span class="comment"># 0  狗   3</span></span><br><span class="line"><span class="comment"># 1  羊   9</span></span><br><span class="line"><span class="comment"># 2  猫   4</span></span><br><span class="line"><span class="comment"># 3  兔   6</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        只有真的多面对几次现实中的需求，才能真的掌握一个库的使用。。。否则仅仅是最基础的 <code>Demo</code> 演练。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
            <tag> excel文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构化思维</title>
      <link href="%E8%AF%BB%E5%90%8E%E6%84%9F-%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4/"/>
      <url>%E8%AF%BB%E5%90%8E%E6%84%9F-%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="结构化思维"><a href="#结构化思维" class="headerlink" title="结构化思维"></a>结构化思维</h3><p>​    什么是结构化思维呢？在本书第一章 第三节简单介绍了结构化思维， 书上所举的鲁班的例子，但个人感觉上鲁班的思维与结构化思维也不太相似，因此对于结构化思维更加迷惑。。。（可能比较愚钝╮(╯Д╰)╭ 😭）</p><p>​    我在这里个人重新理解下：<font color=red><strong>结构化思维 =&gt; 结构化的做事方式</strong></font>，具体见如下两个实例。</p><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>​    通过网上查找的一些资料，如下两个实例体现出了结构化思维：</p><h4 id="场景一：记忆词组"><a href="#场景一：记忆词组" class="headerlink" title="场景一：记忆词组"></a>场景一：记忆词组</h4><p>有下图的一串词组让你来记忆，</p><img src="https://i.loli.net/2021/03/03/FH2QGJbpRXNKcmx.png" alt="结构化思维-1.png" style="zoom: 33%;" /><p><strong>方式一：</strong></p><p><strong>上来就马上开始从前到后的记忆，那么这个记忆的效果可能不太理想，要是数量越多，那效果一般越差</strong>。（<em>此处排除过目不忘的大佬。。。</em>）这种做事方式一般比较低效。<font color=red>就如像我一样刚入职场时┑(￣。。￣)┍ ，在领导布置任务后一般都不思考就马上一股脑动手了，很可能最后结果就是效率低下并且结果与领导希望得到的结果背道而驰。</font></p><img src="https://i.loli.net/2021/03/03/rBAd5syXfHE3zWM.png" alt="结构化思维-2.png" style="zoom:40%;" /><p><strong>方式二：</strong></p><p>一般经过学校或者工作的锻炼，部分人就会掌握一些比较巧妙的做事方式，比如：在看到上面词组后，大家会先将所有词组进行一个分类归纳，然后再来记忆，虽然从数量上反而还新增了3个节点（蔬菜、水果、动物），但实际在记忆的效率上肯定比方式一要高效。</p><h4 id="场景二：新人入职任务"><a href="#场景二：新人入职任务" class="headerlink" title="场景二：新人入职任务"></a>场景二：新人入职任务</h4><p>很多人应该都经历过新人入职培训，培训上面可能会布置一些新人入职第一天的任务，那你还记得培训上有哪些任务吗？比如讲师就将如下图的内容展示给你们，你们估计也就是填鸭式将一天课程从头到尾听一遍，事情过了就完了。</p><img src="https://i.loli.net/2021/03/03/1Bd9gmSQIwzUhLb.png" alt="结构化思维-4.png" style="zoom:33%;" /><p>上图就是普通的做事方式，从头到尾来一遍。</p><p>这个时候依然参考结构化思维，更好的办法是先让大家了解这些任务之间的关系，然后再从更小的一个维度去让大家了解具体任务是什么，如下图：</p><img src="https://i.loli.net/2021/03/03/voQyqiHkV8aB4s6.png" alt="结构化思维-3.png" style="zoom:33%;" /><p>通过上述结构化后的任务，更加容易理解需要做的任务以及之间的关联性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    通过上述的两个实例后，我大概对结构化思维有了如下的一些见解：</p><p>​    ⚠️ 个人理解：每个实例中的后者就是<strong>结构化</strong>的做事方式，前者则为普通的思维（做事）方式，当然除了结构化的做事方式我理解还有更多其他成熟的做事方式，每种方式可能解决的场景又不太一样。</p><p>结构化思维可以解决如下类型的问题：</p><ul><li>遇到大问题脑子一团乱，不知如何下手；</li><li>说了一堆话，别人却表示听不懂；</li><li>想写文章，却毫无思路，无从下笔。</li></ul><p>结构化的做事方式具体步骤如下：</p><ol><li>先所有的信息/任务收集在一起；</li><li><strong>将所有信息/任务在已知的认知中，进行一个加工、归纳分组，形成多个更小的有条理和逻辑的分组，每个分组与上下之间都是有紧密联系的；</strong></li><li>如果下层分组过大，则可以将下层分组再次重复步骤2分成更小的分组。（<strong>存在一些极端场景：那就是所有的信息/任务没有任何关联</strong>）；</li><li>处理/记忆 每个分组。</li></ol><p>所以，结构化思维的核心就是： “<strong>拆分任务为多个有逻辑联系的小任务</strong>“。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思维的影响</title>
      <link href="%E8%AF%BB%E5%90%8E%E6%84%9F-%E6%80%9D%E7%BB%B4%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>%E8%AF%BB%E5%90%8E%E6%84%9F-%E6%80%9D%E7%BB%B4%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    很多时候，<strong>你可能不知道思维对你的生活到底造成了多大的影响</strong>。（就如同以前的我。。。此处可将<font color=red><strong>思维替换为看法</strong></font>）刚好最近看了一部电影一一<strong>华仔的《拆弹专家2》</strong>，里面很明显的展示出了不同的思维对主角（刘德华）带来了多大的影响。</p><p>​    <font color=gray>备注：可能很多地方也推荐《金字塔原理》，但我个人觉得如果是入门可以先看《结构化思维》，里面有更多的实例，让人理解起来更加浅显易懂。</font></p><a id="more"></a><h3 id="思维的意义"><a href="#思维的意义" class="headerlink" title="思维的意义"></a>思维的意义</h3><p>​    <font color=blue><strong>思维的意义，它是我们解读事实的起点，是产生行为的源头，是决定结果的根本。</strong></font></p><p>​    本书中刚开始就用了很多比较形象的案例阐述了思维在这些案例中的影响（意义），我个人理解思维在情绪上大致可以总结为：<code>积极的思维</code> 和 <code>消极的思维</code> 两种（有兴趣可以自行查阅书中的案例）。</p><p>​    <font color=blue>在不同的思维下，对于做事情的态度和行为也会天差地别。</font></p><p><strong>从以下几个大部分人可能都经历过的实际场景来看</strong>（平时工作中的年终考核或者季度考核）<font color=gray><em>我不以偏概全，但如果把我自己代入到这个场景后我可能会有如下看法。</em></font></p><ul><li><p><strong>你得知你自己的绩效较差或者你觉得自己能拿A，但是实际只给了你B。</strong></p><p>以前的我第一看法可能就是：<strong>搞什么鬼？， 这领导是给我穿小鞋吧，然后开始对于后面的工作有所松懈，更极端点就是离职</strong>。</p></li><li><p><strong>在上面的场景下，你得知自己只得到了B，小明得到了A（并且你觉的小明不如自己）。</strong></p><p>以前的我第一看法可能是：<strong>他做的和我一样呀，感觉都还不如我做的好，不会是靠拍马屁上去的吧？</strong></p></li></ul><p>先不管上面的猜测或者臆断的看法是否是正确的，但是可以发现产生我上述的看法的根本原因之一就是一一<code>消极思维</code>。以至于对后面的工作也可能越做越差，那后续的绩效也可想而知。</p><p>⚠️ 注意：<strong>道理可能大家都懂，但是真的碰到后不按照道理说的来做那还不如不懂这个道理！！！</strong></p><p>看了这章节后，我明白了思维的重要性，现在的我至少在再次面对上面的场景时候，我能从更深层次去思考问题，关于上述的实例场景，具体可以分为如下几个步骤：</p><ol><li><strong>先保持冷静以及抛开所有上述自己开始的猜想或者臆断</strong>（如果有这些主观因素影响的话，后面的步骤可能效果不佳）；</li><li><strong>仔细思考下这一年或者这一个季度自己做的东西是否真的如自己想象中那么好？</strong><ul><li>如果是自己真的做的不好，那么后面<strong>需要进行反省以及制定对应的改进计划</strong>，并且将自己的改进计划与领导进行核对确认，避免大方向错误。（这牵涉到<strong>向上管理</strong>，有兴趣的可以搜索这方面书籍）；</li><li>如果真的是自己做的好，那么总结出自己做的好的内容，与领导进行核对，确认是否两端有误会，<strong>而不是直接放手不干</strong>。</li></ul></li><li><strong>仔细思考下小明是不是真的不如自己？</strong><ul><li>如果小明真的是不如自己，那么总结出自己做的比小明好的地方，与领导进行核对，确认是否两端有误会，<strong>而不是背地里猜忌</strong>。</li><li>如果小明真的做的比自己好，那么就需要<strong>提取出小明的优势，然后制定自己的改进计划，并且将自己的改进计划与领导进行核对确认，避免误解了小明做的好的地方。</strong></li></ul></li></ol><p><font color=gray><em>但如果上述步骤做了后，发现确实不是自己的问题的时候，如何抉择很重要，但绝不能因为这件事而影响以后的工作或者生活。</em></font></p><h3 id="本节总结"><a href="#本节总结" class="headerlink" title="本节总结"></a>本节总结</h3><p>​    最后还是再强调一句：<code>如果过往事实不能改变，我们就只能改变思维，改变面对事实的态度和行为，让未来过得更好，避免发生悲剧。改变思维才是改变一切的源头。</code></p><p>​    发生任何事情， <code>积极思维</code> 一般都比 <code>消极思维</code> 要好，当然有时候一些悲伤的事情，适当的 <code>消极思维</code> 也是可以的，但一定要注意及时调整自己的思维，否则浪费的就是自己的时间。（可能大家有更好的见解💡，欢迎一起讨论实践）。 </p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周报的意义</title>
      <link href="%E6%9D%82%E9%A1%B9-%E5%91%A8%E6%8A%A5%E7%9A%84%E6%84%8F%E4%B9%89/"/>
      <url>%E6%9D%82%E9%A1%B9-%E5%91%A8%E6%8A%A5%E7%9A%84%E6%84%8F%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    在从刚开始工作至工作5年后，都对周报的作用没有太大的了解，并且<strong>觉得是一件浪费时间又不讨好的事情</strong>。至今我才恍然大悟，庆幸为时不晚。</p><p>​    写周报，在公司里每周都会发生，大部分情况下，周围的人都对周报没有表现出太大的兴趣，有人则对它异常反感，甚至称它是<strong>“职场鸡肋”</strong>；还有人有这样的疑问：<strong>每周雷同的“僵尸”周报浪费时间和精力，真的有存在的必要吗？</strong>而且，我们辛辛苦苦写的周报老板到底看了没有？</p><p>或多或少，大家应该都可能有过如下类似的想法：</p><blockquote><p>  【小明】忙了一周了但是周报上不知道该写啥？老板看没看呢？</p><p>  【小明】我做了什么领导不知道吗?记录一周的工作内容有什么价值？随便写写算了~</p><p>  【小明】每周忙的都是一样的，这个能写出个什么花来？</p></blockquote><a id="more"></a><h3 id="周报是否-“鸡肋”？"><a href="#周报是否-“鸡肋”？" class="headerlink" title="周报是否 “鸡肋”？"></a>周报是否 “鸡肋”？</h3><p>答案肯定是否！</p><p>周报是<strong>职场通用基本功之一，员工通过每周周报的反复练习，不断提升自己复盘、思考和规划的基础能力。</strong></p><p>通过对过去一周工作的总结和沉淀，对未来一周的工作做计划和安排，回顾收获与不足，促成协同与互补。</p><p><strong>周报不仅是为了写给老板看的，更是写给自己看的，为自己创造一个“照镜子”的机会，沉淀经验，发现不足，快速改进。</strong></p><h3 id="周报撰写的方法"><a href="#周报撰写的方法" class="headerlink" title="周报撰写的方法"></a>周报撰写的方法</h3><table><thead><tr><th align="left">周报的三个部分</th><th align="left">撰写要点</th></tr></thead><tbody><tr><td align="left"><strong>第一部分，本周工作进展</strong></td><td align="left">也就是本周自己做了哪些事，分别取得了什么样的成果，围绕4个方面：</td></tr><tr><td align="left"></td><td align="left">①检查关键项目/任务的完成进度是否符合预期；</td></tr><tr><td align="left"></td><td align="left">②反馈各项目/任务的执行结果，如：完成情况/未达预期的原因/改进方案；</td></tr><tr><td align="left"></td><td align="left">③统计日程表中各任务的耗时情况是否正常，有没有效率特低或特高的情况，原因写到备注中；</td></tr><tr><td align="left"></td><td align="left">④回溯上一周面临的问题是否得到解决，解决方案是否有效，并简单总结经验教训。</td></tr><tr><td align="left"><strong>第二部分，下周任务安排</strong></td><td align="left">即对下周工作开展的简单思路，明确下周的工作重点，同时也能更加合理地管理时间，提升工作效率。可参考以下步骤进行规划：</td></tr><tr><td align="left"></td><td align="left">①列出下周的关键项目/任务；</td></tr><tr><td align="left"></td><td align="left">②明确各项项目/任务的产出指标；</td></tr><tr><td align="left"></td><td align="left">③细化任务，一方面要计划任务量，另一方面要计划时间分配，明确完成的时间节点。</td></tr><tr><td align="left"><strong>第三部分，本周工作感想</strong></td><td align="left">包括对工作的思考/疑问/不满/建议等等 。</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    总之，好的周报不仅让领导眼前一亮，并且能够让自己持续成长，不至于每当机遇来了却感叹没有掉到自己的手里。周期性的复盘自我才能一直持续高速成长。</p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周报 </tag>
            
            <tag> 个人成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PYPI打包躺坑日记</title>
      <link href="python-PYPI%E6%89%93%E5%8C%85%E8%BA%BA%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
      <url>python-PYPI%E6%89%93%E5%8C%85%E8%BA%BA%E5%9D%91%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    作为一个测试，在使用 <code>PYTHON</code> 开发项目或者平台的时候会发现自己写的通用型功能可能每次都要拷贝到不同的项目中，如：我自己对数据库操作进行二次封装的 <code>sql_utils</code> ，可能由于一些扩展性需要或者修复一些缺陷就需要在每个项目里进行修改，操作起来相当繁琐并且可能出现失误。</p><p>​    大家肯定都用过 <code>pip</code> 来安装过依赖包，那么我们是否可以把自己写的公共模块通过 <code>PYPI</code> 来管理，这样通过 pip 就能安装了，是不是满满的成就感(╯▔▽▔)╯(╯▔▽▔)╯  ！！！心动不如行动！！</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>​    关于如何将自己的项目打包上传到 <code>PYPI</code> 进行统一管理的基本教程很多，这里就不重复搬运了，可以参考当时我找到的一篇<a href="https://blog.csdn.net/Coxhuang/article/details/88952367">教程</a>。主要记录下在这个过程中遇到的一些问题。</p><h3 id="基本命令行"><a href="#基本命令行" class="headerlink" title="基本命令行"></a>基本命令行</h3><p>在所有流程都执行完后，每次上传版本的命令行基本如下：</p><ol><li><p> 修改 <code>setup.py</code> 文件中的 <code>version</code> 字段版本值 ；</p></li><li><p> 执行 <code>python setup.py sdist build </code>，本地打包构建最新版本的 dist 包；</p></li><li><p> 执行 <code>twine upload --skip-existing dist/* </code> 上传新的版本包；</p></li><li><p> 使用方升级 <code>pip install --upgrade $&#123;package_name&#125; </code>。</p></li></ol><h3 id="过程中遇到的问题"><a href="#过程中遇到的问题" class="headerlink" title="过程中遇到的问题"></a>过程中遇到的问题</h3><h4 id="问题1：在执行上述命令行的第3步时候，上传一直报错-403"><a href="#问题1：在执行上述命令行的第3步时候，上传一直报错-403" class="headerlink" title="问题1：在执行上述命令行的第3步时候，上传一直报错 403"></a>问题1：在执行上述命令行的第3步时候，上传一直报错 403</h4><p>具体报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPError: 403 Client Error: Invalid or non-existent authentication information. <span class="keyword">for</span> url: https://upload.pypi.org/legacy/ </span><br></pre></td></tr></table></figure><p>查了下相关的问题， 如: <a href="https://github.com/pypa/twine/issues/424">官网ISSUES</a>，但看起来和我的不太一致，最终通过对比发现由于根目录下 <code>LICENSE</code> 文件中有一个用户名信息。</p><p><strong>解决方案：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admindeMacBook-Pro-2:date_utils xxx$ cat LICENSE</span><br><span class="line">Copyright (c) 2018 <span class="variable">$&#123;YOUR_USERNAME&#125;</span>  <span class="comment"># 这个地方应该填写自己的PYPI username</span></span><br></pre></td></tr></table></figure><h4 id="问题2：参考官网链接里面的操作，执行到如下命令时候报错"><a href="#问题2：参考官网链接里面的操作，执行到如下命令时候报错" class="headerlink" title="问题2：参考官网链接里面的操作，执行到如下命令时候报错"></a>问题2：参考官网链接里面的操作，执行到如下命令时候报错</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; python3 -m pip install --user --upgrade setuptools wheel </span><br><span class="line">error: invalid <span class="built_in">command</span> ‘bdist_wheel<span class="string">&#x27; </span></span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong><a href="https://stackoverflow.com/questions/34819221/why-is-python-setup-py-saying-invalid-command-bdist-wheel-on-travis-ci">参考链接</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install wheel </span><br></pre></td></tr></table></figure><h4 id="问题3：-更新代码并修改了version后执行步骤3，仍然报错"><a href="#问题3：-更新代码并修改了version后执行步骤3，仍然报错" class="headerlink" title="问题3： 更新代码并修改了version后执行步骤3，仍然报错"></a>问题3： 更新代码并修改了version后执行步骤3，仍然报错</h4><p>具体报错信息为：<code>400 Client Error: File already exists </code></p><p><strong>解决方案：</strong> <a href="https://stackoverflow.com/questions/52016336/how-to-upload-new-versions-of-project-to-pypi-with-twine">参考链接</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twine upload --skip-existing dist/* </span><br></pre></td></tr></table></figure><h4 id="问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。"><a href="#问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。" class="headerlink" title="问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。"></a>问题4：本地安装自己的公共库时候，提示其它依赖模块不存在。</h4><p><strong>原因：</strong>如果存在了依赖非系统自带的库的时候，比如 <code>requests</code> ，默认情况下打包上传后，下载的库在运行时候会报 <code>request</code> 不存在，没有自动安装相应的依赖。</p><p><strong>解决办法：</strong></p><p>​    在 <code>setup.py</code> 文件中添加配置，具体代码如下：<a href="https://note.qidong.name/2018/01/python-setup-requires/">参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setup(</span><br><span class="line">...</span><br><span class="line">    install_requires=[</span><br><span class="line">        <span class="string">&quot;requests&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="问题5：在Mac上打包的公共库，-但在windows上安装一直报错。"><a href="#问题5：在Mac上打包的公共库，-但在windows上安装一直报错。" class="headerlink" title="问题5：在Mac上打包的公共库， 但在windows上安装一直报错。"></a>问题5：在Mac上打包的公共库， 但在windows上安装一直报错。</h4><p>具体报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: <span class="string">&#x27;gbk&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xbf in postion 2: illegal multibyte sequence</span></span><br></pre></td></tr></table></figure><p>原因是：是因为在 <code>setup.py</code> 文件时候，执行了 <code>open(README.rst)</code> 此处编码有问题。</p><p>解决办法：在 <code>setup.py</code> 文件中的代码进行如下修改。（但不一定是这个文件。具体要看是否有哪个代码使用了open()方法打开了中文字体的文件）<a href="https://blog.csdn.net/lqzdreamer/article/details/76549256">参考链接</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(README.rst) ==&gt; open(README.rst, encoding=&#x27;gb18030&#x27;, errors=&#x27;ignore&#x27;)</span><br></pre></td></tr></table></figure><h4 id="问题6-上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。"><a href="#问题6-上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。" class="headerlink" title="问题6: 上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。"></a>问题6: 上传了新的包后，在PYPI上能看到最新的包，但是通过本地pip安装一直没有找到对应的包。</h4><p>原因：因为本地配置了pip的安装源为<a href="http://mirrors.aliyun.com/pypi/simple/">阿里云的链接</a>，<strong>阿里云的pip源不是实时去同步PYPI上的包</strong>。</p><p>解决办法： 把本地配置的 <code>pip.conf</code>  里面的用户自定义配置的内容注释掉即可。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://packaging.python.org/tutorials/packaging-projects/#uploading-your-project-to-pypi">Packaging Python Projects</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PYPI </tag>
            
            <tag> Python公共库管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识思维</title>
      <link href="%E8%AF%BB%E5%90%8E%E6%84%9F-%E5%88%9D%E8%AF%86%E6%80%9D%E7%BB%B4/"/>
      <url>%E8%AF%BB%E5%90%8E%E6%84%9F-%E5%88%9D%E8%AF%86%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是思维"><a href="#什么是思维" class="headerlink" title="什么是思维"></a>什么是思维</h3><p>书本上的解释：</p><blockquote><p> 思维是大脑对接收到的信息进行加工处理，再反映在现实生活中的一种过程。</p></blockquote><p><strong>信息：</strong>泛指人类社会传播的一切内容。 </p><p><strong>加工处理：</strong>如：记忆、理解、筛选、推理、思考、想象等。 </p><p><strong>反映在现实生活中：</strong>指的是产生的动作、想法或者行动，这种动作可能是大脑内部的运转，也可能是通过说、写、画、行动等方式表达出来的肢体动作。 </p><p>书上的概念大多数时候都比较抽象 ㄟ(▔︹▔ㄟ) ，此处我为了方便记忆会用当前我已知的知识替换一部分名词，如：<font color=red><strong>思维 =&gt; 看法</strong> </font>。（思维会产生一个或多个看法，<a href="https://wiki.mbalib.com/wiki/%E6%80%9D%E7%BB%B4">MBA百科</a>上解释 思维 =&gt; 思考）</p><a id="more"></a><p>⚠️ <strong>个人理解</strong>： 思维（<strong>看法</strong>）不会凭空产生，当你知道某个信息A后，通过自己已有的认知对A形成关于该信息的看法（可能是多个）。</p><p>比如：</p><ul><li>你去了重来没去过的饭店A去吃饭，挺好吃的，这个时候就形成了饭店A菜还不错的思维（看法a）。</li><li>你第二次再次去了饭店A吃饭（由于上述的看法a），但是此次吃同样的菜很难吃，这个时候你又形成了饭店A菜怎么这么难吃的思维（看法b）</li><li>再准备出去吃饭的时候，你可能不会再考虑饭店A（由于看法b导致）。</li></ul><p>所以通俗易懂的来说就是：**”思维” 就是  “一个或者多个关于某个信息的看法”**（个人觉得这样理解挺方便😂）。</p><h3 id="思维形成的过程"><a href="#思维形成的过程" class="headerlink" title="思维形成的过程"></a>思维形成的过程</h3><p>​    从上面的实例来看，<font color=blue><strong>思维（看法）会在不断接受到信息后不断的改变。</strong></font>再来看一个具体的实例：</p><p>​    当我们去一个新公司上班。一进门，人事专员就面带微笑地迎接，给我们办理入职相关手续，这时候我们有可能会想：<strong>哇，新公司真不错，同事这么和蔼可亲、服务周到，看起来氛围也很好。</strong></p><p>​    在这一系列的思考后，我们是不是会放下内心的担忧或者矜持，对人事专员笑容以对呢？</p><p>​    接着人事专员让我们稍等，她去复印身份证，<strong>结果一等就等了20分钟。这时候，我们是不是又会情绪不安</strong>，心想：<strong>怎么回事，复印个身份证都能这么久，这个人做事靠谱吗？是不是半路被拉去做其他事，把我忘了？还是我入职的事情，有了什么变化？</strong></p><p>​    在这一系列的思考后，<strong>我们可能会来回走动、坐立不安，甚至开始四处找人呢？</strong></p><p><font color=red>此时再次设想存在如下两个场景：</font></p><p><strong>场景一：</strong>当我们找到人事专员，发现她在跟其他人聊天，这个时候我们看到她脸上的笑容，就不再认为她和蔼可亲了。</p><p>此时你是不是会觉得：<strong>这个人怎么回事啊？把我晾在一边，我这边的手续还没办完，又在跟别人说说笑笑，真不靠谱！</strong></p><p><strong>场景二：</strong>我们发现她在帮我们复印文件时弄了一手油墨，并且不断和我们道歉说复印机突然坏了，维修师傅明天才能到，为了不影响我们入职，她只能自己动手尝试修理，一不小心忘了时间……发现是这样的情况，我们会怎样思考呢？</p><p>此时你是不是会觉得：<strong>“原来是这样啊，我误会她了，人事专员还能修复印机真是厉害，公司员工的素质好高啊，真是个不错的公司！”</strong></p><p>所以，思维不仅是单向运动，而且还是<strong>动态循环</strong>的过程。我们会<font color=blue><strong>因为事情呈现的变化和结果，反过来影响思维，又持续不断地影响接下来的态度、行为，以及事情的结果。</strong></font></p><img src="https://i.loli.net/2021/02/20/qfkyZVjYCM8FRcx.png" alt="逻辑思维-1.png" style="zoom:35%;" /><p>在工作中也是这样。</p><p><strong>如果你存在上司对你有意见的看法， 那你的工作肯定做不好。</strong>因为任何不好的事情发生后，你可能都会先怪罪到你上司身上，并且消极怠工、破罐子破摔、拒不改错或者与上司起冲突。最终结果可能就是离职。最后我们还会认为：<font color=red><strong>果然，上司就是不待见自己！</strong></font></p><p><strong>如果你存在上司有意栽培你的看法时，那你的工作可能会越做越好。</strong> 上司指出我们方案中的错误，我们就会认为上司精益求精、借此指点我们，继而我们更虚心好学、热情请教、刨根问底、精益求精，结果肯定是自己逐渐进步和优秀。最后，我们会认为：<font color=blue><strong>上司果然是想培养自己！</strong></font></p><h4 id="思维方式"><a href="#思维方式" class="headerlink" title="思维方式"></a>思维方式</h4><blockquote><p>就这样在上图描述那样，一次又一次的思维循环里，思维过程重复多次，就会形成固定的思维方式，从而形成思维惯性，遇见相同或类似的信息时，按照同样的思维方式思考，就能得出同样的认知。 </p></blockquote><p>⚠️ <strong>个人理解</strong>：在上述过程中讲到了思维方式，我个人理解可以认为： <font color=red><strong>思维方式 =&gt; 做事方式</strong></font>。（后面如有遗漏可自行替换为做事方式）</p><p>比如：从小我们经过很多事情（在不特意训练的情况下），形成了一套属于自己的做事方式（大部分这个做事方法是不成熟的，就比如我刚工作的做事方式(╯▔︹▔)╯ ）。</p><ul><li>刚开始工作时，每当遇到问题时，夸张一点的做事方式：<strong>上来就直接问别人，如果解决了就完事了，没解决那就算了！！</strong>，在这种做事方式下，直接影响了个人的成长。所以急需改正。</li><li>在工作3～5年后，通过工作经验的积累，每当遇到问题，我的思维（<strong>做事</strong>）方式是：<strong>先解决这个问题，并且记录问题以及具体原因，通过5Why分析法追根溯源</strong>，这种思维<strong>（做事）</strong>方式让我在后续遇到类似的问题也能从容应对，让我的个人能力也突飞猛进。</li></ul><p>所以，如果我一直维持刚开始工作时候的固定的思维（<strong>做事</strong>）方式，那结果可想而知。</p><h4 id="固定思维方式的优点"><a href="#固定思维方式的优点" class="headerlink" title="固定思维方式的优点"></a>固定思维方式的优点</h4><p>​    当我们形成一种固定的思维（<strong>做事</strong>）方式后，常常会以这种方式去处理大部分的信息，优势在于有效率。也就是说，我们能把这种思维（<strong>做事</strong>）方式本身带来的红利发挥最大化。</p><ul><li>做过销售的人，往往更在乎结果。因为他们在做销售的过程中，业绩、收入取决于销售结果，所以有销售经验的人做其他工作往往更加看重结果是否达成。</li><li>做过编辑的人，看到文章，即使无须他们审核，也会快速找出其中格式错误、错别字、标点符号错误等问题。</li><li>做过行政工作的人，做事往往也会更加在乎细节。</li></ul><p>这些工作方式的差异，都是思维上重复多次后，形成固定思维（<strong>做事</strong>）方式的结果。</p><h4 id="固定思维方式的缺点"><a href="#固定思维方式的缺点" class="headerlink" title="固定思维方式的缺点"></a>固定思维方式的缺点</h4><p>​    容易忽略其他特质，比如：</p><ul><li>在乎结果的人容易忽视过程，甚至可能为短期结果而牺牲长远利益；</li><li>快速找到文章错误的人，往往不容易克服这些错误而去欣赏文章本身的意境；</li><li>在乎细节的人就不容易跳出局部看整体等。</li></ul><p>一个比较常见的实例，某些销售员由于工作原因，接触的人多了，就对人产生一些惯性思维，比如穿的破破烂烂的就没兴趣接待。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    如果掌握足够优秀或者成熟的思维（<strong>做事</strong>）方式，我们必然就会成为睿智、思考全面、轻松做正确选择的人。如果思维（<strong>做事</strong>）方式杂乱无章，没有形成结构，我们看待事情必然就会片面、局限、逻辑混乱，从而在失败里循环。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue + Element el-upload实现上传文件</title>
      <link href="vue-Vue-upload%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
      <url>vue-Vue-upload%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近在开发测试用例管理平台，其中需要实现上传用例的 <strong>Excel</strong> 文件。</p><h3 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h3><p>​    通过  <code>Element-ui</code> 很轻松就找到了对应的组件（<a href="https://element.eleme.cn/#/zh-CN/component/upload#tuo-zhuai-shang-chuan">Element-ui具体代码</a>），通过查找资料以及填坑，最终实现的效果如下：</p><img src="https://i.loli.net/2021/02/26/CZyFN5EdbTUOXgq.png" alt="finally-ui-import.png" style="zoom:40%;" /><a id="more"></a><p>具体核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-upload</span><br><span class="line">           class&#x3D;&quot;upload-demo&quot;</span><br><span class="line">           drag</span><br><span class="line">           :action&#x3D;&quot;doUpload&quot;</span><br><span class="line">           :data&#x3D;&quot;specialData&quot;</span><br><span class="line">           :on-change&#x3D;&quot;handleChange&quot;</span><br><span class="line">           :file-list&#x3D;&quot;fileList&quot;</span><br><span class="line">           :on-error&#x3D;&quot;handleError&quot;</span><br><span class="line">           :on-success&#x3D;&quot;handleSuccess&quot;</span><br><span class="line">           accept&#x3D;&quot;.xlsx, .xls&quot;</span><br><span class="line">           :before-upload&#x3D;&quot;onBeforeUpload&quot;</span><br><span class="line">           &gt;</span><br><span class="line">  &lt;i class&#x3D;&quot;el-icon-upload&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;&#x2F;em&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;el-upload__tip&quot; slot&#x3D;&quot;tip&quot; style&#x3D;&quot;color&#x3D;#4073ff&quot;&gt;只能上传excel文件，且不超过10MB&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;el-upload&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中对应的一些差异的js方法代码如下</span></span><br><span class="line"><span class="function"><span class="title">handleChange</span>(<span class="params">file, fileList</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.fileList = fileList;</span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此处使用 JSON.parse(err.message) 代替 JSON.stringify(err) </span></span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.parse(err.message)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg.err_msg)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>虽然 <code>Element-ui</code> 上的组件很丰富， 但是对于<strong>一个测试</strong>来说，有时候还是有些难以理解😭😭。</p><h4 id="问题1：action参数的使用问题。"><a href="#问题1：action参数的使用问题。" class="headerlink" title="问题1：action参数的使用问题。"></a>问题1：action参数的使用问题。</h4><p>在源码中 <code>action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;</code> 的使用，以及下面参数<code>action</code> 解释为：<strong>必选参数，上传的地址</strong>。这个地方就误以为只能使用 <code>URL</code> 格式，实际也可以 <code>:action</code> 直接对应后端的上传文件的API接口即可 。</p><p>解决方案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将源码中的 action=&quot;https://jsonplaceholder.typicode.com/posts/&quot; ==&gt; :action=&quot;doUpload&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">...</span><br><span class="line">  data() </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      doUpload:<span class="string">&#x27;/api/upload_excel_file&#x27;</span>,<span class="comment">// 对应后端的上传文件接口</span></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题2：需要传输指定的参数给后端接口。"><a href="#问题2：需要传输指定的参数给后端接口。" class="headerlink" title="问题2：需要传输指定的参数给后端接口。"></a>问题2：需要传输指定的参数给后端接口。</h4><p>解决方案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue 中上传组件新增 :data参数为指定需要传入给后端接口的data</span></span><br><span class="line">&lt;el-upload</span><br><span class="line">...</span><br><span class="line">  :action=<span class="string">&quot;doUpload&quot;</span></span><br><span class="line">  :data=<span class="string">&quot;specialData&quot;</span></span><br><span class="line">...</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">...</span><br><span class="line">  data() </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      doUpload:<span class="string">&#x27;/api/upload_excel_file&#x27;</span>,<span class="comment">// 对应后端的上传文件接口</span></span><br><span class="line">      specialData: &#123;</span><br><span class="line">        name: <span class="string">&quot;111&quot;</span>,<span class="comment">// 后端接口就能接收到该变量</span></span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体效果如下：</p><img src="https://i.loli.net/2021/02/26/7Jj2FYUrWc8n4L3.png" alt="upload-data.png" style="zoom:80%;" /><h4 id="问题3-针对于上传失败后，解析返回的错误信息不全。"><a href="#问题3-针对于上传失败后，解析返回的错误信息不全。" class="headerlink" title="问题3: 针对于上传失败后，解析返回的错误信息不全。"></a>问题3: 针对于上传失败后，解析返回的错误信息不全。</h4><p>具体现象如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.stringify(err)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">&#123;<span class="string">&quot;status&quot;</span>:<span class="number">400</span>,<span class="string">&quot;method&quot;</span>:<span class="string">&quot;post&quot;</span>,<span class="string">&quot;url&quot;</span>:<span class="string">&quot;/api/upload_excel_file&quot;</span>&#125; </span><br><span class="line"><span class="comment">// 实际err的信息应该如下（需要解析到里面的err_msg）：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code> JSON.stringify(err)</code> 去解析err 发现打印的数据没有想要的错误信息， 通过控制台调试的时候发现完整的err应该为如下格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>: &#123;</span><br><span class="line">  method: <span class="string">&quot;post&quot;</span></span><br><span class="line">  status: <span class="number">400</span></span><br><span class="line">  url: <span class="string">&quot;/api/upload_excel_file&quot;</span></span><br><span class="line">  message: <span class="string">&quot;&#123;↵  &quot;</span>code<span class="string">&quot;: 400, ↵  &quot;</span>data<span class="string">&quot;: &#123;&#125;, ↵  &quot;</span>err_msg<span class="string">&quot;: &quot;</span>\u5df2\u5b58\u5728\u76f8\u540c\u540d\u79f0\u7684\u6587\u4ef6<span class="string">&quot;↵&#125;↵&quot;</span></span><br><span class="line">  stack: <span class="string">&quot;Error: &#123;↵  &quot;</span>code<span class="string">&quot;: 400, ↵  &quot;</span>data<span class="string">&quot;: &#123;&#125;, </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>所以是 <code>JSON.stringify</code> 在转义的过程中少了一些字段（具体原因：<strong>JSON.stringify()只能序列化对象的可枚举的自有属性</strong>），此处解决办法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此处使用 JSON.parse(err.message) 代替 JSON.stringify(err) </span></span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.parse(err.message)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg.err_msg)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，基本已经满足了最初预定的需求。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://segmentfault.com/q/1010000019086550">Element upload组件如何获取它的on-error事件的报错信息</a><br><a href="https://segmentfault.com/a/1190000013796215">Element el-upload 上传组件详解</a><br><a href="https://element.eleme.cn/#/zh-CN/component/upload#tuo-zhuai-shang-chuan">Element 官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Element UI </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探Sqlmap（一）</title>
      <link href="%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3-%E5%88%9D%E6%8E%A2Sqlmap%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3-%E5%88%9D%E6%8E%A2Sqlmap%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    基于<a href="https://beanskingdom.top/%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3-%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%80%E6%A6%82%E5%BF%B5%E7%AF%87/">业务存在 Sql 注入危险</a> 的现状，开始研究相关工具的使用一一 Sqlmap。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    <code>Sqlmap</code> 是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。（<a href="https://github.com/sqlmapproject/sqlmap">Sqlmap源码</a>）</p><p>​    本文会简单描述下 <code>Sqlmap</code> 的使用方式，然后详细介绍下 <code>SqlmapAPI</code> 的大致原理。</p><a id="more"></a><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="一、-命令行方式"><a href="#一、-命令行方式" class="headerlink" title="一、 命令行方式"></a>一、 命令行方式</h4><p><strong>优点：</strong> 上手快，命令行输入/输出容易理解；问题定位方便。</p><p>​    对于<strong>新手初次使用该工具</strong>时候，建议<strong>使用命令行模式先将整个流程跑通</strong>（如参考：<a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a>，很详细的介绍了从Sql注入到破解数据库信息的整个过程），想了解更多命令行参数可以阅读源码目录 <code>lib/parse/cmdline</code> 文件获取更多参数的含义。</p><p><strong>大致的命令行格式如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对参数是直接拼接在链接后方的命令行</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;http://ip:port/user/login?username=foo&amp;passwd=bar&quot;</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;http://ip:port/user/login?username=foo&amp;passwd=bar&quot;</span> --batch --dbs</span><br></pre></td></tr></table></figure><p><strong>我常用的命令行参数有：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--dbms=<span class="string">&#x27;MySQL&#x27;</span><span class="comment"># 指定后台扫描数据库类型为 MYSQL</span></span><br><span class="line">--risk 3<span class="comment"># 执行中的风险系数，1~3，级别越高，可能会使用&#x27;or&#x27;等等语句，默认1</span></span><br><span class="line">--level 3<span class="comment"># 级别越高，发送的请求(payload)越多，默认1</span></span><br><span class="line">--random-agent<span class="comment"># Use randomly selected HTTP User-Agent header value</span></span><br><span class="line">--keep-alive<span class="comment"># Use persistent HTTP(s) connections</span></span><br><span class="line">--batch<span class="comment"># 自动选择默认的值，否则需要手动选择</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>注意：</strong> <strong>针对实践中的一些特定的场景，如加 <code>headers</code> 或对 <code>POST</code> 方法注入的命令行如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果需要自定义header，使用headers参数，注意：多个header之间用\n间隔</span></span><br><span class="line"><span class="comment"># 具体的data参数需要进行URL编码。</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;https://xxx/test/user&quot;</span> --headers=<span class="string">&quot;xxx: xxx\nxbbb: 4\nxcc: 111\nx-token: xxx&quot;</span> --data=<span class="string">&#x27;data=%7B%22id%22%3A%22111%22%2C%22new%22%3A%229%22%2C%20%22old%22%3A%221%22%7D&#x27;</span> --dbms=<span class="string">&#x27;MySQL &#x27;</span> --random-agent --batch </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如上请求的POST参数具体格式如下</span></span><br><span class="line">data=&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;111&quot;</span>,<span class="string">&quot;new&quot;</span>:<span class="string">&quot;9&quot;</span>, <span class="string">&quot;old&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line"><span class="comment"># 在注入的时候，要对data中所有的字段进行注入，则需要将上述data修改如下，在每个字段的value值后新增一个*号：</span></span><br><span class="line">data=&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;111*&quot;</span>,<span class="string">&quot;new&quot;</span>:<span class="string">&quot;9*&quot;</span>, <span class="string">&quot;old&quot;</span>:<span class="string">&quot;1*&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意</strong>⚠️： 对于data里面需要注入的参数带 * 号时候，转义后仍然需要是 * 号，不能直接转义，否则就导致最终仅仅是对 data最外层这个data进行了注入！！！</font></p><p><strong>缺点：</strong></p><ul><li>由于Sqlmap每检测一个站点都需要开启一个新的命令行窗口或者结束掉上一个检测任务。虽然 -m 参数可以批量扫描URL，但是模式也是一个结束扫描后才开始另一个扫描任务，执行效率较慢；</li><li>对于想获取历史任务的日志和结果操作不友好。</li></ul><p><strong>实际使用场景：我大多数时候是用该方式进行参数调试。</strong></p><h4 id="二、API请求"><a href="#二、API请求" class="headerlink" title="二、API请求"></a>二、API请求</h4><p><strong>优点：</strong> Sqlmap封装了较多的API接口，更方便操作扫描任务。</p><ul><li><p>通过 API接口下发扫描任务，无需每次执行扫描新开一个命令行窗口，通过Http接口即可执行扫描任务；</p></li><li><p>可通过 API接口获取历史执行结果以及日志进行聚合和分析。</p></li></ul><p>具体如何使用 SqlmapAPI不具体描述，可参考：<a href="https://paper.seebug.org/940/">细说Sqlmap</a>，比较详细的说明了 SqlmapAPI的使用。</p><h3 id="SqlmapAPI-原理"><a href="#SqlmapAPI-原理" class="headerlink" title="SqlmapAPI 原理"></a>SqlmapAPI 原理</h3><h4 id="SqlmapAPI-服务器启动"><a href="#SqlmapAPI-服务器启动" class="headerlink" title="SqlmapAPI 服务器启动"></a>SqlmapAPI 服务器启动</h4><p>SqlmapAPI的服务器启动逻辑还是很简单，下图为整个 <code>sqlmapapi.py</code> 脚本服务器启动流程。</p><img src="https://i.loli.net/2021/02/16/WJVaUkBYhstGRHv.png" alt="sqlmapAPI.png" style="zoom:45%;" /><h4 id="api-py"><a href="#api-py" class="headerlink" title="api.py"></a>api.py</h4><p>SqlmapAPI使用的是 <a href="https://docs.python.org/zh-cn/3/library/sqlite3.html">sqlite3</a> 数据库。在 <code>server()</code> 方法中主要是进行本地数据库的路径创建、连接以及创建必须的表结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个随机地址, 用于存放数据库文件</span></span><br><span class="line">_, Database.filepath = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.IPC, text=<span class="literal">False</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize IPC database</span></span><br><span class="line">DataStore.current_db = Database()</span><br><span class="line">DataStore.current_db.connect()</span><br><span class="line">DataStore.current_db.init()</span><br></pre></td></tr></table></figure><p>使用API模式进行sql注入测试时候，主要使用如下几个API接口（具体如何调用可参考：<a href="https://paper.seebug.org/940/">细说Sqlmap</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@get(<span class="string">&quot;/task/new&quot;</span>)<span class="comment"># 创建一个新的扫描任务</span></span><br><span class="line">@post(<span class="string">&quot;/scan/&lt;taskid&gt;/start&quot;</span>)<span class="comment"># 指定任务进行扫描</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/status&quot;</span>)<span class="comment"># 查看指定任务的状态</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/data&quot;</span>)<span class="comment"># 查看指定任务的执行结果</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/log&quot;</span>)<span class="comment"># 查看指定任务的扫描执行日志</span></span><br></pre></td></tr></table></figure><h4 id="Task执行原理"><a href="#Task执行原理" class="headerlink" title="Task执行原理"></a>Task执行原理</h4><p>此处仅介绍 <code>/scan/&lt;taskid&gt;/start</code>，主要通过 <code>DataStore.tasks[taskid].engine_start()</code> 进行执行指定任务执行扫描。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">engine_start</span>(<span class="params">self</span>):</span></span><br><span class="line">  handle, configFile = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.CONFIG, text=<span class="literal">True</span>)</span><br><span class="line">  os.close(handle)</span><br><span class="line">  saveConfig(self.options, configFile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&quot;sqlmap.py&quot;</span>):</span><br><span class="line">  self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">elif</span> os.path.exists(os.path.join(os.getcwd(), <span class="string">&quot;sqlmap.py&quot;</span>)):</span><br><span class="line">    self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, cwd=os.getcwd(), close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">elif</span> os.path.exists(os.path.join(os.path.abspath(os.path.dirname(sys.argv[<span class="number">0</span>])), <span class="string">&quot;sqlmap.py&quot;</span>)):</span><br><span class="line">    self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, cwd=os.path.join(os.path.abspath(os.path.dirname(sys.argv[<span class="number">0</span>]))), close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    self.process = Popen([<span class="string">&quot;sqlmap&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, close_fds=<span class="keyword">not</span> IS_WIN)</span><br></pre></td></tr></table></figure><p>从上面的代码来看，最终还是使用的 <code>sqlmap.py</code> 脚本来进行的任务扫描，也可以通过打印出源代码中 <code>configFile</code>  的路径，来查看每次任务的配置参数是什么。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，SqlmapAPI就介绍到此，可以看出来该脚本主要是启动一个本地数据库以及Web后台，来记录所有的任务相关信息。下一次将再继续分析 <code>sqlmap.py</code> 脚本中是如何进行sql注入的测试。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://octobug.gitbooks.io/sqlmap-wiki-zhcn/content/">sqlmap中文介绍</a><br><a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a><br><a href="https://github.com/sqlmapproject/sqlmap">Sqlmap源码</a><br><a href="https://www.freebuf.com/sectool/164608.html">Sqlmap超详细攻略</a><br><a href="https://paper.seebug.org/940/">细说Sqlmap</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全测试 </tag>
            
            <tag> Sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探安全测试</title>
      <link href="%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3-%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%80%E6%A6%82%E5%BF%B5%E7%AF%87/"/>
      <url>%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3-%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%80%E6%A6%82%E5%BF%B5%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    某天，A：你们Web后台存在安全问题，部分接口<font color=red><strong>存在SQL注入的问题</strong></font>。</p><p>​    B：…</p><p>​    B To C：接口存在SQL注入的问题，你去调研下Sqlmap。</p><p>​    C：… emm (⊙＿⊙)。</p><a id="more"></a><h3 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h3><ul><li>什么是安全问题？应用软件中又存在哪些方面的安全问题？</li><li>什么是安全测试？</li><li>常见的安全性缺陷和漏洞有哪些？</li><li>Sql注入，用于进行Sql注入的工具有哪些？</li></ul><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>​    现实生活中安全相关话题无处不在，如消防安全、卫生安全、人身安全等等，如：<strong>小区楼道中贴着一些禁止电动车在楼道中充电</strong>，因为这会存在着引发火灾的安全问题（严重的情况甚至影响到生命危险）。</p><p>​    那么应用软件中也存在安全问题，情况严重时候不仅会造成经济损失，还可能由于大量用户信息被泄漏而导致整个公司崩溃。常见的几种安全问题如下：</p><ul><li><strong>信息安全问题</strong>：如淘宝、京东中，用户一般都绑定了身份证、银行卡、手机号、家庭住址等个人隐私信息，如果这些信息泄漏给一些不法分子后，就会对一些指定用户进行电信诈骗；</li><li><strong>财产安全问题</strong>：如很多钓鱼网站，都是通过短信、微信、网页链接等方式模拟正规网页，骗取用户在上面进行操作，导致银行卡密码泄漏而造成财产损失；</li><li><strong>权限安全问题</strong>：由于权限控制不得当，非公司内部管理员也能通过某些方式对公司的私密信息进行操作，最终导致整个公司隐私泄漏或者信息错误。</li></ul><h4 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h4><p>​    个人理解安全测试应该是 <strong>一个识别应用程序潜在的安全性缺陷的过程</strong>，如：保证用户对数据或业务功能的访问，在预期的安全性情况下，操作者只能<strong>访问应用程序的特定功能、有限的数据</strong>等。</p><p>其它参考：<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95">百度–安全测试</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95">维基–渗透测试</a></p><p>​    常用的安全测试手段有：</p><ul><li>静态的代码安全测试；</li><li>动态的渗透测试；</li><li>程序数据扫描。</li></ul><h4 id="常见的软件安全性缺陷和漏洞有哪些"><a href="#常见的软件安全性缺陷和漏洞有哪些" class="headerlink" title="常见的软件安全性缺陷和漏洞有哪些"></a>常见的软件安全性缺陷和漏洞有哪些</h4><p>由于篇幅有限，暂仅对此次存在 <code>Sql注入</code> 的安全问题详细介绍。</p><ul><li><a href="https://baike.baidu.com/item/SQL%E6%B3%A8%E5%85%A5">SQL注入</a></li><li><a href="https://www.jianshu.com/p/9fc25e661ab9">XSS注入</a></li><li><a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E">远程代码执行</a></li><li><a href="https://www.netinbag.com/cn/internet/what-is-parameter-tampering.html">参数篡改</a></li><li><a href="https://www.anquanke.com/post/id/217290">弱口令</a></li><li>…</li></ul><h4 id="Sql注入"><a href="#Sql注入" class="headerlink" title="Sql注入"></a>Sql注入</h4><p>​    在没有深入之前，对于Sql注入的理解是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，然后获得该接口的返回或者绕过授权。对于存在Sql注入的威胁也仅仅是绕过登录或者获取某些普通数据。</p><p>​    然而通过资料的查询以及自身的Sqlmap实践后，才感觉一阵后怕，比较常见的威胁如下：</p><ul><li>猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。（<strong>如果存在Sql注入时，在没有特殊的安全措施下，可以理解数据库里面的所有信息都可以被获取到</strong>）</li><li>绕过认证，列如绕过验证登录网站后台。</li></ul><p>​    具体如何使用Sqlmap达到上面的效果这里就不细说了，网上这块教程比较多（如：<a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a>）。</p><h4 id="Sql注入的步骤"><a href="#Sql注入的步骤" class="headerlink" title="Sql注入的步骤"></a>Sql注入的步骤</h4><ol><li><p><strong>SQL注入点探测</strong>。</p><p>探测SQL注入点是关键的一步，通过适当的分析应用程序，可以判断什么地方存在SQL注入点。通常只要带有输入提交的动态网页，并且动态网页访问数据库，就可能存在SQL注入漏洞。如果程序员信息安全意识不强，<font color=red><strong>采用动态构造SQL语句访问数据库，并且对用户的输入未进行有效性验证，则存在SQL注入漏洞的可能性很大。</strong></font>一般通过页面的报错信息来确定是否存在SQL注入漏洞。</p></li><li><p><strong>收集后台数据库信息。</strong></p><p>不同数据库的注入方法、函数都不尽相同，因此在注入之前，我们先要判断一下数据库的类型。判断数据库类型的方法很多，可以输入特殊字符，如单引号，让程序返回错误信息，我们根据错误信息提示进行判断；还可以使用特定函数来判断，比如输入“1 and version（）&gt;0”，程序返回正常，说明 <code>version()</code> 函数被数据库识别并执行，而 <code>version()</code> 函数是 <code>MySQL</code> 特有的函数，因此可以推断后台数据库为MySQL。</p></li><li><p><strong>猜解用户名和密码。</strong></p><p>数据库中的表和字段命名一般都是有规律的。通过构造特殊SQL语句在数据库中依次猜解出表名、字段名、字段数、用户名和密码。 </p></li><li><p><strong>查找Web后台管理入口。</strong></p><p>WEB后台管理通常不对普通用户开放，要找到后台管理的登录网址，可以利用Web目录扫描工具（如：wwwscan、AWVS）快速搜索到可能的登录地址，然后逐一尝试，便可以找到后台管理平台的登录网址。</p></li><li><p><strong>入侵和破坏。</strong></p><p>一般后台管理具有较高权限和较多的功能，使用前面已破译的用户名、密码成功登录后台管理平台后，就可以任意进行破坏，比如上传<a href="https://baike.baidu.com/item/%E6%9C%A8%E9%A9%AC/530">木马</a>、篡改网页、修改和窃取信息等，还可以进一步提权，入侵Web服务器和数据库服务器。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    概念相关就介绍到此，下一篇将会具体介绍如何通过工具来进行相关Sql注入的测试一一 <code>Sqlmap</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> 安全测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全测试 </tag>
            
            <tag> Sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019~2020年回顾</title>
      <link href="%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE-2019-2020%E5%B9%B4%E5%9B%9E%E9%A1%BE/"/>
      <url>%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE-2019-2020%E5%B9%B4%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="感慨（吐槽自己…）"><a href="#感慨（吐槽自己…）" class="headerlink" title="感慨（吐槽自己…）"></a>感慨（吐槽自己…）</h3><p>​    瞬间就到了2021年了。。。依稀还记得2019年立的flags(╯▔︵▔)╯，重度拖延+健忘+各种琐事总能把一些想法扼杀在摇篮中。</p><p>比如：大一点方向就是全世界/全国旅游； 小一点方向就是学习潜水、滑雪等…</p><h3 id="庆幸"><a href="#庆幸" class="headerlink" title="庆幸"></a>庆幸</h3><p>​    让我感到欣慰的是，在2020年中下旬的开始，我的思维有了一些转变。我开始变得爱看书了（各种方面的都有，如：理财、PS、算法、逻辑思维等），这个也要归功于我主动看的第一本书籍 <code>《小强升职记》</code> （通俗易懂 + 符合现实），让我感同身受的同时，思维上也有了一个质的改变。</p><a id="more"></a><p>​    我完成了很多原来不可能会做的事情（容易量化的如下，实际还有更多就不一一列举了）：</p><ul><li>我主动看完了一本书；</li><li>我坚持了看书2个月；</li></ul><p>​    虽然按照书上的一些方法不那么有效（<em>并不是每一本书都能帮你解决什么问题，它们仅仅是一个个你的起点而已</em>），但通过不断的实践、修改、实践，我开始慢慢掌握了一个属于我自己的节奏，并且更加积极向上，我知道 2021 年会更加精彩。那些天马星空的想法也变的不那么遥不可及。</p><p>​    至此我也开始明白了一句话 一一 <code>书中自有黄金屋，书中自有颜如玉。</code></p><h3 id="2019～2020年的生活"><a href="#2019～2020年的生活" class="headerlink" title="2019～2020年的生活"></a>2019～2020年的生活</h3><blockquote><p>不如意事常八九，可与语人无二三。</p></blockquote><p>​    这一年半多的时间里，磕磕碰碰的事情挺多，过程中也一度沮丧或者低落过。特别是由于平时缺乏锻炼，感觉身体上也开始各种小毛病。（<font color=red><em>敲黑板！！！身体是革命的本钱，早期一定要注意</em></font>）。</p><p>​    刚好看到2018年时去马来西亚沙巴的一次团建（<em>早晨吹着海风躺在椰子树阴下的躺椅上，感叹着生活如此多娇</em>）。</p><center class="half">    <img title="life_photo_new_1_resize.jpeg" src="https://i.loli.net/2021/06/16/koKMbSA7YjCFI3Q.jpg"></center><h3 id="印象比较深刻的几个地方"><a href="#印象比较深刻的几个地方" class="headerlink" title="印象比较深刻的几个地方"></a>印象比较深刻的几个地方</h3><p>在面对这些大自然的美景时，整个人的心境都得到了升华，感觉什么烦恼都在那一刻抛到九霄云外。</p><h4 id="仙本那"><a href="#仙本那" class="headerlink" title="仙本那"></a>仙本那</h4><p>印象最深刻的是当时参观的<strong>巴瑶族人</strong>一一地球上最后一个海洋游牧民族，”<strong>一生</strong>“ 都在水上的民族。</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2021/06/16/3lM1m7dE4cXwpzf.jpg"></center><h4 id="塞班岛"><a href="#塞班岛" class="headerlink" title="塞班岛"></a>塞班岛</h4><p>天空和海水的搭配真的是很美（海天一色）！！！无需任何滤镜，感觉如画中一般。</p><center class="half">    <img title="life_photo_new_3_resize.jpeg" src="https://i.loli.net/2021/06/16/6a7Qx3bNktU2eGw.jpg"></center><center class="half">    <img title="life_photo_new_4_resize.jpeg" src="https://i.loli.net/2021/06/16/QvhBlWSfgM2yzNq.jpg"></center><h4 id="雁荡山"><a href="#雁荡山" class="headerlink" title="雁荡山"></a>雁荡山</h4><p>云海翻腾，山海共生。<br><img src="https://i.loli.net/2020/08/16/Dv1gQmIM3cpCTkP.jpg" alt="life_photo_5.png" style="zoom:60%;" /></p><img src="https://i.loli.net/2020/08/16/ePwQyk1zmsI9glp.jpg" alt="life_photo_6.png" style="zoom:60%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    <strong>其实生活也就那样一一酸甜苦辣</strong>。（乍得一看有点像是一篇游记(╯▔▽▔)╯ ）</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT + Valine躺坑之路</title>
      <link href="Hexo%E5%BB%BA%E7%AB%99-next-Valine%E8%BA%BA%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
      <url>Hexo%E5%BB%BA%E7%AB%99-next-Valine%E8%BA%BA%E5%9D%91%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    写了一段时间博客后，发现别人的文章有浏览次数以及评论功能★~★，这也某种程度上提高写 <em>Blog</em> 的动力，那我也来弄一个哈哈哈。。。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>​    然而，事实总是那么折磨人。。。使用的是 <em>nexT</em> 主题的 <em>v8.2.1</em> 版本，按照网上的<a href="https://qianfanguojin.github.io/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">教程</a>后一直没有达到最终的效果😭😭。</p><a id="more"></a><h4 id="问题1-使用-Valine-插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。"><a href="#问题1-使用-Valine-插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。" class="headerlink" title="问题1: 使用 Valine 插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。"></a>问题1: 使用 <em>Valine</em> 插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。</h4><p>具体原因：因为 <code>v8.2.1 版本已经将 Valine 功能去除掉了</code>。（详情见<a href="https://github.com/next-theme/hexo-theme-next/issues/188">官网解释</a>）也尝试了官网中的解决办法以及各种网上的方法，但是仍然无效。（瞎折腾了3个小时都没结果。。。气到内伤😭😭）</p><p>那就将版本降低到能使用的 <em>Valine</em> 的 <em>NexT</em> 版本呢？（如降低到<a href="https://github.com/theme-next/hexo-theme-next/releases/tag/v7.8.0">7.8.0</a>版本呢？？）<code>降低版本到7.8.0后，问题就解决了</code>。</p><h4 id="问题2-降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。"><a href="#问题2-降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。" class="headerlink" title="问题2: 降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。"></a>问题2: 降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击中文标题导航栏时候，console控制台中报错，并且页面上没有跳转到对应的标题位置。</span></span><br><span class="line">Cannot read property <span class="string">&#x27;getBoundingClientRect&#x27;</span> <span class="keyword">of</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>实际原因是:  <code>themes/next/source/js/utils.js</code> 中的代码存在遗漏，没有对中文进行URL解码。具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... <span class="comment">// 其他多余代码省略</span></span><br><span class="line"><span class="comment">// 在这个地方获取 event 的属性时候，中文的会被自动转成URI编码格式</span></span><br><span class="line"><span class="comment">// href=&quot;#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4&quot; </span></span><br><span class="line"><span class="comment">// 但文章中的Id仍然是中文的 &lt;h3 id=&quot;操作步骤&quot;&gt;, 所以导致此处的target为null。</span></span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(event.currentTarget.getAttribute(<span class="string">&#x27;href&#x27;</span>).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br><span class="line">... <span class="comment">// 其他多余代码省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法：将上述代码替换如下代码即可。</span></span><br><span class="line"><span class="keyword">var</span> str_id = <span class="built_in">decodeURI</span>(event.currentTarget.getAttribute(<span class="string">&#x27;href&#x27;</span>).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(str_id);</span><br><span class="line"><span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br></pre></td></tr></table></figure><p>至此， 终于得到了自己想要的效果。。。（＋﹏＋）（＋﹏＋）</p><img src="https://i.loli.net/2021/02/09/vLhxcG8jZfyk46u.png" alt="valine_result.png" style="zoom:50%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    很多时候遇到的问题，通过网上不一定能适用自己当前的场景，并不一定是别人的方式有问题。。。很可能是你的环境和别人的就不一样，所以<code>同样的操作不一定能解决同样现象的问题</code>。。。还是需要多排查定位看看主要的问题点在哪。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
            <tag> Valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Py-spy解决Python程序Hang住问题</title>
      <link href="python-py-spy%E8%A7%A3%E5%86%B3Python%E7%A8%8B%E5%BA%8FHang%E4%BD%8F%E9%97%AE%E9%A2%98/"/>
      <url>python-py-spy%E8%A7%A3%E5%86%B3Python%E7%A8%8B%E5%BA%8FHang%E4%BD%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    已经集成的接口自动化测试 Job 在周期性定时运行的时候，会很小概率出现一直卡在那里，原本应该3min就执行完成的任务，偶尔过了半个小时还没结束。（(￣３￣)直觉告诉我这个地方肯定有问题。。。</p><p>​    但由于复现的概率较小，一个月可能出现一次，所以开始并没有什么太大的线索（仅靠一些猜测并不切实际）。</p><p>​    终于！！！在某一个阳光明媚的大好日子，<strong>它重现了</strong>。</p><a id="more"></a><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ol><li><p>赶紧先登录到服务器上看看进程情况，发现此时存在脚本发起的2个 Worker CPU占用100%（由于用的 <code>Pytest + Pytest-xdist</code>  分布式插件执行用例），当时第一反应是死循环了？？</p><img src="https://i.loli.net/2021/01/22/AVhg7RGzYIfuWtN.png" alt="process_hang_1.png" style="zoom:50%;" /></li><li><p>通过<strong>perf</strong> 、<strong>ps</strong>或者 <strong>pstack</strong> 打印对应的pid， 看到的结果并没有什么太大用，反而<strong>误导我以为是代码里面的一个文件锁导致该问题</strong>。</p><img src="https://i.loli.net/2021/01/22/E1Yq9cjRo2GOx5e.png" alt="process_hang_2.png" style="zoom:50%;" /></li><li><p>网上查询了一通后，发现一个神奇的工具一一 <a href="https://www.zhihu.com/question/310832912">py-spy</a> （更多使用方法见 <a href="https://pypi.org/project/py-spy/">官网</a>）</p><p>安装后使用命令 ：选定一个异常的进程，执行命令： <code>py-spy  top --pid 19785</code> 打印结果如下，很明显看出来当前Cpu都卡在 <code>check_retry_status</code> 方法上面。</p><img src="https://i.loli.net/2021/01/22/CuRZJnsj13eTXoQ.png" alt="process_hang_3.png" style="zoom:50%;" /></li><li><p>查看该代码，发现该方法中存在一个while循环，并且很凑巧的是。。。╮(╯3╰)╭ 里面<font color=red><strong>没有兜底</strong></font>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体代码如下，过于相信传进来的 retry_flag 一定是1/2， 如果出现不是这两个值的时候，此时这个方法则进入了死循环。。。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_retry_status</span>(<span class="params">cls, uid, atk, order_id, retry_flag, devuuid</span>):</span></span><br><span class="line">    max_count = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> max_count &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> retry_flag == <span class="number">2</span>:</span><br><span class="line">        retry_flag = functionA(xxx, ...)</span><br><span class="line">        max_count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> retry_flag == <span class="number">1</span>:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;验证充值订单失败&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>到这个地方，就很明显定位到了问题，在此处加上兜底并且加上对应日志记录functionA（<strong>第三方依赖</strong>）到底返回的是什么。（ 因为首次传入的 retry_flag 也是来自于functionA）</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    写代码要谨慎。。。特别是结果来自第三方依赖的时候。。。<strong>一定要进行兜底！！！</strong></p><p>​    （emm… 兜一下总比不兜强）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python Plugin </tag>
            
            <tag> py-spy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python调用gRPC接口</title>
      <link href="python-python%E8%B0%83%E7%94%A8gRPC%E6%8E%A5%E5%8F%A3/"/>
      <url>python-python%E8%B0%83%E7%94%A8gRPC%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近几个项目都是用的go语言编写的，使用的是 gRPC接口，是没有对外暴露http接口。但在部分场景下，由于可测性的需要必须直接调用 gRPC接口，达到数据的构造，所以需要通过 <code>Python</code> 代码完成调用服务器上的 gRPC接口 。</p><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><p>​    由于网上相关最简单的demo已经是烂了一地。。。我这边就不再去重复写一段demo了（可参考当时我看的一篇<a href="https://cloud.tencent.com/developer/article/1557398">Blog</a>，或自行搜索相关前置准备）。</p><p>​    主要记录在实际过程中运用遇到的一些问题，希望能给大家一些帮助。</p><a id="more"></a><h4 id="步骤一：在执行转化脚本命令时候报错，具体信息如下："><a href="#步骤一：在执行转化脚本命令时候报错，具体信息如下：" class="headerlink" title="步骤一：在执行转化脚本命令时候报错，具体信息如下："></a>步骤一：在执行转化脚本命令时候报错，具体信息如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. ./user.proto</span><br><span class="line"></span><br><span class="line">github.com/gogo/protobuf/gogoproto/gogo.proto: File not found.</span><br><span class="line">base.proto: File not found.</span><br><span class="line">user.proto:7:1: Import <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span> was not found or had errors.</span><br><span class="line">user.proto:8:1: Import <span class="string">&quot;base.proto&quot;</span> was not found or had errors.</span><br><span class="line">user.proto:47:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:59:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:86:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:239:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:258:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br></pre></td></tr></table></figure><p>针对报错问题一个个分析。</p><h5 id="问题1-github-com-gogo-protobuf-gogoproto-gogo-proto-File-not-found。"><a href="#问题1-github-com-gogo-protobuf-gogoproto-gogo-proto-File-not-found。" class="headerlink" title="问题1: github.com/gogo/protobuf/gogoproto/gogo.proto: File not found。"></a>问题1: github.com/gogo/protobuf/gogoproto/gogo.proto: File not found。</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于转化的脚本中直接以如下方法引用的 gogo.proto 文件，但在转换的时候肯定是找不到的</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span></span><br></pre></td></tr></table></figure><p>解决办法：</p><ol><li><p>将 <a href="https://github.com/gogo/protobuf/blob/master/gogoproto/gogo.proto">gogo.proto</a> 文件下载到本地，放到与需要转换的 user.proto 文件同级目录下;</p></li><li><p>修改 user.proto 的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将如下代码修改成 import &quot;gogo.proto&quot;</span></span><br><span class="line">import <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="问题2-base-proto-File-not-found。"><a href="#问题2-base-proto-File-not-found。" class="headerlink" title="问题2: base.proto: File not found。"></a>问题2: base.proto: File not found。</h5><p>解决方式同问题1，实际就将依赖的这个 base.proto 文件放到与需要转换的 user.proto 文件同级目录下即可。（<code>由于我的 base.proto 文件中也同问题1中一样引用了 gogo.proto，所以都需要重复问题1的步骤2</code>）</p><p>经过上面操作，终于将 user.proto 文件转成了对应的python脚本，具体样式如下。</p><img src="https://i.loli.net/2021/02/07/B8rjYhz1ZksDfiq.png" alt="python_convert_grpc.png" style="zoom:40%;" /><p>但你以为这就完事了？？(╯▔︹▔)╯ ， <code>Too young too simple</code></p><h4 id="步骤二：调用转换成python脚本的接口。"><a href="#步骤二：调用转换成python脚本的接口。" class="headerlink" title="步骤二：调用转换成python脚本的接口。"></a>步骤二：调用转换成python脚本的接口。</h4><p><em>注：由于无需本地启动一个服务端，所以可以简单点只写一个调用端即可（具体方式类似 <code>BloomRPC</code>，通过  <code>kubectl</code> 代理到远端的 <code>grpc</code>服务端， 具体原理可自行搜索）</em></p><p>在写客户端代码之前，就还存在一个隐藏问题。</p><h5 id="问题3-实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成-python脚本（根据个人需要进行转换）。"><a href="#问题3-实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成-python脚本（根据个人需要进行转换）。" class="headerlink" title="问题3: 实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成 python脚本（根据个人需要进行转换）。"></a>问题3: 实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成 python脚本（根据个人需要进行转换）。</h5><p>客户端代码大致如下（<em>我编写的demo中则无需转换其它文件</em>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> user_pb2_grpc, user_pb2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">userService</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_mobile_by_id</span>(<span class="params">cls</span>):</span></span><br><span class="line">      <span class="comment"># 连接上本地的gRPC代理服务端, 端口为kubectl本地代理的端口</span></span><br><span class="line">        channel = grpc.insecure_channel(<span class="string">&#x27;localhost:6666&#x27;</span>) </span><br><span class="line">        <span class="comment"># 根据对应服务初始化渠道</span></span><br><span class="line">        test_stub = user_pb2_grpc.UserStub(channel)          </span><br><span class="line">        user_id = <span class="number">1234</span></span><br><span class="line">        <span class="comment"># 根据具体的 Request 定义来传入参数, 否则会报错</span></span><br><span class="line">        <span class="keyword">return</span> test_stub.GetXxxById(user_pb2.GetXxxByIdRequest(userId=user_id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(userService.get_mobile_by_id())</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 执行效果如下</span></span><br><span class="line">(ENV) ➜  demo_python_convert_grpc python user_client.py</span><br><span class="line">mobileId: <span class="string">&quot;11166668888&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数按照 user_pb2.py中方法Request定义的FieldDescriptor中具体的name来传入</span></span><br><span class="line">fields=[</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;userId&#x27;</span>, full_name</span><br><span class="line">      ...]</span><br></pre></td></tr></table></figure><p>​    至此，整体调用 <code>gRPC接口</code> 的流程算是跑通了，后续就看各自业务需求来定制化了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    最后吐槽下，很多时候准备做一件事的时候，发现网上教程挺多的，但是也会发现那些 “教程” 可能<strong>千篇一律</strong>。。。有些甚至一摸一样╮(╯Д╰)╭ 。。。当你真正按照这些 “教程” 来操作的时候又会发现可能不那么简单，所以说：<font color=blue><strong>实践是检验真理的唯一标准</strong> ！！！</font></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> gRPC接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Set命令</title>
      <link href="Linux-Linux-Set%E5%91%BD%E4%BB%A4/"/>
      <url>Linux-Linux-Set%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    有时候在执行shell脚本的时候，在运行/调试的过程中会有些报错看起来不是太明显，那如何高效的调试自己编写的shell脚本呢？？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>​    网上有一些解决方案，但是尝试了下后觉得使用 shell 中的 <strong>set</strong> 命令来解决更加方便和快捷。下面来看看 <strong>set</strong> 命令到底能够有哪些应用场景。</p><a id="more"></a><h4 id="（1）set-u"><a href="#（1）set-u" class="headerlink" title="（1）set -u"></a>（1）set -u</h4><p>​    执行脚本的时候，有时候会遇到变量未定义（如：拼写错误导致变量未定义），Bash 默认是忽略它并且继续执行的，在某些场景这可能会对后面的脚本造成不可预期的错误操作， 所以可以通过 <code>set -u</code> 来控制，具体案例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line"></span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>​    可以看到，<code>echo $a</code> 输出了一个空行，Bash 忽略了不存在的 $a，然后继续执行 <code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p><p>通过脚本在头部加上 <code>set -u</code> 后，遇到不存在的变量就会报错，并停止执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -u</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 4: a: unbound variable</span><br></pre></td></tr></table></figure><h4 id="（2）set-x"><a href="#（2）set-x" class="headerlink" title="（2）set -x"></a>（2）set -x</h4><p>​    在执行复杂脚本的时候，需要对脚本进行类似debug一样的操作，则可以通过设置 <code>set -x</code>，这样就会对脚本中的执行过程的变量以及具体执行的代码进行输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line">name=<span class="string">&quot;tester&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;name&#125;</span> == <span class="string">&quot;tester&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;failed...&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> end</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">+ name=tester</span><br><span class="line">+ [[ tester == \t\e\s\t\e\r ]]</span><br><span class="line">+ <span class="built_in">echo</span> hello</span><br><span class="line">hello</span><br><span class="line">+ <span class="built_in">echo</span> end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>​    可以看到，在进行条件判断的时候，变量name被具体值替换了，打印了代码走到了条件分支的哪一步，以及打印了相应的有输出的代码行，行首以+表示。这对于调试复杂的脚本是很有用的。</p><h4 id="（3）set-e"><a href="#（3）set-e" class="headerlink" title="（3）set -e"></a>（3）set -e</h4><p>​    如果脚本里面有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令，在实际开发中，这种会导致比较严重的影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 5: foo: <span class="built_in">command</span> not found</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>通过使用 <code>set -e</code> 则可以运行失败的命令就直接退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 6: foo: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>也可以通过下面的方式来指定具体某个代码块运行失败后自动退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -e      <span class="comment"># 表示打开遇到运行命令返回非0则退出</span></span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line"><span class="built_in">set</span> +e      <span class="comment"># 表示关闭遇到运行命令返回非0则退出</span></span><br></pre></td></tr></table></figure><h4 id="（4）set-o-pipefail"><a href="#（4）set-o-pipefail" class="headerlink" title="（4）set -o pipefail"></a>（4）set -o pipefail</h4><p>​    <code>set -e</code> 有一个例外情况，就是不适用于管道命令。Bash 会把<strong>最后一个子命令的返回值</strong>，作为<strong>整个命令的返回值</strong>。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code> 就失效了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">foo | <span class="built_in">echo</span> a</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 7: foo: <span class="built_in">command</span> not found</span><br><span class="line">a</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>​    上面代码中，<strong>foo</strong>是一个不存在的命令，但是 <code>foo | echo a</code> 这个管道命令会执行成功，导致后面的 <code>echo bar</code> 会继续执行。</p><p>​     <code>set -eo pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本会在该管道执行完后终止执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line"></span><br><span class="line">foo | <span class="built_in">echo</span> a</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 7: foo: <span class="built_in">command</span> not found</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>​    可以看出，管道任务失败后，echo bar则未进行执行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    set命令的上面这四个参数，一般都放在一起使用，常用的两种方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell 脚本调试 </tag>
            
            <tag> shell 命令 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之优化（一）</title>
      <link href="Hexo%E5%BB%BA%E7%AB%99-Hexo%E4%B9%8B%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>Hexo%E5%BB%BA%E7%AB%99-Hexo%E4%B9%8B%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>​    继上一篇搭建完最基础的Hexo环境并且发布一篇Demo文章后，基本上能满足了平时的个人Blog编写以及发布，但很多地方还是用户体验不太好，于是再对自己的Blog进行一系列的优化😁😁。</p><h4 id="优化一：Hexo-主题优化"><a href="#优化一：Hexo-主题优化" class="headerlink" title="优化一：Hexo 主题优化"></a>优化一：Hexo 主题优化</h4><p>​    网上搜了下大部分都用的 <a href="https://github.com/next-theme/hexo-theme-next">nexT</a> 这个主题，于是就直接参照对应的 <a href="https://theme-next.js.org/docs/getting-started/">官网链接</a> 操作即可。（顺便继续记录一些遇到的坑~~）如果觉得默认的主题已经不错了的可以直接跳过改步骤（<strong>但后续优化<font color=red>基于nexT v8.2.1版本优化</font>，不一定全部通用于其他主题</strong>）。</p><a id="more"></a><ul><li><p><strong>问题1: 由于官网是英文版，在网上搜索中文版本代码过老导致启动进入 localhost:4000页面仅展示如下错误内容。</strong></p><p>如果你看的教程是 <code>https://theme-next.iissnan.com/getting-started.html</code>，那么就要注意了，该链接中的nexT代码过于老旧了，可能会存在一定的问题，建议使用 <a href="https://theme-next.js.org/docs/getting-started/">官网链接</a> 。</p></li></ul><p><strong>参照最新版的教程修改完主题后，最新的样式就如下图：</strong></p><img src="https://i.loli.net/2021/02/03/1jk4csEovyJWgnM.png" alt="hexo_default.png" style="zoom:30%;" /><p>​    这个时候问题来了，<strong>如果每篇文章都如上，篇幅比较长，那么就导致首页每次展示的文章数量过少。</strong></p><h4 id="优化二：文章折叠展示-对文章添加分类、标签等"><a href="#优化二：文章折叠展示-对文章添加分类、标签等" class="headerlink" title="优化二：文章折叠展示 + 对文章添加分类、标签等"></a>优化二：文章折叠展示 + 对文章添加分类、标签等</h4><ul><li><p>步骤一：修改nexT主题目录下的_config.yml配置 (将文件中的注释去掉即可)。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure></li><li><p>步骤二：给文章添加对应的属性（如：tags、categories、description）。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="string">首次搭建个人Blog</span> <span class="string">问题记录（一）</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-02-01 22:14:05</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">blog搭建</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo建站</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">hexo建站</span></span><br></pre></td></tr></table></figure><p><strong>问题2：设置首页新增了 <code>tags 和 categories</code> 页后，点击进入到对应的 tags 或者 categories 的时候没有想要的内容， 仅仅一个 tags 或者 categories 标签。</strong></p><p>原因: 在执行 <code>hexo new page &quot;tags&quot;</code> 这一步自动生成的index.md 文件中内容缺失导致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决办法如下操作，打开对应的 blog_dir/source/tags/index.md 文件, 在最后补充如下代码</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span><span class="comment"># about/categories页操作将tags替换成about/categories即可</span></span><br></pre></td></tr></table></figure></li><li><p>步骤三：文章折叠的<a href="http://theme-next.iissnan.com/faqs.html#%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95">解决办法</a> (个人选择了方法一)</p></li></ul><p>优化完后的效果如下：</p><img src="https://i.loli.net/2021/02/03/1I6TEuywBj2QG7R.png" alt="nexT_first.png" style="zoom:40%;" /><h4 id="优化三：-文章生成短链接"><a href="#优化三：-文章生成短链接" class="headerlink" title="优化三： 文章生成短链接"></a>优化三： 文章生成短链接</h4><p>点开上图的阅读全文后，发现整体的链接是一大串文字，这个时候看起来就比较怪异，并且复制出来后直接会是URL编码的格式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://beanskingdom.github.io/2021/02/01/Hexo-首次搭建遇到的问题/#more</span><br><span class="line">https://beanskingdom.github.io/2021/02/01/Hexo-%E9%A6%96%E6%AC%A1%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/#more</span><br></pre></td></tr></table></figure><p>此时可以通过Hexo-abbrlink生成唯一永久文章链接（<a href="https://github.com/Rozbo/hexo-abbrlink">参考链接</a>）。 </p><p>最终的效果则为：<code>xxx/posts/48255dc8/#more</code></p><h4 id="优化四：修改文内链接样式"><a href="#优化四：修改文内链接样式" class="headerlink" title="优化四：修改文内链接样式"></a>优化四：修改文内链接样式</h4><p>nexT默认文章链接样式如下图：</p><img src="https://i.loli.net/2021/02/03/q2CwmFHZsNoyYlW.png" alt="next_link_style.png" style="zoom:40%;" /><p>为了突出区别性，我们在对应文件中添加下列的代码即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">themes</span>/<span class="selector-tag">next</span>/<span class="selector-tag">source</span>/<span class="selector-tag">css</span>/_<span class="selector-tag">common</span>/<span class="selector-tag">components</span>/<span class="selector-tag">post</span>/<span class="selector-tag">post-body</span><span class="selector-class">.styl</span></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的样式如下：</p><img src="https://i.loli.net/2021/02/03/L4j9vFUxBl2o3cM.png" alt="next_link_update.png" style="zoom:40%;" /><h4 id="优化五：给主页文章添加阴影效果"><a href="#优化五：给主页文章添加阴影效果" class="headerlink" title="优化五：给主页文章添加阴影效果"></a>优化五：给主页文章添加阴影效果</h4><p>打开<code>themes/next/source/css/_common/components/post/index.styl</code>文件，将<code>post-block</code>代码进行如下更改：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (hexo-config(&#x27;motion.transition.post_block&#x27;)) &#123;</span><br><span class="line">  # 添加如下代码</span><br><span class="line">    <span class="selector-class">.post-block</span>&#123;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">        <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">        background:rgba(255,255,255,0.9) none repeat scroll !important; //添加透明效果</span><br><span class="line">        <span class="selector-tag">-webkit-box-shadow</span>: 0 0 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(202, 203, 203, .5);</span><br><span class="line">        <span class="selector-tag">-moz-box-shadow</span>: 0 0 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(202, 203, 204, .5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="优化六：文章内部的导航栏位置优化"><a href="#优化六：文章内部的导航栏位置优化" class="headerlink" title="优化六：文章内部的导航栏位置优化"></a>优化六：文章内部的导航栏位置优化</h4><p>默认文章内部的导航栏位置是在左侧，看文章时候比较怪异，所以优化到了右边。</p><p>打开 <code>themes/next/_config.yml</code> 文件，将如下代码修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="comment"># position: left# 将改行注释掉，再去掉下面一行的注释</span></span><br><span class="line">  position: right</span><br></pre></td></tr></table></figure><h4 id="优化七：给文章末尾添加结束语"><a href="#优化七：给文章末尾添加结束语" class="headerlink" title="优化七：给文章末尾添加结束语"></a>优化七：给文章末尾添加结束语</h4><ul><li><p>在 <code>themes/next/layout/_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件，添加代码至该文件中；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">      &lt;div style=<span class="string">&quot;text-align:center;color: #ccc;font-size:20px;&quot;</span>&gt;------------- 本 文 结 束 &lt;i class=<span class="string">&quot;fa fa-paw&quot;</span>&gt;&lt;/i&gt; 感 谢 您 的 阅 读 -------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>themes/next/layout/_macro/post.njk</code> 文件，在 post-body 后，post-footer 前，添加下面内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">&#x27;passage-end-tag.swig&#x27;</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在如下内容之前添加上述代码</span></span><br><span class="line"><span class="comment">#    &#123;#####################&#125;</span></span><br><span class="line"><span class="comment">#    &#123;### END POST BODY ###&#125;</span></span><br><span class="line"><span class="comment">#    &#123;#####################&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在主题配置文件 <code>_config.yml</code> 在末尾添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="优化八：给代码块添加复制功能"><a href="#优化八：给代码块添加复制功能" class="headerlink" title="优化八：给代码块添加复制功能"></a>优化八：给代码块添加复制功能</h4><p>打开 <code>themes/next/_config.yml</code> 主题配置文件，搜索 codeblock ,开启复制，修改代码如下。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">copy_button:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span><span class="comment"># 显示复制按钮</span></span><br><span class="line">  <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">flat</span><span class="comment"># 复制按钮展示形式</span></span><br></pre></td></tr></table></figure><h4 id="优化九：实现统计功能"><a href="#优化九：实现统计功能" class="headerlink" title="优化九：实现统计功能"></a>优化九：实现统计功能</h4><p>在根目录下安装 <code>hexo-wordcount</code>,运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>然后在主题的配置文件中，配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    至此，部分个人体验相关的优化已经结束，这个时候可以开心的写blog了，自己看起来效果也不错，但这样你满足了么？？</p><p>​    当然不满意啦！！！ 至少要看到有多少人来看我的blog吧？😄😄静待后续优化。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 首次搭建个人Blog问题记录</title>
      <link href="Hexo%E5%BB%BA%E7%AB%99-Hexo-%E9%A6%96%E6%AC%A1%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>Hexo%E5%BB%BA%E7%AB%99-Hexo-%E9%A6%96%E6%AC%A1%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    看到别人那么炫酷的个人Blog后，自己也突然有了一些想法，既而最近看了《小强升职记》中的第五章让目标落地，于是便马上开始规划起了自己的Blog。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>​    通过这个Blog记录生活中的点点滴滴。</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>​    由于这类型的文章在网上太多了。。。具体的搭建过程就不一一搬运了。（个人觉得比较详细的一个链接：<a href="https://www.cnblogs.com/shwee/p/11421156.html">Hexo+Github: 个人博客网站搭建完全教程(看这篇就够了)</a>）</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>​    emm…有一个比较详细的教程是多么重要的一件事，虽然别人的Blog上看起来也就1个小时的事，实际自己做起来却花费了大半天😭😭。。。总结了以下在搭建过程中自己遇到的坑。</p><ol><li><p><strong>执行修改_config.yml文件后，执行创建新的文章命令时候报错。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;Bigbean&#x27;s demo&quot;</span></span><br><span class="line">FATAL TypeError: Invalid config detected: <span class="string">&quot;url&quot;</span> should be string, not object!</span><br><span class="line"></span><br><span class="line">原因：拷贝其他教程的配置文件时候，url:  <span class="comment">#网址 这个地方未配置</span></span><br></pre></td></tr></table></figure></li><li><p><strong>发布了第一篇文章后，页面打开显示错误。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端里面报错 </span></span><br><span class="line">WARN  No layout: index.html</span><br></pre></td></tr></table></figure><p>原因：在步骤3中按照参考链接中改了配置后，实际并没有链接中的那个主题 <code>theme: landscape-plus</code>， </p><p>所以<font color=red><strong>修改_config.yml配置文件的时候一定要注意！！！再次提醒不要全部照抄，应该仅仅是改自己需要改的地方。</strong></font></p></li><li><p><strong>在执行 <code>hexo d</code> 发布的时候报错。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: git</span><br><span class="line"><span class="comment"># 这是因为没安装hexo-deployer-git插件，在站点目录下输入下面的插件安装就好了</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p><strong>怎么再通过github的链接直接访问网上远端的效果呢？</strong></p><p>进入 github 项目中点击 Settings，向下拉到最后有个 GitHub Pages，点击 Choose a theme 选择一个主题。然后等一会儿，再回到 GitHub Pages，就会变成你选择的主题。<a href="https://zhuanlan.zhihu.com/p/35668237">参考链接</a></p></li><li><p><strong>按照6中的操作后，github page一直未被识别，导致点击链接去看里面样式找不到。（<a href="https://www.cnblogs.com/shwee/p/11421156.html">参考链接</a>）</strong></p><p>原因： 要创建一个和你用户名相同的仓库，后面加 <strong>.github.io</strong>，只有这样，将来要部署到 <code>GitHub page</code> 的时候，才会被识别 。例如我的：<a href="https://beanskingdom.github.io/">beanskingdom.github.io</a></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        至此。。。终于完成了第一篇内容的发布，后续还会继续进行相关的优化，如：主题、评论、搜索等等。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
