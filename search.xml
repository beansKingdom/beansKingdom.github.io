<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>结构化思维读后感一一初识思维</title>
      <link href="posts/50e7aed3/"/>
      <url>posts/50e7aed3/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    很多时候，<strong>你可能不知道思维对你的生活到底造成了多大的影响</strong>。（就如同以前的我。。。）刚好最近还看了一部电影一一<strong>华仔的《拆弹专家2》</strong>，里面很明显的展示出了不同的思维对主角（刘德华）带来了多大的影响。</p><p>​    <font color=gray>备注：可能很多地方也推荐《金字塔原理》，但个人觉得如果是入门可以先看《结构化思维》更加浅显易懂。</font></p><a id="more"></a><h3 id="思维的意义"><a href="#思维的意义" class="headerlink" title="思维的意义"></a>思维的意义</h3><p>​    <font color=blue><strong>思维的意义，它是我们解读事实的起点，是产生行为的源头，是决定结果的根本。</strong></font></p><p>​    本书中刚开始就用了很多比较形象的案例阐述了思维在这些案例中的影响（意义），我个人理解思维在情绪上大致可以总结为：<code>积极的思维</code> 和 <code>消极的思维</code> 两种（有兴趣可以自行查阅书中的案例）。</p><p>​    <font color=blue>在不同的思维下，对于做事情的态度和行为也会天差地别。</font></p><p><strong>从以下几个大部分人可能都经历过的实际场景来看</strong>（平时工作中的年终考核或者季度考核）<font color=gray><em>我不以偏概全，但如果把我自己代入到这个场景后我可能会有如下想法。</em></font></p><ul><li><p><strong>你得知你自己的绩效较差或者你觉得自己能拿A，但是实际只给了你B。</strong></p><p>以前的我第一想法可能就是：<strong>搞什么鬼？， 这领导是给我穿小鞋吧，然后开始对于后面的工作有所松懈，更极端点就是离职</strong>。</p></li><li><p><strong>在上面的场景下，你得知自己只得到了B，小明得到了A（并且你觉的小明不如自己）。</strong></p><p>以前的我第一想法可能是：<strong>他做的和我一样呀，感觉都还不如我做的好，不会是靠拍马屁上去的吧？</strong></p></li></ul><p>先不管上面的猜测或者臆断的想法是否是事实，但是可以发现产生我上述的想法的根本原因之一就是一一<code>消极思维</code>。以至于对后面的工作也可能越做越差，那后续的绩效也可想而知。</p><p>看了这章节后，我明白了思维的重要性，现在的我至少在再次面对上面的场景时候，我能从更深层次去思考问题（后续会介绍我的步骤）。</p><p>⚠️ 注意：<strong>道理可能大家都懂，但是真的碰到后不按照道理说的来做那还不如开始不懂这个道理！！！</strong></p><p>书上的关于改变思维的原话是：</p><blockquote><p>如果过往事实不能改变，我们就只能改变思维，改变面对事实的态度和行为，让未来过得更好，避免发生悲剧。改变思维才是改变一切的源头。</p></blockquote><p>我读了本书后，新的想法可以分为如下几个步骤：</p><ol><li><strong>先保持冷静以及抛开所有上述自己开始的猜想或者臆断</strong>（如果有这些主观因素影响的话，后面的步骤可能效果不佳）；</li><li><strong>仔细思考下这一年或者这一个季度自己做的东西是否真的如自己想象中那么好？</strong><ul><li>如果是自己真的做的不好，那么后面<strong>需要进行反省以及制定对应的改进计划</strong>，并且将自己的改进计划与领导进行核对确认，避免大方向错误。（这牵涉到<strong>向上管理</strong>，有兴趣的可以搜索这方面书籍）；</li><li>如果真的是自己做的好，那么总结出自己做的好的内容，与领导进行核对，确认是否两端有误会，<strong>而不是直接放手不干</strong>。</li></ul></li><li><strong>仔细思考下小明是不是真的不如自己？</strong><ul><li>如果小明真的是不如自己，那么总结出自己做的比小明好的地方，与领导进行核对，确认是否两端有误会，<strong>而不是背地里猜忌</strong>。</li><li>如果小明真的做的比自己好，那么就需要<strong>提取出小明的优势，然后制定自己的改进计划，并且将自己的改进计划与领导进行核对确认，避免误解了小明做的好的地方。</strong></li></ul></li></ol><p><font color=gray><em>但如果上述步骤做了后，发现确实不是自己的问题的时候，如何抉择很重要，但绝不能因为这件事而影响以后的工作或者生活。</em></font></p><h3 id="本节总结"><a href="#本节总结" class="headerlink" title="本节总结"></a>本节总结</h3><p>​    最后还是再强调一句：<code>如果过往事实不能改变，我们就只能改变思维，改变面对事实的态度和行为，让未来过得更好，避免发生悲剧。改变思维才是改变一切的源头。</code></p><p>​    发生任何事情， <code>积极思维</code> 一般都比 <code>消极思维</code> 要好，当然有时候一些悲伤的事情，适当的 <code>消极思维</code> 也是可以的，但一定要注意及时调整自己的思维，否则浪费的就是自己的时间。（可能大家有更好的想法💡，欢迎一起讨论实践）。 </p>]]></content>
      
      
      <categories>
          
          <category> 软素质 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软素质 </tag>
            
            <tag> 逻辑思维 </tag>
            
            <tag> 读后感 </tag>
            
            <tag> 结构化思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue + Element el-upload实现上传文件</title>
      <link href="posts/bb375789/"/>
      <url>posts/bb375789/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近在开发测试用例管理平台，其中需要实现上传用例的 <strong>Excel</strong> 文件。</p><h3 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h3><p>​    通过  <code>Element-ui</code> 很轻松就找到了对应的组件（<a href="https://element.eleme.cn/#/zh-CN/component/upload#tuo-zhuai-shang-chuan">Element-ui具体代码</a>），通过查找资料以及填坑，最终实现的效果如下：</p><img src="https://i.loli.net/2021/02/26/CZyFN5EdbTUOXgq.png" alt="finally-ui-import.png" style="zoom:40%;" /><a id="more"></a><p>具体核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-upload</span><br><span class="line">           class&#x3D;&quot;upload-demo&quot;</span><br><span class="line">           drag</span><br><span class="line">           :action&#x3D;&quot;doUpload&quot;</span><br><span class="line">           :data&#x3D;&quot;specialData&quot;</span><br><span class="line">           :on-change&#x3D;&quot;handleChange&quot;</span><br><span class="line">           :file-list&#x3D;&quot;fileList&quot;</span><br><span class="line">           :on-error&#x3D;&quot;handleError&quot;</span><br><span class="line">           :on-success&#x3D;&quot;handleSuccess&quot;</span><br><span class="line">           accept&#x3D;&quot;.xlsx, .xls&quot;</span><br><span class="line">           :before-upload&#x3D;&quot;onBeforeUpload&quot;</span><br><span class="line">           &gt;</span><br><span class="line">  &lt;i class&#x3D;&quot;el-icon-upload&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;&#x2F;em&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;el-upload__tip&quot; slot&#x3D;&quot;tip&quot; style&#x3D;&quot;color&#x3D;#4073ff&quot;&gt;只能上传excel文件，且不超过10MB&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;el-upload&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中对应的一些差异的js方法代码如下</span></span><br><span class="line"><span class="function"><span class="title">handleChange</span>(<span class="params">file, fileList</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.fileList = fileList;</span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此处使用 JSON.parse(err.message) 代替 JSON.stringify(err) </span></span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.parse(err.message)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg.err_msg)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>虽然 <code>Element-ui</code> 上的组件很丰富， 但是对于<strong>一个测试</strong>来说，有时候还是有些难以理解😭😭。</p><h4 id="问题1：action参数的使用问题。"><a href="#问题1：action参数的使用问题。" class="headerlink" title="问题1：action参数的使用问题。"></a>问题1：action参数的使用问题。</h4><p>在源码中 <code>action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;</code> 的使用，以及下面参数<code>action</code> 解释为：<strong>必选参数，上传的地址</strong>。这个地方就误以为只能使用 <code>URL</code> 格式，实际也可以 <code>:action</code> 直接对应后端的上传文件的API接口即可 。</p><p>解决方案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将源码中的 action=&quot;https://jsonplaceholder.typicode.com/posts/&quot; ==&gt; :action=&quot;doUpload&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">...</span><br><span class="line">  data() </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      doUpload:<span class="string">&#x27;/api/upload_excel_file&#x27;</span>,<span class="comment">// 对应后端的上传文件接口</span></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题2：需要传输指定的参数给后端接口。"><a href="#问题2：需要传输指定的参数给后端接口。" class="headerlink" title="问题2：需要传输指定的参数给后端接口。"></a>问题2：需要传输指定的参数给后端接口。</h4><p>解决方案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue 中上传组件新增 :data参数为指定需要传入给后端接口的data</span></span><br><span class="line">&lt;el-upload</span><br><span class="line">...</span><br><span class="line">  :action=<span class="string">&quot;doUpload&quot;</span></span><br><span class="line">  :data=<span class="string">&quot;specialData&quot;</span></span><br><span class="line">...</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">...</span><br><span class="line">  data() </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      doUpload:<span class="string">&#x27;/api/upload_excel_file&#x27;</span>,<span class="comment">// 对应后端的上传文件接口</span></span><br><span class="line">      specialData: &#123;</span><br><span class="line">        name: <span class="string">&quot;111&quot;</span>,<span class="comment">// 后端接口就能接收到该变量</span></span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体效果如下：</p><img src="https://i.loli.net/2021/02/26/7Jj2FYUrWc8n4L3.png" alt="upload-data.png" style="zoom:80%;" /><h4 id="问题3-针对于上传失败后，解析返回的错误信息不全。"><a href="#问题3-针对于上传失败后，解析返回的错误信息不全。" class="headerlink" title="问题3: 针对于上传失败后，解析返回的错误信息不全。"></a>问题3: 针对于上传失败后，解析返回的错误信息不全。</h4><p>具体现象如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.stringify(err)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">&#123;<span class="string">&quot;status&quot;</span>:<span class="number">400</span>,<span class="string">&quot;method&quot;</span>:<span class="string">&quot;post&quot;</span>,<span class="string">&quot;url&quot;</span>:<span class="string">&quot;/api/upload_excel_file&quot;</span>&#125; </span><br><span class="line"><span class="comment">// 实际err的信息应该如下（需要解析到里面的err_msg）：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code> JSON.stringify(err)</code> 去解析err 发现打印的数据没有想要的错误信息， 通过控制台调试的时候发现完整的err应该为如下格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>: &#123;</span><br><span class="line">  method: <span class="string">&quot;post&quot;</span></span><br><span class="line">  status: <span class="number">400</span></span><br><span class="line">  url: <span class="string">&quot;/api/upload_excel_file&quot;</span></span><br><span class="line">  message: <span class="string">&quot;&#123;↵  &quot;</span>code<span class="string">&quot;: 400, ↵  &quot;</span>data<span class="string">&quot;: &#123;&#125;, ↵  &quot;</span>err_msg<span class="string">&quot;: &quot;</span>\u5df2\u5b58\u5728\u76f8\u540c\u540d\u79f0\u7684\u6587\u4ef6<span class="string">&quot;↵&#125;↵&quot;</span></span><br><span class="line">  stack: <span class="string">&quot;Error: &#123;↵  &quot;</span>code<span class="string">&quot;: 400, ↵  &quot;</span>data<span class="string">&quot;: &#123;&#125;, </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>所以是 <code>JSON.stringify</code> 在转义的过程中少了一些字段（具体原因：<strong>JSON.stringify()只能序列化对象的可枚举的自有属性</strong>），此处解决办法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此处使用 JSON.parse(err.message) 代替 JSON.stringify(err) </span></span><br><span class="line">  <span class="keyword">var</span> err_msg = <span class="built_in">JSON</span>.parse(err.message)</span><br><span class="line">  <span class="built_in">console</span>.log(err_msg.err_msg)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，基本已经满足了最初预定的需求。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://segmentfault.com/q/1010000019086550">Element upload组件如何获取它的on-error事件的报错信息</a><br><a href="https://segmentfault.com/a/1190000013796215">Element el-upload 上传组件详解</a><br><a href="https://element.eleme.cn/#/zh-CN/component/upload#tuo-zhuai-shang-chuan">Element 官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Element UI </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探Sqlmap（一）</title>
      <link href="posts/e96496d4/"/>
      <url>posts/e96496d4/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    基于<a href="https://beanskingdom.top/posts/6ad48805/#more">业务存在 Sql 注入危险</a> 的现状，开始研究相关工具的使用一一 Sqlmap。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    <code>Sqlmap</code> 是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。（<a href="https://github.com/sqlmapproject/sqlmap">Sqlmap源码</a>）</p><p>​    本文会简单描述下 <code>Sqlmap</code> 的使用方式，然后详细介绍下 <code>SqlmapAPI</code> 的大致原理。</p><a id="more"></a><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="一、-命令行方式"><a href="#一、-命令行方式" class="headerlink" title="一、 命令行方式"></a>一、 命令行方式</h4><p><strong>优点：</strong> 上手快，命令行输入/输出容易理解；问题定位方便。</p><p>​    对于<strong>新手初次使用该工具</strong>时候，建议<strong>使用命令行模式先将整个流程跑通</strong>（如参考：<a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a>，很详细的介绍了从Sql注入到破解数据库信息的整个过程），想了解更多命令行参数可以阅读源码目录 <code>lib/parse/cmdline</code> 文件获取更多参数的含义。</p><p><strong>大致的命令行格式如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对参数是直接拼接在链接后方的命令行</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;http://ip:port/user/login?username=foo&amp;passwd=bar&quot;</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;http://ip:port/user/login?username=foo&amp;passwd=bar&quot;</span> --batch --dbs</span><br></pre></td></tr></table></figure><p><strong>我常用的命令行参数有：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--dbms=<span class="string">&#x27;MySQL&#x27;</span><span class="comment"># 指定后台扫描数据库类型为 MYSQL</span></span><br><span class="line">--risk 3<span class="comment"># 执行中的风险系数，1~3，级别越高，可能会使用&#x27;or&#x27;等等语句，默认1</span></span><br><span class="line">--level 3<span class="comment"># 级别越高，发送的请求(payload)越多，默认1</span></span><br><span class="line">--random-agent<span class="comment"># Use randomly selected HTTP User-Agent header value</span></span><br><span class="line">--keep-alive<span class="comment"># Use persistent HTTP(s) connections</span></span><br><span class="line">--batch<span class="comment"># 自动选择默认的值，否则需要手动选择</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>注意：</strong> <strong>针对实践中的一些特定的场景，如加 <code>headers</code> 或对 <code>POST</code> 方法注入的命令行如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果需要自定义header，使用headers参数，注意：多个header之间用\n间隔</span></span><br><span class="line"><span class="comment"># 具体的data参数需要进行URL编码。</span></span><br><span class="line">python3 sqlmap.py -u <span class="string">&quot;https://xxx/test/user&quot;</span> --headers=<span class="string">&quot;xxx: xxx\nxbbb: 4\nxcc: 111\nx-token: xxx&quot;</span> --data=<span class="string">&#x27;data=%7B%22id%22%3A%22111%22%2C%22new%22%3A%229%22%2C%20%22old%22%3A%221%22%7D&#x27;</span> --dbms=<span class="string">&#x27;MySQL &#x27;</span> --random-agent --batch </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如上请求的POST参数具体格式如下</span></span><br><span class="line">data=&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;111&quot;</span>,<span class="string">&quot;new&quot;</span>:<span class="string">&quot;9&quot;</span>, <span class="string">&quot;old&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line"><span class="comment"># 在注入的时候，要对data中所有的字段进行注入，则需要将上述data修改如下，在每个字段的value值后新增一个*号：</span></span><br><span class="line">data=&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;111*&quot;</span>,<span class="string">&quot;new&quot;</span>:<span class="string">&quot;9*&quot;</span>, <span class="string">&quot;old&quot;</span>:<span class="string">&quot;1*&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意</strong>⚠️： 对于data里面需要注入的参数带 * 号时候，转义后仍然需要是 * 号，不能直接转义，否则就导致最终仅仅是对 data最外层这个data进行了注入！！！</font></p><p><strong>缺点：</strong></p><ul><li>由于Sqlmap每检测一个站点都需要开启一个新的命令行窗口或者结束掉上一个检测任务。虽然 -m 参数可以批量扫描URL，但是模式也是一个结束扫描后才开始另一个扫描任务，执行效率较慢；</li><li>对于想获取历史任务的日志和结果操作不友好。</li></ul><p><strong>实际使用场景：我大多数时候是用该方式进行参数调试。</strong></p><h4 id="二、API请求"><a href="#二、API请求" class="headerlink" title="二、API请求"></a>二、API请求</h4><p><strong>优点：</strong> Sqlmap封装了较多的API接口，更方便操作扫描任务。</p><ul><li><p>通过 API接口下发扫描任务，无需每次执行扫描新开一个命令行窗口，通过Http接口即可执行扫描任务；</p></li><li><p>可通过 API接口获取历史执行结果以及日志进行聚合和分析。</p></li></ul><p>具体如何使用 SqlmapAPI不具体描述，可参考：<a href="https://paper.seebug.org/940/">细说Sqlmap</a>，比较详细的说明了 SqlmapAPI的使用。</p><h3 id="SqlmapAPI-原理"><a href="#SqlmapAPI-原理" class="headerlink" title="SqlmapAPI 原理"></a>SqlmapAPI 原理</h3><h4 id="SqlmapAPI-服务器启动"><a href="#SqlmapAPI-服务器启动" class="headerlink" title="SqlmapAPI 服务器启动"></a>SqlmapAPI 服务器启动</h4><p>SqlmapAPI的服务器启动逻辑还是很简单，下图为整个 <code>sqlmapapi.py</code> 脚本服务器启动流程。</p><img src="https://i.loli.net/2021/02/16/WJVaUkBYhstGRHv.png" alt="sqlmapAPI.png" style="zoom:45%;" /><h4 id="api-py"><a href="#api-py" class="headerlink" title="api.py"></a>api.py</h4><p>SqlmapAPI使用的是 <a href="https://docs.python.org/zh-cn/3/library/sqlite3.html">sqlite3</a> 数据库。在 <code>server()</code> 方法中主要是进行本地数据库的路径创建、连接以及创建必须的表结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个随机地址, 用于存放数据库文件</span></span><br><span class="line">_, Database.filepath = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.IPC, text=<span class="literal">False</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize IPC database</span></span><br><span class="line">DataStore.current_db = Database()</span><br><span class="line">DataStore.current_db.connect()</span><br><span class="line">DataStore.current_db.init()</span><br></pre></td></tr></table></figure><p>使用API模式进行sql注入测试时候，主要使用如下几个API接口（具体如何调用可参考：<a href="https://paper.seebug.org/940/">细说Sqlmap</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@get(<span class="string">&quot;/task/new&quot;</span>)<span class="comment"># 创建一个新的扫描任务</span></span><br><span class="line">@post(<span class="string">&quot;/scan/&lt;taskid&gt;/start&quot;</span>)<span class="comment"># 指定任务进行扫描</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/status&quot;</span>)<span class="comment"># 查看指定任务的状态</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/data&quot;</span>)<span class="comment"># 查看指定任务的执行结果</span></span><br><span class="line">@get(<span class="string">&quot;/scan/&lt;taskid&gt;/log&quot;</span>)<span class="comment"># 查看指定任务的扫描执行日志</span></span><br></pre></td></tr></table></figure><h4 id="Task执行原理"><a href="#Task执行原理" class="headerlink" title="Task执行原理"></a>Task执行原理</h4><p>此处仅介绍 <code>/scan/&lt;taskid&gt;/start</code>，主要通过 <code>DataStore.tasks[taskid].engine_start()</code> 进行执行指定任务执行扫描。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">engine_start</span>(<span class="params">self</span>):</span></span><br><span class="line">  handle, configFile = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.CONFIG, text=<span class="literal">True</span>)</span><br><span class="line">  os.close(handle)</span><br><span class="line">  saveConfig(self.options, configFile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&quot;sqlmap.py&quot;</span>):</span><br><span class="line">  self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">elif</span> os.path.exists(os.path.join(os.getcwd(), <span class="string">&quot;sqlmap.py&quot;</span>)):</span><br><span class="line">    self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, cwd=os.getcwd(), close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">elif</span> os.path.exists(os.path.join(os.path.abspath(os.path.dirname(sys.argv[<span class="number">0</span>])), <span class="string">&quot;sqlmap.py&quot;</span>)):</span><br><span class="line">    self.process = Popen([sys.executable <span class="keyword">or</span> <span class="string">&quot;python&quot;</span>, <span class="string">&quot;sqlmap.py&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, cwd=os.path.join(os.path.abspath(os.path.dirname(sys.argv[<span class="number">0</span>]))), close_fds=<span class="keyword">not</span> IS_WIN)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    self.process = Popen([<span class="string">&quot;sqlmap&quot;</span>, <span class="string">&quot;--api&quot;</span>, <span class="string">&quot;-c&quot;</span>, configFile], shell=<span class="literal">False</span>, close_fds=<span class="keyword">not</span> IS_WIN)</span><br></pre></td></tr></table></figure><p>从上面的代码来看，最终还是使用的 <code>sqlmap.py</code> 脚本来进行的任务扫描，也可以通过打印出源代码中 <code>configFile</code>  的路径，来查看每次任务的配置参数是什么。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，SqlmapAPI就介绍到此，可以看出来该脚本主要是启动一个本地数据库以及Web后台，来记录所有的任务相关信息。下一次将再继续分析 <code>sqlmap.py</code> 脚本中是如何进行sql注入的测试。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://octobug.gitbooks.io/sqlmap-wiki-zhcn/content/">sqlmap中文介绍</a><br><a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a><br><a href="https://github.com/sqlmapproject/sqlmap">Sqlmap源码</a><br><a href="https://www.freebuf.com/sectool/164608.html">Sqlmap超详细攻略</a><br><a href="https://paper.seebug.org/940/">细说Sqlmap</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全测试 </tag>
            
            <tag> Sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探安全测试</title>
      <link href="posts/6ad48805/"/>
      <url>posts/6ad48805/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    某天，A：你们Web后台存在安全问题，部分接口<font color=red><strong>存在SQL注入的问题</strong></font>。</p><p>​    B：…</p><p>​    B To C：接口存在SQL注入的问题，你去调研下Sqlmap。</p><p>​    C：… emm (⊙＿⊙)。</p><a id="more"></a><h3 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h3><ul><li>什么是安全问题？应用软件中又存在哪些方面的安全问题？</li><li>什么是安全测试？</li><li>常见的安全性缺陷和漏洞有哪些？</li><li>Sql注入，用于进行Sql注入的工具有哪些？</li></ul><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>​    现实生活中安全相关话题无处不在，如消防安全、卫生安全、人身安全等等，如：<strong>小区楼道中贴着一些禁止电动车在楼道中充电</strong>，因为这会存在着引发火灾的安全问题（严重的情况甚至影响到生命危险）。</p><p>​    那么应用软件中也存在安全问题，情况严重时候不仅会造成经济损失，还可能由于大量用户信息被泄漏而导致整个公司崩溃。常见的几种安全问题如下：</p><ul><li><strong>信息安全问题</strong>：如淘宝、京东中，用户一般都绑定了身份证、银行卡、手机号、家庭住址等个人隐私信息，如果这些信息泄漏给一些不法分子后，就会对一些指定用户进行电信诈骗；</li><li><strong>财产安全问题</strong>：如很多钓鱼网站，都是通过短信、微信、网页链接等方式模拟正规网页，骗取用户在上面进行操作，导致银行卡密码泄漏而造成财产损失；</li><li><strong>权限安全问题</strong>：由于权限控制不得当，非公司内部管理员也能通过某些方式对公司的私密信息进行操作，最终导致整个公司隐私泄漏或者信息错误。</li></ul><h4 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h4><p>​    个人理解安全测试应该是 <strong>一个识别应用程序潜在的安全性缺陷的过程</strong>，如：保证用户对数据或业务功能的访问，在预期的安全性情况下，操作者只能<strong>访问应用程序的特定功能、有限的数据</strong>等。</p><p>其它参考：<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95">百度–安全测试</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95">维基–渗透测试</a></p><p>​    常用的安全测试手段有：</p><ul><li>静态的代码安全测试；</li><li>动态的渗透测试；</li><li>程序数据扫描。</li></ul><h4 id="常见的软件安全性缺陷和漏洞有哪些"><a href="#常见的软件安全性缺陷和漏洞有哪些" class="headerlink" title="常见的软件安全性缺陷和漏洞有哪些"></a>常见的软件安全性缺陷和漏洞有哪些</h4><p>由于篇幅有限，暂仅对此次存在 <code>Sql注入</code> 的安全问题详细介绍。</p><ul><li><a href="https://baike.baidu.com/item/SQL%E6%B3%A8%E5%85%A5">SQL注入</a></li><li><a href="https://www.jianshu.com/p/9fc25e661ab9">XSS注入</a></li><li><a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E">远程代码执行</a></li><li><a href="https://www.netinbag.com/cn/internet/what-is-parameter-tampering.html">参数篡改</a></li><li><a href="https://www.anquanke.com/post/id/217290">弱口令</a></li><li>…</li></ul><h4 id="Sql注入"><a href="#Sql注入" class="headerlink" title="Sql注入"></a>Sql注入</h4><p>​    在没有深入之前，对于Sql注入的理解是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，然后获得该接口的返回或者绕过授权。对于存在Sql注入的威胁也仅仅是绕过登录或者获取某些普通数据。</p><p>​    然而通过资料的查询以及自身的Sqlmap实践后，才感觉一阵后怕，比较常见的威胁如下：</p><ul><li>猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。（<strong>如果存在Sql注入时，在没有特殊的安全措施下，可以理解数据库里面的所有信息都可以被获取到</strong>）</li><li>绕过认证，列如绕过验证登录网站后台。</li></ul><p>​    具体如何使用Sqlmap达到上面的效果这里就不细说了，网上这块教程比较多（如：<a href="https://www.cnblogs.com/cc11001100/p/7634049.html">Sql注入获取数据库信息</a>）。</p><h4 id="Sql注入的步骤"><a href="#Sql注入的步骤" class="headerlink" title="Sql注入的步骤"></a>Sql注入的步骤</h4><ol><li><p><strong>SQL注入点探测</strong>。</p><p>探测SQL注入点是关键的一步，通过适当的分析应用程序，可以判断什么地方存在SQL注入点。通常只要带有输入提交的动态网页，并且动态网页访问数据库，就可能存在SQL注入漏洞。如果程序员信息安全意识不强，<font color=red><strong>采用动态构造SQL语句访问数据库，并且对用户的输入未进行有效性验证，则存在SQL注入漏洞的可能性很大。</strong></font>一般通过页面的报错信息来确定是否存在SQL注入漏洞。</p></li><li><p><strong>收集后台数据库信息。</strong></p><p>不同数据库的注入方法、函数都不尽相同，因此在注入之前，我们先要判断一下数据库的类型。判断数据库类型的方法很多，可以输入特殊字符，如单引号，让程序返回错误信息，我们根据错误信息提示进行判断；还可以使用特定函数来判断，比如输入“1 and version（）&gt;0”，程序返回正常，说明 <code>version()</code> 函数被数据库识别并执行，而 <code>version()</code> 函数是 <code>MySQL</code> 特有的函数，因此可以推断后台数据库为MySQL。</p></li><li><p><strong>猜解用户名和密码。</strong></p><p>数据库中的表和字段命名一般都是有规律的。通过构造特殊SQL语句在数据库中依次猜解出表名、字段名、字段数、用户名和密码。 </p></li><li><p><strong>查找Web后台管理入口。</strong></p><p>WEB后台管理通常不对普通用户开放，要找到后台管理的登录网址，可以利用Web目录扫描工具（如：wwwscan、AWVS）快速搜索到可能的登录地址，然后逐一尝试，便可以找到后台管理平台的登录网址。</p></li><li><p><strong>入侵和破坏。</strong></p><p>一般后台管理具有较高权限和较多的功能，使用前面已破译的用户名、密码成功登录后台管理平台后，就可以任意进行破坏，比如上传<a href="https://baike.baidu.com/item/%E6%9C%A8%E9%A9%AC/530">木马</a>、篡改网页、修改和窃取信息等，还可以进一步提权，入侵Web服务器和数据库服务器。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    概念相关就介绍到此，下一篇将会具体介绍如何通过工具来进行相关Sql注入的测试一一 <code>Sqlmap</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> 安全测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全测试 </tag>
            
            <tag> Sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019~2020年回顾</title>
      <link href="posts/6a64e1dd/"/>
      <url>posts/6a64e1dd/</url>
      
        <content type="html"><![CDATA[<h3 id="感慨（吐槽自己…）"><a href="#感慨（吐槽自己…）" class="headerlink" title="感慨（吐槽自己…）"></a>感慨（吐槽自己…）</h3><p>​    瞬间就到了2021年了。。。依稀还记得2019年立的flags(╯▔︵▔)╯，重度拖延+健忘+各种琐事总能把一些想法扼杀在摇篮中。</p><p>比如：大一点方向就是全世界/全国旅游； 小一点方向就是学习潜水、滑雪等…</p><h3 id="庆幸"><a href="#庆幸" class="headerlink" title="庆幸"></a>庆幸</h3><p>​    让我感到欣慰的是，在2020年中下旬的开始，我的思维有了一些转变。我开始变得爱看书了（各种方面的都有，如：理财、PS、算法、逻辑思维等），这个也要归功于我主动看的第一本书籍 <code>《小强升职记》</code> （通俗易懂 + 符合现实），让我感同身受的同时，思维上也有了一个质的改变。</p><a id="more"></a><p>​    我完成了很多原来不可能会做的事情（容易量化的如下，实际还有更多就不一一列举了）：</p><ul><li>我主动看完了一本书；</li><li>我坚持了看书2个月；</li></ul><p>​    虽然按照书上的一些方法不那么有效（<em>并不是每一本书都能帮你解决什么问题，它们仅仅是一个个你的起点而已</em>），但通过不断的实践、修改、实践，我开始慢慢掌握了一个属于我自己的节奏，并且更加积极向上，我知道 2021 年会更加精彩。那些天马星空的想法也变的不那么遥不可及。</p><p>​    至此我也开始明白了一句话 一一 <code>书中自有黄金屋，书中自有颜如玉。</code></p><h3 id="2019～2020年的生活"><a href="#2019～2020年的生活" class="headerlink" title="2019～2020年的生活"></a>2019～2020年的生活</h3><blockquote><p>不如意事常八九，可与语人无二三。</p></blockquote><p>​    这一年半多的时间里，磕磕碰碰的事情挺多，过程中也一度沮丧或者低落过。特别是由于平时缺乏锻炼，感觉身体上也开始各种小毛病。（<font color=red><em>敲黑板！！！身体是革命的本钱，早期一定要注意</em></font>）。</p><p>​    刚好看到2018年时去马来西亚沙巴的一次团建（<em>早晨吹着海风躺在椰子树阴下的躺椅上，感叹着生活如此多娇</em>）。</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/9S43eH5lOTtANUZ.jpg"></center><h3 id="印象比较深刻的几个地方"><a href="#印象比较深刻的几个地方" class="headerlink" title="印象比较深刻的几个地方"></a>印象比较深刻的几个地方</h3><p>在面对这些大自然的美景时，整个人的心境都得到了升华，感觉什么烦恼都在那一刻抛到九霄云外。</p><h4 id="仙本那"><a href="#仙本那" class="headerlink" title="仙本那"></a>仙本那</h4><p>印象最深刻的是当时参观的<strong>巴瑶族人</strong>一一地球上最后一个海洋游牧民族，”<strong>一生</strong>“ 都在水上的民族。</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/QvZG5ALmpbjDqOR.jpg"></center><h4 id="塞班岛"><a href="#塞班岛" class="headerlink" title="塞班岛"></a>塞班岛</h4><p>天空和海水的搭配真的是很美（海天一色）！！！无需任何滤镜，感觉如画中一般。</p><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/XFHWT2khB8i4KtQ.jpg"></center><center class="half">    <img title="life_photo_1.png" src="https://i.loli.net/2020/08/16/Jzw5jZWachnstgv.jpg"></center><h4 id="雁荡山"><a href="#雁荡山" class="headerlink" title="雁荡山"></a>雁荡山</h4><p>云海翻腾，山海共生。<br><img src="https://i.loli.net/2020/08/16/Dv1gQmIM3cpCTkP.jpg" alt="life_photo_5.png" style="zoom:60%;" /></p><img src="https://i.loli.net/2020/08/16/ePwQyk1zmsI9glp.jpg" alt="life_photo_6.png" style="zoom:60%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    <strong>其实生活也就那样一一酸甜苦辣</strong>。（乍得一看有点像是一篇游记(╯▔▽▔)╯ ）</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT + Valine躺坑之路</title>
      <link href="posts/a21b8f58/"/>
      <url>posts/a21b8f58/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    写了一段时间博客后，发现别人的文章有浏览次数以及评论功能★~★，这也某种程度上提高写 <em>Blog</em> 的动力，那我也来弄一个哈哈哈。。。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>​    然而，事实总是那么折磨人。。。使用的是 <em>nexT</em> 主题的 <em>v8.2.1</em> 版本，按照网上的<a href="https://qianfanguojin.github.io/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">教程</a>后一直没有达到最终的效果😭😭。</p><a id="more"></a><h4 id="问题1-使用-Valine-插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。"><a href="#问题1-使用-Valine-插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。" class="headerlink" title="问题1: 使用 Valine 插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。"></a>问题1: 使用 <em>Valine</em> 插件后，在页面上并没有显示具体的评论数量以及文章的浏览次数。</h4><p>具体原因：因为 <code>v8.2.1 版本已经将 Valine 功能去除掉了</code>。（详情见<a href="https://github.com/next-theme/hexo-theme-next/issues/188">官网解释</a>）也尝试了官网中的解决办法以及各种网上的方法，但是仍然无效。（瞎折腾了3个小时都没结果。。。气到内伤😭😭）</p><p>那就将版本降低到能使用的 <em>Valine</em> 的 <em>NexT</em> 版本呢？（如降低到<a href="https://github.com/theme-next/hexo-theme-next/releases/tag/v7.8.0">7.8.0</a>版本呢？？）<code>降低版本到7.8.0后，问题就解决了</code>。</p><h4 id="问题2-降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。"><a href="#问题2-降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。" class="headerlink" title="问题2: 降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。"></a>问题2: 降低版本后，发现原来文章中中文导航又不能用了，英文的就没有问题。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击中文标题导航栏时候，console控制台中报错，并且页面上没有跳转到对应的标题位置。</span></span><br><span class="line">Cannot read property <span class="string">&#x27;getBoundingClientRect&#x27;</span> <span class="keyword">of</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>实际原因是:  <code>themes/next/source/js/utils.js</code> 中的代码存在遗漏，没有对中文进行URL解码。具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... <span class="comment">// 其他多余代码省略</span></span><br><span class="line"><span class="comment">// 在这个地方获取 event 的属性时候，中文的会被自动转成URI编码格式</span></span><br><span class="line"><span class="comment">// href=&quot;#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4&quot; </span></span><br><span class="line"><span class="comment">// 但文章中的Id仍然是中文的 &lt;h3 id=&quot;操作步骤&quot;&gt;, 所以导致此处的target为null。</span></span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(event.currentTarget.getAttribute(<span class="string">&#x27;href&#x27;</span>).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br><span class="line">... <span class="comment">// 其他多余代码省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法：将上述代码替换如下代码即可。</span></span><br><span class="line"><span class="keyword">var</span> str_id = <span class="built_in">decodeURI</span>(event.currentTarget.getAttribute(<span class="string">&#x27;href&#x27;</span>).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(str_id);</span><br><span class="line"><span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br></pre></td></tr></table></figure><p>至此， 终于得到了自己想要的效果。。。（＋﹏＋）（＋﹏＋）</p><img src="https://i.loli.net/2021/02/09/vLhxcG8jZfyk46u.png" alt="valine_result.png" style="zoom:50%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    很多时候遇到的问题，通过网上不一定能适用自己当前的场景，并不一定是别人的方式有问题。。。很可能是你的环境和别人的就不一样，所以<code>同样的操作不一定能解决同样现象的问题</code>。。。还是需要多排查定位看看主要的问题点在哪。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
            <tag> Valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Py-spy解决Python程序Hang住问题</title>
      <link href="posts/cb61081b/"/>
      <url>posts/cb61081b/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    已经集成的接口自动化测试 Job 在周期性定时运行的时候，会很小概率出现一直卡在那里，原本应该3min就执行完成的任务，偶尔过了半个小时还没结束。（(￣３￣)直觉告诉我这个地方肯定有问题。。。</p><p>​    但由于复现的概率较小，一个月可能出现一次，所以开始并没有什么太大的线索（仅靠一些猜测并不切实际）。</p><p>​    终于！！！在某一个阳光明媚的大好日子，<strong>它重现了</strong>。</p><a id="more"></a><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ol><li><p>赶紧先登录到服务器上看看进程情况，发现此时存在脚本发起的2个 Worker CPU占用100%（由于用的 <code>Pytest + Pytest-xdist</code>  分布式插件执行用例），当时第一反应是死循环了？？</p><img src="https://i.loli.net/2021/01/22/AVhg7RGzYIfuWtN.png" alt="process_hang_1.png" style="zoom:50%;" /></li><li><p>通过<strong>perf</strong> 、<strong>ps</strong>或者 <strong>pstack</strong> 打印对应的pid， 看到的结果并没有什么太大用，反而<strong>误导我以为是代码里面的一个文件锁导致该问题</strong>。</p><img src="https://i.loli.net/2021/01/22/E1Yq9cjRo2GOx5e.png" alt="process_hang_2.png" style="zoom:50%;" /></li><li><p>网上查询了一通后，发现一个神奇的工具一一 <a href="https://www.zhihu.com/question/310832912">py-spy</a> （更多使用方法见 <a href="https://pypi.org/project/py-spy/">官网</a>）</p><p>安装后使用命令 ：选定一个异常的进程，执行命令： <code>py-spy  top --pid 19785</code> 打印结果如下，很明显看出来当前Cpu都卡在 <code>check_retry_status</code> 方法上面。</p><img src="https://i.loli.net/2021/01/22/CuRZJnsj13eTXoQ.png" alt="process_hang_3.png" style="zoom:50%;" /></li><li><p>查看该代码，发现该方法中存在一个while循环，并且很凑巧的是。。。╮(╯3╰)╭ 里面<font color=red><strong>没有兜底</strong></font>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体代码如下，过于相信传进来的 retry_flag 一定是1/2， 如果出现不是这两个值的时候，此时这个方法则进入了死循环。。。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_retry_status</span>(<span class="params">cls, uid, atk, order_id, retry_flag, devuuid</span>):</span></span><br><span class="line">    max_count = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> max_count &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> retry_flag == <span class="number">2</span>:</span><br><span class="line">        retry_flag = functionA(xxx, ...)</span><br><span class="line">        max_count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> retry_flag == <span class="number">1</span>:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;验证充值订单失败&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>到这个地方，就很明显定位到了问题，在此处加上兜底并且加上对应日志记录functionA（<strong>第三方依赖</strong>）到底返回的是什么。（ 因为首次传入的 retry_flag 也是来自于functionA）</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    写代码要谨慎。。。特别是结果来自第三方依赖的时候。。。<strong>一定要进行兜底！！！</strong></p><p>​    （emm… 兜一下总比不兜强）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python Plugin </tag>
            
            <tag> py-spy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python调用gRPC接口</title>
      <link href="posts/2a44a0fd/"/>
      <url>posts/2a44a0fd/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    最近几个项目都是用的go语言编写的，使用的是 gRPC接口，是没有对外暴露http接口。但在部分场景下，由于可测性的需要必须直接调用 gRPC接口，达到数据的构造，所以需要通过 <code>Python</code> 代码完成调用服务器上的 gRPC接口 。</p><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><p>​    由于网上相关最简单的demo已经是烂了一地。。。我这边就不再去重复写一段demo了（可参考当时我看的一篇<a href="https://cloud.tencent.com/developer/article/1557398">Blog</a>，或自行搜索相关前置准备）。</p><p>​    主要记录在实际过程中运用遇到的一些问题，希望能给大家一些帮助。</p><a id="more"></a><h4 id="步骤一：在执行转化脚本命令时候报错，具体信息如下："><a href="#步骤一：在执行转化脚本命令时候报错，具体信息如下：" class="headerlink" title="步骤一：在执行转化脚本命令时候报错，具体信息如下："></a>步骤一：在执行转化脚本命令时候报错，具体信息如下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. ./user.proto</span><br><span class="line"></span><br><span class="line">github.com/gogo/protobuf/gogoproto/gogo.proto: File not found.</span><br><span class="line">base.proto: File not found.</span><br><span class="line">user.proto:7:1: Import <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span> was not found or had errors.</span><br><span class="line">user.proto:8:1: Import <span class="string">&quot;base.proto&quot;</span> was not found or had errors.</span><br><span class="line">user.proto:47:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:59:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:86:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:239:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br><span class="line">user.proto:258:5: <span class="string">&quot;NullInt64&quot;</span> is not defined.</span><br></pre></td></tr></table></figure><p>针对报错问题一个个分析。</p><h5 id="问题1-github-com-gogo-protobuf-gogoproto-gogo-proto-File-not-found。"><a href="#问题1-github-com-gogo-protobuf-gogoproto-gogo-proto-File-not-found。" class="headerlink" title="问题1: github.com/gogo/protobuf/gogoproto/gogo.proto: File not found。"></a>问题1: github.com/gogo/protobuf/gogoproto/gogo.proto: File not found。</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于转化的脚本中直接以如下方法引用的 gogo.proto 文件，但在转换的时候肯定是找不到的</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span></span><br></pre></td></tr></table></figure><p>解决办法：</p><ol><li><p>将 <a href="https://github.com/gogo/protobuf/blob/master/gogoproto/gogo.proto">gogo.proto</a> 文件下载到本地，放到与需要转换的 user.proto 文件同级目录下;</p></li><li><p>修改 user.proto 的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将如下代码修改成 import &quot;gogo.proto&quot;</span></span><br><span class="line">import <span class="string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="问题2-base-proto-File-not-found。"><a href="#问题2-base-proto-File-not-found。" class="headerlink" title="问题2: base.proto: File not found。"></a>问题2: base.proto: File not found。</h5><p>解决方式同问题1，实际就将依赖的这个 base.proto 文件放到与需要转换的 user.proto 文件同级目录下即可。（<code>由于我的 base.proto 文件中也同问题1中一样引用了 gogo.proto，所以都需要重复问题1的步骤2</code>）</p><p>经过上面操作，终于将 user.proto 文件转成了对应的python脚本，具体样式如下。</p><img src="https://i.loli.net/2021/02/07/B8rjYhz1ZksDfiq.png" alt="python_convert_grpc.png" style="zoom:40%;" /><p>但你以为这就完事了？？(╯▔︹▔)╯ ， <code>Too young too simple</code></p><h4 id="步骤二：调用转换成python脚本的接口。"><a href="#步骤二：调用转换成python脚本的接口。" class="headerlink" title="步骤二：调用转换成python脚本的接口。"></a>步骤二：调用转换成python脚本的接口。</h4><p><em>注：由于无需本地启动一个服务端，所以可以简单点只写一个调用端即可（具体方式类似 <code>BloomRPC</code>，通过  <code>kubectl</code> 代理到远端的 <code>grpc</code>服务端， 具体原理可自行搜索）</em></p><p>在写客户端代码之前，就还存在一个隐藏问题。</p><h5 id="问题3-实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成-python脚本（根据个人需要进行转换）。"><a href="#问题3-实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成-python脚本（根据个人需要进行转换）。" class="headerlink" title="问题3: 实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成 python脚本（根据个人需要进行转换）。"></a>问题3: 实际上如果在写客户端代码时候需要引用的其它的proto文件中的方法，则需要其它引用的文件也转成 python脚本（根据个人需要进行转换）。</h5><p>客户端代码大致如下（<em>我编写的demo中则无需转换其它文件</em>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> user_pb2_grpc, user_pb2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">userService</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_mobile_by_id</span>(<span class="params">cls</span>):</span></span><br><span class="line">      <span class="comment"># 连接上本地的gRPC代理服务端, 端口为kubectl本地代理的端口</span></span><br><span class="line">        channel = grpc.insecure_channel(<span class="string">&#x27;localhost:6666&#x27;</span>) </span><br><span class="line">        <span class="comment"># 根据对应服务初始化渠道</span></span><br><span class="line">        test_stub = user_pb2_grpc.UserStub(channel)          </span><br><span class="line">        user_id = <span class="number">1234</span></span><br><span class="line">        <span class="comment"># 根据具体的 Request 定义来传入参数, 否则会报错</span></span><br><span class="line">        <span class="keyword">return</span> test_stub.GetXxxById(user_pb2.GetXxxByIdRequest(userId=user_id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(userService.get_mobile_by_id())</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 执行效果如下</span></span><br><span class="line">(ENV) ➜  demo_python_convert_grpc python user_client.py</span><br><span class="line">mobileId: <span class="string">&quot;11166668888&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数按照 user_pb2.py中方法Request定义的FieldDescriptor中具体的name来传入</span></span><br><span class="line">fields=[</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;userId&#x27;</span>, full_name</span><br><span class="line">      ...]</span><br></pre></td></tr></table></figure><p>​    至此，整体调用 <code>gRPC接口</code> 的流程算是跑通了，后续就看各自业务需求来定制化了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    最后吐槽下，很多时候准备做一件事的时候，发现网上教程挺多的，但是也会发现那些 “教程” 可能<strong>千篇一律</strong>。。。有些甚至一摸一样╮(╯Д╰)╭ 。。。当你真正按照这些 “教程” 来操作的时候又会发现可能不那么简单，所以说：<font color=blue><strong>实践是检验真理的唯一标准</strong> ！！！</font></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gRPC接口 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Set命令</title>
      <link href="posts/cf736c07/"/>
      <url>posts/cf736c07/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    有时候在执行shell脚本的时候，在运行/调试的过程中会有些报错看起来不是太明显，那如何高效的调试自己编写的shell脚本呢？？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>​    网上有一些解决方案，但是尝试了下后觉得使用 shell 中的 <strong>set</strong> 命令来解决更加方便和快捷。下面来看看 <strong>set</strong> 命令到底能够有哪些应用场景。</p><a id="more"></a><h4 id="（1）set-u"><a href="#（1）set-u" class="headerlink" title="（1）set -u"></a>（1）set -u</h4><p>​    执行脚本的时候，有时候会遇到变量未定义（如：拼写错误导致变量未定义），Bash 默认是忽略它并且继续执行的，在某些场景这可能会对后面的脚本造成不可预期的错误操作， 所以可以通过 <code>set -u</code> 来控制，具体案例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line"></span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>​    可以看到，<code>echo $a</code> 输出了一个空行，Bash 忽略了不存在的 $a，然后继续执行 <code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p><p>通过脚本在头部加上 <code>set -u</code> 后，遇到不存在的变量就会报错，并停止执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -u</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 4: a: unbound variable</span><br></pre></td></tr></table></figure><h4 id="（2）set-x"><a href="#（2）set-x" class="headerlink" title="（2）set -x"></a>（2）set -x</h4><p>​    在执行复杂脚本的时候，需要对脚本进行类似debug一样的操作，则可以通过设置 <code>set -x</code>，这样就会对脚本中的执行过程的变量以及具体执行的代码进行输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line">name=<span class="string">&quot;tester&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;name&#125;</span> == <span class="string">&quot;tester&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;failed...&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> end</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">+ name=tester</span><br><span class="line">+ [[ tester == \t\e\s\t\e\r ]]</span><br><span class="line">+ <span class="built_in">echo</span> hello</span><br><span class="line">hello</span><br><span class="line">+ <span class="built_in">echo</span> end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>​    可以看到，在进行条件判断的时候，变量name被具体值替换了，打印了代码走到了条件分支的哪一步，以及打印了相应的有输出的代码行，行首以+表示。这对于调试复杂的脚本是很有用的。</p><h4 id="（3）set-e"><a href="#（3）set-e" class="headerlink" title="（3）set -e"></a>（3）set -e</h4><p>​    如果脚本里面有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令，在实际开发中，这种会导致比较严重的影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 5: foo: <span class="built_in">command</span> not found</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>通过使用 <code>set -e</code> 则可以运行失败的命令就直接退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 6: foo: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>也可以通过下面的方式来指定具体某个代码块运行失败后自动退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -e      <span class="comment"># 表示打开遇到运行命令返回非0则退出</span></span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line"><span class="built_in">set</span> +e      <span class="comment"># 表示关闭遇到运行命令返回非0则退出</span></span><br></pre></td></tr></table></figure><h4 id="（4）set-o-pipefail"><a href="#（4）set-o-pipefail" class="headerlink" title="（4）set -o pipefail"></a>（4）set -o pipefail</h4><p>​    <code>set -e</code> 有一个例外情况，就是不适用于管道命令。Bash 会把<strong>最后一个子命令的返回值</strong>，作为<strong>整个命令的返回值</strong>。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code> 就失效了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">foo | <span class="built_in">echo</span> a</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 7: foo: <span class="built_in">command</span> not found</span><br><span class="line">a</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>​    上面代码中，<strong>foo</strong>是一个不存在的命令，但是 <code>foo | echo a</code> 这个管道命令会执行成功，导致后面的 <code>echo bar</code> 会继续执行。</p><p>​     <code>set -eo pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本会在该管道执行完后终止执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line"></span><br><span class="line">foo | <span class="built_in">echo</span> a</span><br><span class="line"><span class="built_in">echo</span> bar</span><br><span class="line">$ bash set_test.sh</span><br><span class="line">set_test.sh: line 7: foo: <span class="built_in">command</span> not found</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>​    可以看出，管道任务失败后，echo bar则未进行执行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    set命令的上面这四个参数，一般都放在一起使用，常用的两种方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell 脚本调试 </tag>
            
            <tag> Linux 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之优化（一）</title>
      <link href="posts/a3ff5801/"/>
      <url>posts/a3ff5801/</url>
      
        <content type="html"><![CDATA[<p>​    继上一篇搭建完最基础的Hexo环境并且发布一篇Demo文章后，基本上能满足了平时的个人Blog编写以及发布，但很多地方还是用户体验不太好，于是再对自己的Blog进行一系列的优化😁😁。</p><h4 id="优化一：Hexo-主题优化"><a href="#优化一：Hexo-主题优化" class="headerlink" title="优化一：Hexo 主题优化"></a>优化一：Hexo 主题优化</h4><p>​    网上搜了下大部分都用的 <a href="https://github.com/next-theme/hexo-theme-next">nexT</a> 这个主题，于是就直接参照对应的 <a href="https://theme-next.js.org/docs/getting-started/">官网链接</a> 操作即可。（顺便继续记录一些遇到的坑~~）如果觉得默认的主题已经不错了的可以直接跳过改步骤（<strong>但后续优化<font color=red>基于nexT v8.2.1版本优化</font>，不一定全部通用于其他主题</strong>）。</p><a id="more"></a><ul><li><p><strong>问题1: 由于官网是英文版，在网上搜索中文版本代码过老导致启动进入 localhost:4000页面仅展示如下错误内容。</strong></p><p>如果你看的教程是 <code>https://theme-next.iissnan.com/getting-started.html</code>，那么就要注意了，该链接中的nexT代码过于老旧了，可能会存在一定的问题，建议使用 <a href="https://theme-next.js.org/docs/getting-started/">官网链接</a> 。</p></li></ul><p><strong>参照最新版的教程修改完主题后，最新的样式就如下图：</strong></p><img src="https://i.loli.net/2021/02/03/1jk4csEovyJWgnM.png" alt="hexo_default.png" style="zoom:30%;" /><p>​    这个时候问题来了，<strong>如果每篇文章都如上，篇幅比较长，那么就导致首页每次展示的文章数量过少。</strong></p><h4 id="优化二：文章折叠展示-对文章添加分类、标签等"><a href="#优化二：文章折叠展示-对文章添加分类、标签等" class="headerlink" title="优化二：文章折叠展示 + 对文章添加分类、标签等"></a>优化二：文章折叠展示 + 对文章添加分类、标签等</h4><ul><li><p>步骤一：修改nexT主题目录下的_config.yml配置 (将文件中的注释去掉即可)。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure></li><li><p>步骤二：给文章添加对应的属性（如：tags、categories、description）。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="string">首次搭建个人Blog</span> <span class="string">问题记录（一）</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-02-01 22:14:05</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">blog搭建</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo建站</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">hexo建站</span></span><br></pre></td></tr></table></figure><p><strong>问题2：设置首页新增了 <code>tags 和 categories</code> 页后，点击进入到对应的 tags 或者 categories 的时候没有想要的内容， 仅仅一个 tags 或者 categories 标签。</strong></p><p>原因: 在执行 <code>hexo new page &quot;tags&quot;</code> 这一步自动生成的index.md 文件中内容缺失导致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决办法如下操作，打开对应的 blog_dir/source/tags/index.md 文件, 在最后补充如下代码</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span><span class="comment"># about/categories页操作将tags替换成about/categories即可</span></span><br></pre></td></tr></table></figure></li><li><p>步骤三：文章折叠的<a href="http://theme-next.iissnan.com/faqs.html#%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95">解决办法</a> (个人选择了方法一)</p></li></ul><p>优化完后的效果如下：</p><img src="https://i.loli.net/2021/02/03/1I6TEuywBj2QG7R.png" alt="nexT_first.png" style="zoom:40%;" /><h4 id="优化三：-文章生成短链接"><a href="#优化三：-文章生成短链接" class="headerlink" title="优化三： 文章生成短链接"></a>优化三： 文章生成短链接</h4><p>点开上图的阅读全文后，发现整体的链接是一大串文字，这个时候看起来就比较怪异，并且复制出来后直接会是URL编码的格式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://beanskingdom.github.io/2021/02/01/Hexo-首次搭建遇到的问题/#more</span><br><span class="line">https://beanskingdom.github.io/2021/02/01/Hexo-%E9%A6%96%E6%AC%A1%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/#more</span><br></pre></td></tr></table></figure><p>此时可以通过Hexo-abbrlink生成唯一永久文章链接（<a href="https://github.com/Rozbo/hexo-abbrlink">参考链接</a>）。 </p><p>最终的效果则为：<code>xxx/posts/48255dc8/#more</code></p><h4 id="优化四：修改文内链接样式"><a href="#优化四：修改文内链接样式" class="headerlink" title="优化四：修改文内链接样式"></a>优化四：修改文内链接样式</h4><p>nexT默认文章链接样式如下图：</p><img src="https://i.loli.net/2021/02/03/q2CwmFHZsNoyYlW.png" alt="next_link_style.png" style="zoom:40%;" /><p>为了突出区别性，我们在对应文件中添加下列的代码即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">themes</span>/<span class="selector-tag">next</span>/<span class="selector-tag">source</span>/<span class="selector-tag">css</span>/_<span class="selector-tag">common</span>/<span class="selector-tag">components</span>/<span class="selector-tag">post</span>/<span class="selector-tag">post-body</span><span class="selector-class">.styl</span></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的样式如下：</p><img src="https://i.loli.net/2021/02/03/L4j9vFUxBl2o3cM.png" alt="next_link_update.png" style="zoom:40%;" /><h4 id="优化五：给主页文章添加阴影效果"><a href="#优化五：给主页文章添加阴影效果" class="headerlink" title="优化五：给主页文章添加阴影效果"></a>优化五：给主页文章添加阴影效果</h4><p>打开<code>themes/next/source/css/_common/components/post/index.styl</code>文件，将<code>post-block</code>代码进行如下更改：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (hexo-config(&#x27;motion.transition.post_block&#x27;)) &#123;</span><br><span class="line">  # 添加如下代码</span><br><span class="line">    <span class="selector-class">.post-block</span>&#123;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">        <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">        background:rgba(255,255,255,0.9) none repeat scroll !important; //添加透明效果</span><br><span class="line">        <span class="selector-tag">-webkit-box-shadow</span>: 0 0 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(202, 203, 203, .5);</span><br><span class="line">        <span class="selector-tag">-moz-box-shadow</span>: 0 0 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(202, 203, 204, .5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="优化六：文章内部的导航栏位置优化"><a href="#优化六：文章内部的导航栏位置优化" class="headerlink" title="优化六：文章内部的导航栏位置优化"></a>优化六：文章内部的导航栏位置优化</h4><p>默认文章内部的导航栏位置是在左侧，看文章时候比较怪异，所以优化到了右边。</p><p>打开 <code>themes/next/_config.yml</code> 文件，将如下代码修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="comment"># position: left# 将改行注释掉，再去掉下面一行的注释</span></span><br><span class="line">  position: right</span><br></pre></td></tr></table></figure><h4 id="优化七：给文章末尾添加结束语"><a href="#优化七：给文章末尾添加结束语" class="headerlink" title="优化七：给文章末尾添加结束语"></a>优化七：给文章末尾添加结束语</h4><ul><li><p>在 <code>themes/next/layout/_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件，添加代码至该文件中；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">      &lt;div style=<span class="string">&quot;text-align:center;color: #ccc;font-size:20px;&quot;</span>&gt;------------- 本 文 结 束 &lt;i class=<span class="string">&quot;fa fa-paw&quot;</span>&gt;&lt;/i&gt; 感 谢 您 的 阅 读 -------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>themes/next/layout/_macro/post.njk</code> 文件，在 post-body 后，post-footer 前，添加下面内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">&#x27;passage-end-tag.swig&#x27;</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在如下内容之前添加上述代码</span></span><br><span class="line"><span class="comment">#    &#123;#####################&#125;</span></span><br><span class="line"><span class="comment">#    &#123;### END POST BODY ###&#125;</span></span><br><span class="line"><span class="comment">#    &#123;#####################&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在主题配置文件 <code>_config.yml</code> 在末尾添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="优化八：给代码块添加复制功能"><a href="#优化八：给代码块添加复制功能" class="headerlink" title="优化八：给代码块添加复制功能"></a>优化八：给代码块添加复制功能</h4><p>打开 <code>themes/next/_config.yml</code> 主题配置文件，搜索 codeblock ,开启复制，修改代码如下。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">copy_button:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span><span class="comment"># 显示复制按钮</span></span><br><span class="line">  <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">flat</span><span class="comment"># 复制按钮展示形式</span></span><br></pre></td></tr></table></figure><h4 id="优化九：实现统计功能"><a href="#优化九：实现统计功能" class="headerlink" title="优化九：实现统计功能"></a>优化九：实现统计功能</h4><p>在根目录下安装 <code>hexo-wordcount</code>,运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>然后在主题的配置文件中，配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    至此，部分个人体验相关的优化已经结束，这个时候可以开心的写blog了，自己看起来效果也不错，但这样你满足了么？？</p><p>​    当然不满意啦！！！ 至少要看到有多少人来看我的blog吧？😄😄静待后续优化。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 首次搭建个人Blog问题记录</title>
      <link href="posts/48255dc8/"/>
      <url>posts/48255dc8/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    看到别人那么炫酷的个人Blog后，自己也突然有了一些想法，既而最近看了《小强升职记》中的第五章让目标落地，于是便马上开始规划起了自己的Blog。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>​    通过这个Blog记录生活中的点点滴滴。</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>​    由于这类型的文章在网上太多了。。。具体的搭建过程就不一一搬运了。（个人觉得比较详细的一个链接：<a href="https://www.cnblogs.com/shwee/p/11421156.html">Hexo+Github: 个人博客网站搭建完全教程(看这篇就够了)</a>）</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>​    emm…有一个比较详细的教程是多么重要的一件事，虽然别人的Blog上看起来也就1个小时的事，实际自己做起来却花费了大半天😭😭。。。总结了以下在搭建过程中自己遇到的坑。</p><ol><li><p><strong>执行修改_config.yml文件后，执行创建新的文章命令时候报错。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;Bigbean&#x27;s demo&quot;</span></span><br><span class="line">FATAL TypeError: Invalid config detected: <span class="string">&quot;url&quot;</span> should be string, not object!</span><br><span class="line"></span><br><span class="line">原因：拷贝其他教程的配置文件时候，url:  <span class="comment">#网址 这个地方未配置</span></span><br></pre></td></tr></table></figure></li><li><p><strong>发布了第一篇文章后，页面打开显示错误。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端里面报错 </span></span><br><span class="line">WARN  No layout: index.html</span><br></pre></td></tr></table></figure><p>原因：在步骤3中按照参考链接中改了配置后，实际并没有链接中的那个主题 <code>theme: landscape-plus</code>， </p><p>所以<font color=red><strong>修改_config.yml配置文件的时候一定要注意！！！再次提醒不要全部照抄，应该仅仅是改自己需要改的地方。</strong></font></p></li><li><p><strong>在执行 <code>hexo d</code> 发布的时候报错。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: git</span><br><span class="line"><span class="comment"># 这是因为没安装hexo-deployer-git插件，在站点目录下输入下面的插件安装就好了</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p><strong>怎么再通过github的链接直接访问网上远端的效果呢？</strong></p><p>进入 github 项目中点击 Settings，向下拉到最后有个 GitHub Pages，点击 Choose a theme 选择一个主题。然后等一会儿，再回到 GitHub Pages，就会变成你选择的主题。<a href="https://zhuanlan.zhihu.com/p/35668237">参考链接</a></p></li><li><p><strong>按照6中的操作后，github page一直未被识别，导致点击链接去看里面样式找不到。（<a href="https://www.cnblogs.com/shwee/p/11421156.html">参考链接</a>）</strong></p><p>原因： 要创建一个和你用户名相同的仓库，后面加 <strong>.github.io</strong>，只有这样，将来要部署到 <code>GitHub page</code> 的时候，才会被识别 。例如我的：<a href="https://beanskingdom.github.io/">beanskingdom.github.io</a></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        至此。。。终于完成了第一篇内容的发布，后续还会继续进行相关的优化，如：主题、评论、搜索等等。</p>]]></content>
      
      
      <categories>
          
          <category> hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
            <tag> hexo建站 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
